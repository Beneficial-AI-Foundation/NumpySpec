/-!
{
  "name": "numpy.nanmean",
  "category": "Averages and variances",
  "description": "Compute the arithmetic mean along the specified axis, ignoring NaNs",
  "url": "https://numpy.org/doc/stable/reference/generated/numpy.nanmean.html",
  "doc": "numpy.nanmean(a, axis=None, dtype=None, out=None, keepdims=<no value>, *, where=<no value>)\n\nCompute the arithmetic mean along the specified axis, ignoring NaNs.\n\nReturns the average of the array elements. The average is taken over the flattened array by default, otherwise over the specified axis. float64 intermediate and return values are used for integer inputs.\n\nFor all-NaN slices, NaN is returned and a RuntimeWarning is raised.\n\nParameters\n----------\na : array_like\n    Array containing numbers whose mean is desired. If a is not an array, a conversion is attempted.\naxis : {int, tuple of int, None}, optional\n    Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.\ndtype : data-type, optional\n    Type to use in computing the mean. For integer inputs, the default is float64; for inexact inputs, it is the same as the input dtype.\nout : ndarray, optional\n    Alternate output array in which to place the result. The default is None.\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\nwhere : array_like of bool, optional\n    Elements to include in the mean.\n\nReturns\n-------\nm : ndarray, see dtype parameter above\n    If out=None, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.",
  "code": "# Implementation in numpy/lib/_nanfunctions_impl.py\n@array_function_dispatch(_nanmean_dispatcher)\ndef nanmean(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,\n            *, where=np._NoValue):\n    \"\"\"\n    Compute the arithmetic mean along the specified axis, ignoring NaNs.\n    \"\"\"\n    arr, mask = _replace_nan(a, 0)\n    if mask is None:\n        return np.mean(arr, axis=axis, dtype=dtype, out=out, keepdims=keepdims,\n                       where=where)\n    \n    if dtype is not None:\n        dtype = np.dtype(dtype)\n    if dtype is not None and not issubclass(dtype.type, np.inexact):\n        raise TypeError(\"If a is inexact, then dtype must be inexact\")\n    if out is not None and not issubclass(out.dtype.type, np.inexact):\n        raise TypeError(\"If a is inexact, then out must be inexact\")\n    \n    cnt = np.sum(~mask, axis=axis, dtype=np.intp, keepdims=keepdims,\n                 where=where)\n    tot = np.sum(arr, axis=axis, dtype=dtype, out=out, keepdims=keepdims,\n                 where=where)\n    avg = _divide_by_count(tot, cnt, out=out)\n    \n    isbad = (cnt == 0)\n    if isbad.any():\n        warnings.warn(\"Mean of empty slice\", RuntimeWarning, stacklevel=2)\n        # NaN is the only possible bad value, so no further\n        # action is needed to handle bad results.\n    return avg"
}
-/

-- TODO: Implement nanmean
