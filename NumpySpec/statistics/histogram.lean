/-!
{
  "name": "numpy.histogram",
  "category": "Histograms",
  "description": "Compute the histogram of a dataset",
  "url": "https://numpy.org/doc/stable/reference/generated/numpy.histogram.html",
  "doc": "numpy.histogram(a, bins=10, range=None, density=None, weights=None)\n\nCompute the histogram of a dataset.\n\nParameters\n----------\na : array_like\n    Input data. The histogram is computed over the flattened array.\nbins : int or sequence of scalars or str, optional\n    If bins is an int, it defines the number of equal-width bins in the given range (10, by default). If bins is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.\nrange : (float, float), optional\n    The lower and upper range of the bins. If not provided, range is simply (a.min(), a.max()). Values outside the range are ignored.\ndensity : bool, optional\n    If False, the result will contain the number of samples in each bin. If True, the result is the value of the probability density function at the bin, normalized such that the integral over the range is 1.\nweights : array_like, optional\n    An array of weights, of the same shape as a. Each value in a only contributes its associated weight towards the bin count (instead of 1).\n\nReturns\n-------\nhist : array\n    The values of the histogram.\nbin_edges : array of dtype float\n    Return the bin edges (length(hist)+1).",
  "code": "# Implementation in numpy/lib/_histograms_impl.py\n@array_function_dispatch(_histogram_dispatcher)\ndef histogram(a, bins=10, range=None, density=None, weights=None):\n    \"\"\"\n    Compute the histogram of a dataset.\n    \"\"\"\n    a, weights = _ravel_and_check_weights(a, weights)\n    \n    bin_edges, uniform_bins = _get_bin_edges(a, bins, range, weights)\n    \n    # Histogram is an integer or a float array depending on the weights.\n    if weights is None:\n        ntype = np.dtype(np.intp)\n    else:\n        ntype = weights.dtype\n    \n    # We set a block size, as this allows us to iterate over chunks when\n    # computing histograms, to minimize memory usage.\n    BLOCK = 65536\n    \n    # The fast path uses bincount, but that only works for certain types\n    # of weight\n    simple_weights = (\n        weights is None or\n        np.can_cast(weights.dtype, np.double) or\n        np.can_cast(weights.dtype, complex)\n    )\n    \n    if uniform_bins is not None and simple_weights:\n        # Fast algorithm for equal bins\n        # We now convert values of a to bin indices, under the assumption of\n        # equal bin widths (which is valid here).\n        first_edge, last_edge, n_equal_bins = uniform_bins\n        \n        # Initialize empty histogram\n        n = np.zeros(n_equal_bins, ntype)\n        \n        # Pre-compute histogram scaling factor\n        norm_numerator = n_equal_bins\n        norm_denom = _unsigned_subtract(last_edge, first_edge)\n        \n        # We iterate over blocks here for two reasons: the first is that for\n        # large arrays, it is actually faster (for example for a 10^8 array it\n        # is 2x as fast) and it results in a memory footprint 3x lower in the\n        # limit of large arrays.\n        for i in _range(0, len(a), BLOCK):\n            tmp_a = a[i:i+BLOCK]\n            if weights is None:\n                tmp_w = None\n            else:\n                tmp_w = weights[i:i + BLOCK]\n            \n            # Only include values in the right range\n            keep = (tmp_a >= first_edge)\n            keep &= (tmp_a <= last_edge)\n            if not np.logical_and.reduce(keep):\n                tmp_a = tmp_a[keep]\n                if tmp_w is not None:\n                    tmp_w = tmp_w[keep]\n            \n            # Compute bin indices, and for values that lie exactly on\n            # last_edge we need to subtract one\n            f_indices = ((_unsigned_subtract(tmp_a, first_edge) /\n                          norm_denom) * norm_numerator)\n            indices = f_indices.astype(np.intp)\n            indices[indices == n_equal_bins] -= 1\n            \n            # The index computation is not guaranteed to give exactly\n            # consistent results within ~1 ULP of the bin edges.\n            decrement = tmp_a < bin_edges[indices]\n            indices[decrement] -= 1\n            # The last bin includes the right edge. The other bins do not.\n            increment = ((tmp_a >= bin_edges[indices + 1])\n                         & (indices != n_equal_bins - 1))\n            indices[increment] += 1\n            \n            # We now compute the histogram using bincount\n            if ntype.kind == 'c':\n                n.real += np.bincount(indices, weights=tmp_w.real,\n                                      minlength=n_equal_bins)\n                n.imag += np.bincount(indices, weights=tmp_w.imag,\n                                      minlength=n_equal_bins)\n            else:\n                n += np.bincount(indices, weights=tmp_w,\n                                 minlength=n_equal_bins).astype(ntype)\n    else:\n        # Compute via cumulative histogram\n        cum_n = np.zeros(bin_edges.shape, ntype)\n        if weights is None:\n            for i in _range(0, len(a), BLOCK):\n                sa = np.sort(a[i:i+BLOCK])\n                cum_n += _search_sorted_inclusive(sa, bin_edges)\n        else:\n            zero = np.zeros(1, dtype=ntype)\n            for i in _range(0, len(a), BLOCK):\n                tmp_a = a[i:i+BLOCK]\n                tmp_w = weights[i:i+BLOCK]\n                sorting_index = np.argsort(tmp_a)\n                sa = tmp_a[sorting_index]\n                sw = tmp_w[sorting_index]\n                cw = np.concatenate((zero, sw.cumsum()))\n                bin_index = _search_sorted_inclusive(sa, bin_edges)\n                cum_n += cw[bin_index]\n        \n        n = np.diff(cum_n)\n    \n    # density overrides the density keyword argument\n    if density:\n        db = np.array(np.diff(bin_edges), float)\n        return n/db/n.sum(), bin_edges\n    \n    return n, bin_edges"
}
-/

-- TODO: Implement histogram
