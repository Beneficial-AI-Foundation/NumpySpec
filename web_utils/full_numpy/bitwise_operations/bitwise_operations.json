{
  "metadata": {
    "module": "numpy",
    "source": "https://github.com/numpy/numpy/blob/main/numpy/core/src/umath/loops.c.src",
    "c_implementations": [
      "numpy/core/src/umath/loops.c.src",
      "numpy/lib/src/_compiled_base.c"
    ],
    "description": "NumPy bitwise operations - element-wise bit manipulation functions implemented as universal functions (ufuncs)"
  },
  "functions": [
    {
      "name": "numpy.bitwise_and",
      "category": "Elementwise bit operations",
      "description": "Compute the bit-wise AND of two arrays element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.bitwise_and.html",
      "doc": "Compute the bit-wise AND of two arrays element-wise.\n\nComputes the bit-wise AND of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator &.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled.\n    If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result.\n\nReturns\n-------\nout : ndarray or scalar\n    Result. This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\nlogical_and\nbitwise_or\nbitwise_xor\nbinary_repr : Return the binary representation of the input number as a string.",
      "code": "# C implementation for performance\n# Compute the bit-wise AND of two arrays element-wise\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/core/src/umath/loops.c.src:\n\n/**begin repeat\n * #kind = add, subtract, multiply, bitwise_and, bitwise_or, bitwise_xor#\n * #OP = +, -, *, &, |, ^#\n */\n\nBINARY_LOOP_FAST(LONG, @LONG@, *out = in1 @OP@ in2)\n\n/* The BINARY_LOOP_FAST macro expands to efficient C code that performs\n * the bitwise AND operation using the & operator on each element pair */\n\n/* For the & operator: */\n/* *out = in1 & in2 */"
    },
    {
      "name": "numpy.bitwise_or",
      "category": "Elementwise bit operations",
      "description": "Compute the bit-wise OR of two arrays element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.bitwise_or.html",
      "doc": "Compute the bit-wise OR of two arrays element-wise.\n\nComputes the bit-wise OR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator |.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled.\n    If x1.shape != x2.shape, they must be broadcastable to a common shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored.\nwhere : array_like, optional\n    This condition is broadcast over the input.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n\nExamples\n--------\n>>> np.bitwise_or(13, 16)\n29\n>>> np.array([2, 5, 255]) | np.array([4, 4, 4])\narray([6, 5, 255])\n>>> np.bitwise_or([33, 4], 1)\narray([33, 5])\n>>> np.bitwise_or([33, 4], [1, 2])\narray([33, 6])",
      "code": "# C implementation for performance\n# Compute the bit-wise OR of two arrays element-wise\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/core/src/umath/loops.c.src:\n\n/**begin repeat\n * #kind = add, subtract, multiply, bitwise_and, bitwise_or, bitwise_xor#\n * #OP = +, -, *, &, |, ^#\n */\n\nBINARY_LOOP_FAST(LONG, @LONG@, *out = in1 @OP@ in2)\n\n/* For the | operator: */\n/* *out = in1 | in2 */"
    },
    {
      "name": "numpy.bitwise_xor",
      "category": "Elementwise bit operations",
      "description": "Compute the bit-wise XOR of two arrays element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.bitwise_xor.html",
      "doc": "Compute the bit-wise XOR of two arrays element-wise.\n\nComputes the bit-wise XOR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator ^.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled.\n    If x1.shape != x2.shape, they must be broadcastable to a common shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored.\nwhere : array_like, optional\n    This condition is broadcast over the input.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n\nExamples\n--------\n>>> np.bitwise_xor(13, 17)\n28\n>>> np.bitwise_xor(31, 5)\n26\n>>> np.bitwise_xor([31,3], 5)\narray([26, 6])\n>>> np.bitwise_xor([31,3], [5,6])\narray([26, 5])\n>>> np.array([True, True]) ^ np.array([False, True])\narray([True, False])",
      "code": "# C implementation for performance\n# Compute the bit-wise XOR of two arrays element-wise\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/core/src/umath/loops.c.src:\n\n/**begin repeat\n * #kind = add, subtract, multiply, bitwise_and, bitwise_or, bitwise_xor#\n * #OP = +, -, *, &, |, ^#\n */\n\nBINARY_LOOP_FAST(LONG, @LONG@, *out = in1 @OP@ in2)\n\n/* For the ^ operator: */\n/* *out = in1 ^ in2 */"
    },
    {
      "name": "numpy.invert",
      "category": "Elementwise bit operations",
      "description": "Compute bit-wise inversion, or bit-wise NOT, element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.invert.html",
      "doc": "Compute bit-wise inversion, or bit-wise NOT, element-wise.\n\nComputes the bit-wise NOT of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator ~.\n\nFor signed integer inputs, the two's complement is returned. In a two's-complement system negative numbers are represented by the two's complement of the absolute value. This is the most common method of representing signed integers on computers. A N-bit two's-complement system can represent every integer in the range -2^(N-1) to +2^(N-1)-1.\n\nParameters\n----------\nx : array_like\n    Only integer and boolean types are handled.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored.\nwhere : array_like, optional\n    This condition is broadcast over the input.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n\nNotes\n-----\nbitwise_not is an alias for invert:\n\n>>> np.bitwise_not is np.invert\nTrue\n\nExamples\n--------\n>>> np.invert(np.array([13], dtype=np.uint8))\narray([242], dtype=uint8)\n>>> np.invert(np.array([13], dtype=np.uint16))\narray([65522], dtype=uint16)\n>>> np.invert(np.array([13], dtype=np.int8))\narray([-14], dtype=int8)\n>>> np.invert(np.array([True, False]))\narray([False, True])",
      "code": "# C implementation for performance\n# Compute bit-wise inversion, or bit-wise NOT, element-wise\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/core/src/umath/loops.c.src:\n\nUNARY_LOOP_FAST(LONG, @LONG@, *out = ~in)"
    },
    {
      "name": "numpy.left_shift",
      "category": "Bit shifting",
      "description": "Shift the bits of an integer to the left",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.left_shift.html",
      "doc": "Shift the bits of an integer to the left.\n\nBits are shifted to the left by appending x2 0s at the right of x1. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying x1 by 2**x2.\n\nParameters\n----------\nx1 : array_like of integer type\n    Input values.\nx2 : array_like of integer type\n    Number of zeros to append to x1. Has to be non-negative.\n    If x1.shape != x2.shape, they must be broadcastable to a common shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored.\nwhere : array_like, optional\n    This condition is broadcast over the input.\n\nReturns\n-------\nout : ndarray of integer type\n    Return x1 with bits shifted x2 times to the left.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\nright_shift : Shift the bits of an integer to the right.\nbinary_repr : Return the binary representation of the input number as a string.\n\nExamples\n--------\n>>> np.left_shift(5, 2)\n20\n>>> np.left_shift(5, [1,2,3])\narray([10, 20, 40])\n\nNote that the dtype of the second argument may change the dtype of the result and can lead to unexpected results in some cases:\n\n>>> a = np.left_shift(np.uint8(255), 1) # Expect 254\n>>> print(a, type(a)) # Unexpected result due to upcasting\n510 <class 'numpy.int64'>\n>>> b = np.left_shift(np.uint8(255), np.uint8(1))\n>>> print(b, type(b))\n254 <class 'numpy.uint8'>",
      "code": "# C implementation for performance\n# Shift the bits of an integer to the left\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/core/src/umath/loops.c.src:\n\n/**begin repeat\n * #kind = left_shift, right_shift#\n * #OP = <<, >>#\n */\n\nBINARY_LOOP_FAST(INT, @INT@, *out = npy_lshift@c@(in1, in2))\n\n/* The implementation uses safe shift functions that handle\n * platform-specific behavior and prevent undefined behavior\n * from shifting by more bits than the type width */\n\n/* npy_lshift functions ensure the behavior is independent of\n * whether a compiler's shift instructions mask the count by\n * the number of bits in the type, which can produce\n * surprising results. */"
    },
    {
      "name": "numpy.right_shift",
      "category": "Bit shifting",
      "description": "Shift the bits of an integer to the right",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.right_shift.html",
      "doc": "Shift the bits of an integer to the right.\n\nBits are shifted to the right x2. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing x1 by 2**x2.\n\nParameters\n----------\nx1 : array_like, int\n    Input values.\nx2 : array_like, int\n    Number of bits to remove at the right of x1.\n    If x1.shape != x2.shape, they must be broadcastable to a common shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored.\nwhere : array_like, optional\n    This condition is broadcast over the input.\n\nReturns\n-------\nout : ndarray, int\n    Return x1 with bits shifted x2 times to the right.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\nleft_shift : Shift the bits of an integer to the left.\nbinary_repr : Return the binary representation of the input number as a string.\n\nExamples\n--------\n>>> np.right_shift(10, 1)\n5\n>>> np.right_shift(10, [1,2,3])\narray([5, 2, 1])\n\nThe >> operator can be used as a shorthand for np.right_shift on ndarrays.\n\n>>> x1 = 10\n>>> x2 = np.array([1,2,3])\n>>> x1 >> x2\narray([5, 2, 1])",
      "code": "# C implementation for performance\n# Shift the bits of an integer to the right\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/core/src/umath/loops.c.src:\n\n/**begin repeat\n * #kind = left_shift, right_shift#\n * #OP = <<, >>#\n */\n\nBINARY_LOOP_FAST(INT, @INT@, *out = npy_rshift@c@(in1, in2))\n\n/* Uses safe right shift functions that handle signed/unsigned\n * differences and platform-specific behavior */"
    },
    {
      "name": "numpy.packbits",
      "category": "Bit packing",
      "description": "Packs the elements of a binary-valued array into bits in a uint8 array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.packbits.html",
      "doc": "Packs the elements of a binary-valued array into bits in a uint8 array.\n\nThe result is padded to full bytes by inserting zero bits at the end.\n\nParameters\n----------\na : array_like\n    An array of integers or booleans whose elements should be packed to bits.\naxis : int, optional\n    The dimension over which bit-packing is done.\n    None implies packing the flattened array.\nbitorder : {'big', 'little'}, optional\n    The order of the input bits. 'big' will mimic bin(val), 3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1], 'little' will reverse the order to [1, 1, 0, 0, 0, 0, 0, 0].\n    Defaults to 'big'.\n\nReturns\n-------\npacked : ndarray\n    Array of type uint8 whose elements represent bits corresponding to the logical (0 or nonzero) value of the input elements. The shape of packed has the same number of dimensions as the input (unless axis is None, in which case the output is 1-D).\n\nExamples\n--------\n>>> a = np.array([[[1,0,1],\n...                [0,1,0]],\n...               [[1,1,0],\n...                [0,0,1]]])\n>>> b = np.packbits(a, axis=-1)\n>>> b\narray([[[160],\n        [ 64]],\n       [[192],\n        [ 32]]], dtype=uint8)\n\nNote that in binary 160 = 2^5 + 2^7, 64 = 2^6, 192 = 2^6 + 2^7, and 32 = 2^5.",
      "code": "# C implementation for performance\n# Packs the elements of a binary-valued array into bits in a uint8 array\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/lib/src/_compiled_base.c:\n\nstatic void\n_packbits(\n    void *In,\n    npy_intp in_N,\n    npy_intp in_stride,\n    void *Out,\n    npy_intp out_N,\n    npy_intp out_stride,\n    int axis,\n    char order)\n{\n    char build;\n    int i, j, inindex, outindex, remain, packing_type;\n    void (*pack_routine)(char *, char *);\n    \n    if (order == 'b')\n        pack_routine = pack_bitorder_big;\n    else if (order == 'l')\n        pack_routine = pack_bitorder_little;\n    else {\n        PyErr_SetString(PyExc_ValueError,\n                \"'order' must be either 'b' (big) or 'l' (little)\");\n        return;\n    }\n    \n    remain = in_N % 8;               /* uneven bits */\n    if (remain == 0) {\n        packing_type = PACK_FULL;\n    } else {\n        packing_type = PACK_PARTIAL;\n    }\n    \n    for (i = 0; i < out_N; i++) {\n        build = 0;                   /* essential to set to 0 */\n        outindex = i*out_stride;\n        /* Loop through full bytes */\n        for (j = 0; j < 8*(packing_type == PACK_FULL ? 1 : 0); j++) {\n            inindex = ((i*8) + j)*in_stride;\n            build |= (Py_CHARMASK(*(npy_uint8 *)(In + inindex)) != 0) << j;\n        }\n        if ((packing_type == PACK_PARTIAL) && (i == out_N - 1)) {\n            /* Handle the last byte */ \n            for (j = 0; j < remain; j++) {\n                inindex = ((i*8) + j)*in_stride;\n                build |= (Py_CHARMASK(*(npy_uint8 *)(In + inindex)) != 0) << j;\n            }\n        }\n        pack_routine(&build, (char *)(Out + outindex));\n    }\n}"
    },
    {
      "name": "numpy.unpackbits",
      "category": "Bit packing",
      "description": "Unpacks elements of a uint8 array into a binary-valued output array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.unpackbits.html",
      "doc": "Unpacks elements of a uint8 array into a binary-valued output array.\n\nEach element of a represents a bit-field that should be unpacked into a binary-valued output array. The shape of the output array is either 1-D (if axis is None) or the same shape as the input array with unpacking done along the axis specified.\n\nParameters\n----------\na : ndarray, uint8 type\n    Input array.\naxis : int, optional\n    The dimension over which bit-unpacking is done.\n    None implies unpacking the flattened array.\ncount : int or None, optional\n    The number of elements to unpack along axis, provided as a way of undoing the effect of packing a size that is not a multiple of eight. A non-negative number means to only unpack count bits. A negative number means to trim off that many bits from the end. None means to unpack the entire array (the default). Counts larger than the available number of bits will add zero padding to the output. Negative counts must not exceed the available number of bits.\nbitorder : {'big', 'little'}, optional\n    The order of the returned bits. 'big' will mimic bin(val), 3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1], 'little' will reverse the order to [1, 1, 0, 0, 0, 0, 0, 0].\n    Defaults to 'big'.\n\nReturns\n-------\nunpacked : ndarray, uint8 type\n    The elements are binary-valued (0 or 1).\n\nExamples\n--------\n>>> a = np.array([[2], [7], [23]], dtype=np.uint8)\n>>> a\narray([[ 2],\n       [ 7],\n       [23]], dtype=uint8)\n>>> b = np.unpackbits(a, axis=1)\n>>> b\narray([[0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\n>>> c = np.unpackbits(a, axis=1, count=-3)\n>>> c\narray([[0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0]], dtype=uint8)",
      "code": "# C implementation for performance\n# Unpacks elements of a uint8 array into a binary-valued output array\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/lib/src/_compiled_base.c:\n\nstatic void\n_unpackbits(\n    void *In,\n    npy_intp in_N,\n    npy_intp in_stride,\n    void *Out,\n    npy_intp out_N,\n    npy_intp out_stride,\n    char order)\n{\n    char mask;\n    int i, j, inindex, outindex, remain, unpacking_type;\n    void (*unpack_routine)(char, char *);\n    \n    if (order == 'b')\n        unpack_routine = unpack_bitorder_big;\n    else if (order == 'l')\n        unpack_routine = unpack_bitorder_little;\n    else {\n        PyErr_SetString(PyExc_ValueError,\n                \"'order' must be either 'b' (big) or 'l' (little)\");\n        return;\n    }\n    \n    if (out_N != in_N * 8) {\n        remain = out_N % 8;\n        if (remain == 0) {\n            unpacking_type = UNPACK_FULL;\n        } else {\n            unpacking_type = UNPACK_PARTIAL;\n        }\n    } else {\n        unpacking_type = UNPACK_FULL;\n    }\n    \n    for (i = 0; i < in_N; i++) {\n        inindex = i*in_stride;\n        mask = *(npy_uint8 *)(In + inindex);\n        \n        if (i == in_N - 1 && unpacking_type == UNPACK_PARTIAL) {\n            /* last byte is only partially filled */\n            for (j = 0; j < remain; j++) {\n                outindex = ((i*8) + j)*out_stride;\n                unpack_routine(mask, (char *)(Out + outindex));\n                mask >>= 1;\n            }\n        } else {\n            /* Full byte */\n            for (j = 0; j < 8; j++) {\n                outindex = ((i*8) + j)*out_stride;\n                unpack_routine(mask, (char *)(Out + outindex));\n                mask >>= 1;\n            }\n        }\n    }\n}"
    },
    {
      "name": "numpy.bitwise_count",
      "category": "Bit counting",
      "description": "Computes the number of 1-bits in the absolute value of x",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.bitwise_count.html",
      "doc": "Computes the number of 1-bits in the absolute value of x.\n\nAnalogous to the builtin int.bit_count or popcount in C++.\n\nParameters\n----------\nx : array_like, unsigned int\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result.\n\nReturns\n-------\ny : ndarray\n    The corresponding number of 1-bits in the input.\n    Returns uint8 for all integer types.\n    This is a scalar if x is a scalar.\n\nReferences\n----------\n.. [1] Wikipedia, \"Hamming weight\",\n       https://en.wikipedia.org/wiki/Hamming_weight\n.. [2] http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n.. [3] https://aggregate.ee.engr.uky.edu/MAGIC/#Population%20Count%20(Ones%20Count)\n\nExamples\n--------\n>>> np.bitwise_count(1023)\nnp.uint8(10)\n>>> a = np.array([2**i - 1 for i in range(16)])\n>>> np.bitwise_count(a)\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15],\n      dtype=uint8)",
      "code": "# C implementation for performance\n# Computes the number of 1-bits in the absolute value of x\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/core/src/umath/loops.c.src and npy_math.h:\n\n/* Popcount implementation from PR #19355 */\n/* Uses CountBitsSetParallel algorithm which takes 12 operations */\n\nstatic NPY_INLINE int\nnpy_popcount_parallel(npy_uintp a) {\n    /* CountBitsSetParallel algorithm */\n    a = a - ((a >> 1) & 0x5555555555555555ULL);\n    a = (a & 0x3333333333333333ULL) + ((a >> 2) & 0x3333333333333333ULL);\n    return (((a + (a >> 4)) & 0xF0F0F0F0F0F0F0FULL) * 0x101010101010101ULL) >> 56;\n}\n\n/* Platform-specific optimizations */\n#if defined(__GNUC__) || defined(__clang__)\n    /* Use builtin popcount when available */\n    #define npy_popcount(x) __builtin_popcountll(x)\n#elif defined(_MSC_VER)\n    /* Use Windows intrinsic */\n    #include <intrin.h>\n    #define npy_popcount(x) __popcnt64(x)\n#else\n    /* Fallback to parallel algorithm */\n    #define npy_popcount(x) npy_popcount_parallel(x)\n#endif\n\n/* Ufunc loop */\nUNARY_LOOP_FAST(ULONG, npy_uint8, *out = npy_popcount(in))"
    },
    {
      "name": "numpy.binary_repr",
      "category": "Output formatting",
      "description": "Return the binary representation of the input number as a string",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.binary_repr.html",
      "doc": "Return the binary representation of the input number as a string.\n\nFor negative numbers, if width is not given, a minus sign is added to the front. If width is given, the two's complement of the number is returned, with respect to that width.\n\nIn a two's-complement system negative numbers are represented by the two's complement of the absolute value. This is the most common method of representing signed integers on computers. A N-bit two's-complement system can represent every integer in the range -2^(N-1) to +2^(N-1)-1.\n\nParameters\n----------\nnum : int\n    Only an integer decimal number can be used.\nwidth : int, optional\n    The length of the returned string if num is positive, or the length of the two's complement if num is negative, provided that width is at least a sufficient number of bits for num to be represented in the designated form.\n\nReturns\n-------\nbin : str\n    Binary representation of num or two's complement of num.\n\nNotes\n-----\nbinary_repr is equivalent to using base_repr with base 2, but about 25x faster.\n\nReferences\n----------\n.. [1] Wikipedia, \"Two's complement\",\n    https://en.wikipedia.org/wiki/Two's_complement\n\nExamples\n--------\n>>> np.binary_repr(3)\n'11'\n>>> np.binary_repr(-3)\n'-11'\n>>> np.binary_repr(3, width=4)\n'0011'\n\nThe two's complement is returned when the input number is negative and width is specified:\n\n>>> np.binary_repr(-3, width=3)\n'101'\n>>> np.binary_repr(-3, width=5)\n'11101'",
      "code": "Python implementation in numpy/_core/numeric.py:\n\ndef binary_repr(num, width=None):\n    \"\"\"\n    Return the binary representation of the input number as a string.\n\n    For negative numbers, if width is not given, a minus sign is added to the\n    front. If width is given, the two's complement of the number is\n    returned, with respect to that width.\n\n    In a two's-complement system negative numbers are represented by the two's\n    complement of the absolute value. This is the most common method of\n    representing signed integers on computers [1]_. A N-bit two's-complement\n    system can represent every integer in the range\n    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\n    Parameters\n    ----------\n    num : int\n        Only an integer decimal number can be used.\n    width : int, optional\n        The length of the returned string if `num` is positive, or the length\n        of the two's complement if `num` is negative, provided that `width` is\n        at least a sufficient number of bits for `num` to be represented in\n        the designated form.\n\n        If the `width` value is insufficient, it will be ignored, and `num`\n        will be returned in binary (`num` > 0) or two's complement (`num` < 0)\n        form with its width equal to the minimum number of bits needed to\n        represent the number in the designated form. This behavior is\n        deprecated and will later raise an error.\n\n        .. deprecated:: 1.12.0\n\n    Returns\n    -------\n    bin : str\n        Binary representation of `num` or two's complement of `num`.\n\n    See Also\n    --------\n    base_repr: Return a string representation of a number in the given base\n               system.\n    bin: Python's built-in binary representation generator of an integer.\n\n    Notes\n    -----\n    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x\n    faster.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Two's complement\",\n        https://en.wikipedia.org/wiki/Two's_complement\n\n    Examples\n    --------\n    >>> np.binary_repr(3)\n    '11'\n    >>> np.binary_repr(-3)\n    '-11'\n    >>> np.binary_repr(3, width=4)\n    '0011'\n\n    The two's complement is returned when the input number is negative and\n    width is specified:\n\n    >>> np.binary_repr(-3, width=3)\n    '101'\n    >>> np.binary_repr(-3, width=5)\n    '11101'\n\n    \"\"\"\n    # Ensure that num is a Python integer to avoid overflow or unwanted\n    # exception propagation when using numpy integer types\n    num = int(num)\n    \n    def _positive_binary(num_):\n        result = ''\n        while num_:\n            result = str(num_ & 1) + result\n            num_ >>= 1\n        return result or '0'\n\n    if num >= 0:\n        binary = _positive_binary(num)\n        if width is not None:\n            if binary == '0':\n                binary = ''\n            # Pad with zeros on the left\n            if len(binary) < width:\n                binary = '0' * (width - len(binary)) + binary\n            if len(binary) > width:\n                warnings.warn(\n                    'Insufficient bit width provided. This behavior '\n                    'will raise an error in the future.', DeprecationWarning,\n                    stacklevel=2)\n        return binary\n    else:\n        if width is None:\n            return '-' + _positive_binary(-num)\n        else:\n            # Two's complement representation\n            if width < 1:\n                raise ValueError(\"width must be >= 1\")\n\n            # Calculate two's complement\n            poswidth = len(_positive_binary(-num))\n\n            # Check if width is sufficient for two's complement\n            if poswidth > width:\n                warnings.warn(\n                    'Insufficient bit width provided. This behavior '\n                    'will raise an error in the future.', DeprecationWarning,\n                    stacklevel=2)\n\n            # Use Python integers to avoid overflow with numpy integer types\n            twocomp = 2**(max(poswidth, width)) + num\n            binary = _positive_binary(twocomp)\n            if len(binary) < width:\n                binary = '1' * (width - len(binary)) + binary\n            return binary[-width:]"
    }
  ]
}