{
  "metadata": {
    "module": "numpy",
    "source": "https://github.com/numpy/numpy/blob/main/numpy/_core/src/multiarray/",
    "c_implementation_files": [
      "datetime.c",
      "datetime_strings.c",
      "datetime_busday.c"
    ],
    "description": "NumPy datetime and timedelta support - provides datetime64 and timedelta64 types with business day calculations"
  },
  "functions": [
    {
      "name": "numpy.datetime64",
      "category": "Datetime types",
      "description": "Create a datetime64 object representing an offset from 1970-01-01T00:00:00",
      "url": "https://numpy.org/doc/stable/reference/arrays.datetime.html#numpy.datetime64",
      "doc": "If created from a 64-bit integer, it represents an offset from ``1970-01-01T00:00:00``. If created from string, the string can be in ISO 8601 date or datetime format.\n\nWhen parsing a string to create a datetime object, if the string contains a trailing timezone (A 'Z' or a timezone offset), the timezone will be dropped and a User Warning is given.\n\nDatetime64 objects should be considered to be UTC and therefore have an offset of +0000.\n\n>>> np.datetime64(10, 'Y')\nnp.datetime64('1980')\n>>> np.datetime64('1980', 'Y')\nnp.datetime64('1980')\n>>> np.datetime64(10, 'D')\nnp.datetime64('1970-01-11')\n\nSee :ref:`arrays.datetime` for more information.\n\n:Character code: ``'M'``",
      "code": "# C implementation for performance\n# Create a datetime64 object representing an offset from 1970-01-01T00:00:00\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/_core/src/multiarray/datetime.c"
    },
    {
      "name": "numpy.timedelta64",
      "category": "Datetime types",
      "description": "A timedelta stored as a 64-bit integer",
      "url": "https://numpy.org/doc/stable/reference/arrays.datetime.html#numpy.timedelta64",
      "doc": "A timedelta stored as a 64-bit integer.\n\nSee :ref:`arrays.datetime` for more information.\n\n:Character code: ``'m'``",
      "code": "# C implementation for performance\n# A timedelta stored as a 64-bit integer\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/_core/src/multiarray/datetime.c"
    },
    {
      "name": "numpy.datetime_as_string",
      "category": "Datetime conversion",
      "description": "Convert an array of datetimes into an array of strings",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.datetime_as_string.html",
      "doc": "datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')\n\nConvert an array of datetimes into an array of strings.\n\nParameters\n----------\narr : array_like of datetime64\n    The array of UTC timestamps to format.\nunit : str\n    One of None, 'auto', or a :ref:`datetime unit <arrays.dtypes.dateunits>`.\ntimezone : {'naive', 'UTC', 'local'} or tzinfo\n    Timezone information to use when displaying the datetime. If 'UTC', end with a Z to indicate UTC time. If 'local', convert to the local timezone first, and suffix with a +-#### timezone offset. If a tzinfo object, then do as with 'local', but use the specified timezone.\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}\n    Casting to allow when changing between datetime units.\n\nReturns\n-------\nstr_arr : ndarray\n    An array of strings the same shape as `arr`.\n\nExamples\n--------\n>>> import numpy as np\n>>> import pytz\n>>> d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')\n>>> d\narray(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',\n       '2002-10-27T07:30'], dtype='datetime64[m]')\n\nSetting the timezone to UTC shows the same information, but with a Z suffix\n\n>>> np.datetime_as_string(d, timezone='UTC')\narray(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',\n       '2002-10-27T07:30Z'], dtype='<U35')",
      "code": "# C implementation for performance\n# Convert an array of datetimes into an array of strings\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/_core/src/multiarray/datetime_strings.c"
    },
    {
      "name": "numpy.datetime_data",
      "category": "Datetime metadata",
      "description": "Get information about the step size of a date or time type",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.datetime_data.html",
      "doc": "datetime_data(dtype, /)\n\nGet information about the step size of a date or time type.\n\nThe returned tuple can be passed as the second argument of `numpy.datetime64` and `numpy.timedelta64`.\n\nParameters\n----------\ndtype : dtype\n    The dtype object, which must be a `datetime64` or `timedelta64` type.\n\nReturns\n-------\nunit : str\n    The :ref:`datetime unit <arrays.dtypes.dateunits>` on which this dtype is based.\ncount : int\n    The number of base units in a step.\n\nExamples\n--------\n>>> import numpy as np\n>>> dt_25s = np.dtype('timedelta64[25s]')\n>>> np.datetime_data(dt_25s)\n('s', 25)\n>>> np.array(10, dt_25s).astype('timedelta64[s]')\narray(250, dtype='timedelta64[s]')\n\nThe result can be used to construct a datetime that uses the same units as a timedelta\n\n>>> np.datetime64('2010', np.datetime_data(dt_25s))\nnp.datetime64('2010-01-01T00:00:00','25s')",
      "code": "# C implementation for performance\n# Get information about the step size of a date or time type\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/_core/src/multiarray/datetime.c"
    },
    {
      "name": "numpy.busday_offset",
      "category": "Business day operations",
      "description": "First adjusts the date to fall on a valid day according to the roll rule, then applies offsets to the given dates counted in valid days",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.busday_offset.html",
      "doc": "busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)\n\nFirst adjusts the date to fall on a valid day according to the ``roll`` rule, then applies offsets to the given dates counted in valid days.\n\nParameters\n----------\ndates : array_like of datetime64[D]\n    The array of dates to process.\noffsets : array_like of int\n    The array of offsets, which is broadcast with ``dates``.\nroll : {'raise', 'nat', 'forward', 'following', 'backward', 'preceding', 'modifiedfollowing', 'modifiedpreceding'}, optional\n    How to treat dates that do not fall on a valid day. The default is 'raise'.\n\n    * 'raise' means to raise an exception for an invalid day.\n    * 'nat' means to return a NaT (not-a-time) for an invalid day.\n    * 'forward' and 'following' mean to take the first valid day later in time.\n    * 'backward' and 'preceding' mean to take the first valid day earlier in time.\n    * 'modifiedfollowing' means to take the first valid day later in time unless it is across a Month boundary, in which case to take the first valid day earlier in time.\n    * 'modifiedpreceding' means to take the first valid day earlier in time unless it is across a Month boundary, in which case to take the first valid day later in time.\nweekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun\nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates. They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.\nbusdaycal : busdaycalendar, optional\n    A `busdaycalendar` object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided.\nout : array of datetime64[D], optional\n    If provided, this array is filled with the result.\n\nReturns\n-------\nout : array of datetime64[D]\n    An array with a shape from broadcasting ``dates`` and ``offsets`` together, containing the dates with offsets applied.",
      "code": "# C implementation for performance\n# First adjusts the date to fall on a valid day according to the roll rule, then applies offsets to the given dates counted in valid days\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/_core/src/multiarray/datetime_busday.c"
    },
    {
      "name": "numpy.busday_count",
      "category": "Business day operations",
      "description": "Counts the number of valid days between begindates and enddates, not including the day of enddates",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html",
      "doc": "busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)\n\nCounts the number of valid days between `begindates` and `enddates`, not including the day of `enddates`.\n\nIf ``enddates`` specifies a date value that is earlier than the corresponding ``begindates`` date value, the count will be negative.\n\nParameters\n----------\nbegindates : array_like of datetime64[D]\n    The array of the first dates for counting.\nenddates : array_like of datetime64[D]\n    The array of the end dates for counting, which are excluded from the count themselves.\nweekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun\nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates. They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.\nbusdaycal : busdaycalendar, optional\n    A `busdaycalendar` object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided.\nout : array of int, optional\n    If provided, this array is filled with the result.\n\nReturns\n-------\nout : array of int\n    An array with a shape from broadcasting ``begindates`` and ``enddates`` together, containing the number of valid days between the begin and end dates.",
      "code": "# C implementation for performance\n# Counts the number of valid days between begindates and enddates, not including the day of enddates\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/_core/src/multiarray/datetime_busday.c"
    },
    {
      "name": "numpy.is_busday",
      "category": "Business day operations",
      "description": "Calculates which of the given dates are valid days, and which are not",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.is_busday.html",
      "doc": "is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)\n\nCalculates which of the given dates are valid days, and which are not.\n\nParameters\n----------\ndates : array_like of datetime64[D]\n    The array of dates to process.\nweekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun\nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates. They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.\nbusdaycal : busdaycalendar, optional\n    A `busdaycalendar` object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided.\nout : array of bool, optional\n    If provided, this array is filled with the result.\n\nReturns\n-------\nout : array of bool\n    An array with the same shape as ``dates``, containing True for each valid day, and False for each invalid day.",
      "code": "# C implementation for performance\n# Calculates which of the given dates are valid days, and which are not\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/_core/src/multiarray/datetime_busday.c"
    },
    {
      "name": "numpy.busdaycalendar",
      "category": "Business day operations",
      "description": "A business day calendar object that efficiently stores information defining valid days for the busday family of functions",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.busdaycalendar.html",
      "doc": "busdaycalendar(weekmask='1111100', holidays=None)\n\nA business day calendar object that efficiently stores information defining valid days for the busday family of functions.\n\nThe default valid days are Monday through Friday (\"business days\"). A busdaycalendar object can be specified with any set of weekly valid days, plus an optional \"holiday\" dates that always will be invalid.\n\nOnce a busdaycalendar object is created, the weekmask and holidays cannot be modified.\n\nParameters\n----------\nweekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun\nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates, no matter which weekday they fall upon. Holiday dates may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.\n\nReturns\n-------\nout : busdaycalendar\n    A business day calendar object containing the specified weekmask and holidays values.\n\nAttributes\n----------\nweekmask : (copy) seven-element array of bool\nholidays : (copy) sorted array of datetime64[D]",
      "code": "# C implementation for performance\n# A business day calendar object that efficiently stores information defining valid days for the busday family of functions\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/_core/src/multiarray/datetime_busday.c"
    }
  ]
}