{
  "metadata": {
    "module": "numpy",
    "submodules": ["numpy._core", "numpy.logical"],
    "source": "https://github.com/numpy/numpy/blob/main/numpy/_core/",
    "description": "NumPy logic functions for truth value testing, array comparison, and logical operations"
  },
  "functions": [
    {
      "name": "numpy.all",
      "category": "Truth value testing",
      "description": "Test whether all array elements along a given axis evaluate to True",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.all.html",
      "doc": "Test whether all array elements along a given axis evaluate to True.\n\nParameters\n----------\na : array_like\n    Input array or object that can be converted to an array.\naxis : None or int or tuple of ints, optional\n    Axis or axes along which a logical AND reduction is performed.\n    The default (axis=None) is to perform a logical AND over all\n    the dimensions of the input array. axis may be negative, in\n    which case it counts from the last to the first axis.\n    \n    .. versionadded:: 1.7.0\n    \n    If this is a tuple of ints, a reduction is performed on multiple\n    axes, instead of a single axis or all the axes as before.\nout : ndarray, optional\n    Alternate output array in which to place the result.\n    It must have the same shape as the expected output and its\n    type is preserved (e.g., if dtype(out) is float, the result\n    will consist of 0.0's and 1.0's). See Output type determination\n    for more details.\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n    \n    If the default value is passed, then keepdims will not be\n    passed through to the all method of sub-classes of\n    ndarray, however any non-default value will be. If the\n    sub-class' method does not implement keepdims any\n    exceptions will be raised.\nwhere : array_like of bool, optional\n    Elements to include in checking for all True values.\n    See reduce for details.\n    \n    .. versionadded:: 1.20.0\n\nReturns\n-------\nall : ndarray, bool\n    A new boolean or array is returned unless out is specified,\n    in which case a reference to out is returned.\n\nSee Also\n--------\nndarray.all : equivalent method\n\nany : Test whether any element along a given axis evaluates to True.\n\nNotes\n-----\nNot a Number (NaN), positive infinity and negative infinity\nevaluate to True because these are not equal to zero.\n\nExamples\n--------\n>>> np.all([[True,False],[True,True]])\nFalse\n\n>>> np.all([[True,False],[True,True]], axis=0)\narray([ True, False])\n\n>>> np.all([-1, 4, 5])\nTrue\n\n>>> np.all([1.0, np.nan])\nTrue\n\n>>> np.all([[True, True], [False, True]], where=[[True], [False]])\nTrue\n\n>>> o=np.array(False)\n>>> z=np.all([-1, 4, 5], out=o)\n>>> id(z), id(o), z\n(28293632, 28293632, array(True)) # may vary",
      "code": "@array_function_dispatch(_all_dispatcher)\ndef all(a, axis=None, out=None, keepdims=np._NoValue, *, where=np._NoValue):\n    \"\"\"\n    Test whether all array elements along a given axis evaluate to True.\n    \n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which a logical AND reduction is performed.\n        The default (``axis=None``) is to perform a logical AND over all\n        the dimensions of the input array. `axis` may be negative, in\n        which case it counts from the last to the first axis.\n        \n        .. versionadded:: 1.7.0\n        \n        If this is a tuple of ints, a reduction is performed on multiple\n        axes, instead of a single axis or all the axes as before.\n    out : ndarray, optional\n        Alternate output array in which to place the result.\n        It must have the same shape as the expected output and its\n        type is preserved (e.g., if ``dtype(out)`` is float, the result\n        will consist of 0.0's and 1.0's). See :ref:`ufuncs-output-type` for more\n        details.\n    \n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n        \n        If the default value is passed, then `keepdims` will not be\n        passed through to the `all` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n    \n    where : array_like of bool, optional\n        Elements to include in checking for all `True` values.\n        See `~numpy.ufunc.reduce` for details.\n        \n        .. versionadded:: 1.20.0\n    \n    Returns\n    -------\n    all : ndarray, bool\n        A new boolean or array is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n    \n    See Also\n    --------\n    ndarray.all : equivalent method\n    \n    any : Test whether any element along a given axis evaluates to True.\n    \n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to `True` because these are not equal to zero.\n    \n    Examples\n    --------\n    >>> np.all([[True,False],[True,True]])\n    False\n    \n    >>> np.all([[True,False],[True,True]], axis=0)\n    array([ True, False])\n    \n    >>> np.all([-1, 4, 5])\n    True\n    \n    >>> np.all([1.0, np.nan])\n    True\n    \n    >>> np.all([[True, True], [False, True]], where=[[True], [False]])\n    True\n    \n    >>> o=np.array(False)\n    >>> z=np.all([-1, 4, 5], out=o)\n    >>> id(z), id(o), z\n    (28293632, 28293632, array(True)) # may vary\n    \n    \"\"\"\n    return _wrapreduction_any_all(a, np.logical_and, 'all', axis, out,\n                                  keepdims=keepdims, where=where)"
    },
    {
      "name": "numpy.any",
      "category": "Truth value testing", 
      "description": "Test whether any array element along a given axis evaluates to True",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.any.html",
      "doc": "Test whether any array element along a given axis evaluates to True.\n\nReturns single boolean if axis is None\n\nParameters\n----------\na : array_like\n    Input array or object that can be converted to an array.\naxis : None or int or tuple of ints, optional\n    Axis or axes along which a logical OR reduction is performed.\n    The default (axis=None) is to perform a logical OR over all\n    the dimensions of the input array. axis may be negative, in\n    which case it counts from the last to the first axis.\n    \n    .. versionadded:: 1.7.0\n    \n    If this is a tuple of ints, a reduction is performed on multiple\n    axes, instead of a single axis or all the axes as before.\nout : ndarray, optional\n    Alternate output array in which to place the result. It must have\n    the same shape as the expected output and its type is preserved\n    (e.g., if it is of type float, then it will remain so, returning\n    1.0 for True and 0.0 for False, regardless of the type of a).\n    See Output type determination for more details.\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n    \n    If the default value is passed, then keepdims will not be\n    passed through to the any method of sub-classes of\n    ndarray, however any non-default value will be. If the\n    sub-class' method does not implement keepdims any\n    exceptions will be raised.\nwhere : array_like of bool, optional\n    Elements to include in checking for any True values.\n    See reduce for details.\n    \n    .. versionadded:: 1.20.0\n\nReturns\n-------\nany : bool or ndarray\n    A new boolean or ndarray is returned unless out is specified,\n    in which case a reference to out is returned.\n\nSee Also\n--------\nndarray.any : equivalent method\n\nall : Test whether all elements along a given axis evaluate to True.\n\nNotes\n-----\nNot a Number (NaN), positive infinity and negative infinity evaluate\nto True because these are not equal to zero.\n\nExamples\n--------\n>>> np.any([[True, False], [True, True]])\nTrue\n\n>>> np.any([[True, False], [False, False]], axis=0)\narray([ True, False])\n\n>>> np.any([-1, 0, 5])\nTrue\n\n>>> np.any(np.nan)\nTrue\n\n>>> np.any([[True, False], [False, False]], where=[[False], [True]])\nFalse\n\n>>> o=np.array(False)\n>>> z=np.any([-1, 4, 5], out=o)\n>>> z, o\n(array(True), array(True))\n>>> # Check now that z is a reference to o\n>>> z is o\nTrue\n>>> id(z), id(o) # identity of z and o              # doctest: +SKIP\n(191614240, 191614240)",
      "code": "@array_function_dispatch(_any_dispatcher)\ndef any(a, axis=None, out=None, keepdims=np._NoValue, *, where=np._NoValue):\n    \"\"\"\n    Test whether any array element along a given axis evaluates to True.\n    \n    Returns single boolean if `axis` is ``None``\n    \n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which a logical OR reduction is performed.\n        The default (``axis=None``) is to perform a logical OR over all\n        the dimensions of the input array. `axis` may be negative, in\n        which case it counts from the last to the first axis.\n        \n        .. versionadded:: 1.7.0\n        \n        If this is a tuple of ints, a reduction is performed on multiple\n        axes, instead of a single axis or all the axes as before.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output and its type is preserved\n        (e.g., if it is of type float, then it will remain so, returning\n        1.0 for True and 0.0 for False, regardless of the type of `a`).\n        See :ref:`ufuncs-output-type` for more details.\n    \n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n        \n        If the default value is passed, then `keepdims` will not be\n        passed through to the `any` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n    \n    where : array_like of bool, optional\n        Elements to include in checking for any `True` values.\n        See `~numpy.ufunc.reduce` for details.\n        \n        .. versionadded:: 1.20.0\n    \n    Returns\n    -------\n    any : bool or ndarray\n        A new boolean or `ndarray` is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n    \n    See Also\n    --------\n    ndarray.any : equivalent method\n    \n    all : Test whether all elements along a given axis evaluate to True.\n    \n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity evaluate\n    to `True` because these are not equal to zero.\n    \n    Examples\n    --------\n    >>> np.any([[True, False], [True, True]])\n    True\n    \n    >>> np.any([[True, False], [False, False]], axis=0)\n    array([ True, False])\n    \n    >>> np.any([-1, 0, 5])\n    True\n    \n    >>> np.any(np.nan)\n    True\n    \n    >>> np.any([[True, False], [False, False]], where=[[False], [True]])\n    False\n    \n    >>> o=np.array(False)\n    >>> z=np.any([-1, 4, 5], out=o)\n    >>> z, o\n    (array(True), array(True))\n    >>> # Check now that z is a reference to o\n    >>> z is o\n    True\n    >>> id(z), id(o) # identity of z and o              # doctest: +SKIP\n    (191614240, 191614240)\n    \n    \"\"\"\n    return _wrapreduction_any_all(a, np.logical_or, 'any', axis, out,\n                                  keepdims=keepdims, where=where)"
    },
    {
      "name": "numpy.isfinite",
      "category": "Array contents testing",
      "description": "Test element-wise for finiteness (not infinity and not Not a Number)",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.isfinite.html",
      "doc": "Test element-wise for finiteness (not infinity or not Not a Number).\n\nThe result is returned as a boolean array.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\ny : ndarray, bool\n    True where x is not positive infinity, negative infinity,\n    or NaN; false otherwise.\n    This is a scalar if x is a scalar.\n\nSee Also\n--------\nisinf, isneginf, isposinf, isnan\n\nNotes\n-----\nNot a Number, positive infinity and negative infinity are considered\nto be non-finite.\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nAlso that positive infinity is not equivalent to negative infinity. But\ninfinity is equivalent to positive infinity.  Errors result if the\nsecond argument is also supplied when x is a scalar input, or if\nfirst and second arguments have different shapes.\n\nExamples\n--------\n>>> np.isfinite(1)\nTrue\n>>> np.isfinite(0)\nTrue\n>>> np.isfinite(np.nan)\nFalse\n>>> np.isfinite(np.inf)\nFalse\n>>> np.isfinite(np.NINF)\nFalse\n>>> np.isfinite([np.log(-1.),1.,np.log(0)])\narray([False,  True, False])\n\n>>> x = np.array([-np.inf, 0., np.inf])\n>>> y = np.array([2, 2, 2])\n>>> np.isfinite(x, y)\narray([0, 1, 0])\n>>> y\narray([0, 1, 0])",
      "code": "C implementation: numpy/_core/src/umath/loops_arithm_fp.dispatch.c.src and numpy/_core/src/npymath/ieee754.cpp"
    },
    {
      "name": "numpy.isinf",
      "category": "Array contents testing",
      "description": "Test element-wise for positive or negative infinity",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.isinf.html",
      "doc": "Test element-wise for positive or negative infinity.\n\nReturns a boolean array of the same shape as x, True where x ==\n+/-inf, otherwise False.\n\nParameters\n----------\nx : array_like\n    Input values\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\ny : bool (scalar) or boolean ndarray\n    True where x is positive or negative infinity, false otherwise.\n    This is a scalar if x is a scalar.\n\nSee Also\n--------\nisneginf, isposinf, isnan, isfinite\n\nNotes\n-----\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754).\n\nErrors result if the second argument is supplied when the first\nargument is a scalar, or if the first and second arguments have\ndifferent shapes.\n\nExamples\n--------\n>>> np.isinf(np.inf)\nTrue\n>>> np.isinf(np.nan)\nFalse\n>>> np.isinf(np.NINF)\nTrue\n>>> np.isinf([np.inf, -np.inf, 1.0, np.nan])\narray([ True,  True, False, False])\n\n>>> x = np.array([-np.inf, 0., np.inf])\n>>> y = np.array([2, 2, 2])\n>>> np.isinf(x, y)\narray([1, 0, 1])\n>>> y\narray([1, 0, 1])",
      "code": "C implementation: numpy/_core/src/umath/loops_arithm_fp.dispatch.c.src and numpy/_core/src/npymath/ieee754.cpp"
    },
    {
      "name": "numpy.isnan",
      "category": "Array contents testing",
      "description": "Test element-wise for NaN and return result as a boolean array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.isnan.html", 
      "doc": "Test element-wise for NaN and return result as a boolean array.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns  \n-------\ny : ndarray or bool\n    True where x is NaN, false otherwise.\n    This is a scalar if x is a scalar.\n\nSee Also\n--------\nisinf, isneginf, isposinf, isfinite, isnat\n\nNotes\n-----\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\n\nExamples\n--------\n>>> np.isnan(np.nan)\nTrue\n>>> np.isnan(np.inf)\nFalse\n>>> np.isnan([np.log(-1.),1.,np.log(0)])\narray([ True, False, False])",
      "code": "C implementation: numpy/_core/src/umath/loops_arithm_fp.dispatch.c.src and numpy/_core/src/npymath/ieee754.cpp"
    },
    {
      "name": "numpy.isnat",
      "category": "Array contents testing",
      "description": "Test element-wise for NaT (not a time) and return result as a boolean array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.isnat.html",
      "doc": "Test element-wise for NaT (not a time) and return result as a boolean array.\n\n.. versionadded:: 1.13.0\n\nParameters\n----------\nx : array_like\n    Input array with datetime or timedelta data type.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\ny : ndarray or bool\n    True where x is NaT, false otherwise.\n    This is a scalar if x is a scalar.\n\nSee Also\n--------\nisnan, isinf, isneginf, isposinf, isfinite\n\nExamples\n--------\n>>> np.isnat(np.datetime64(\"NaT\"))\nTrue\n>>> np.isnat(np.datetime64(\"2016-01-01\"))\nFalse\n>>> np.isnat(np.array([\"NaT\", \"2016-01-01\"], dtype=\"datetime64[ns]\"))\narray([ True, False])",
      "code": "C implementation: ufunc for datetime64 and timedelta64 types"
    },
    {
      "name": "numpy.isneginf",
      "category": "Array contents testing",
      "description": "Test element-wise for negative infinity, return result as bool array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.isneginf.html",
      "doc": "Test element-wise for negative infinity, return result as bool array.\n\nParameters\n----------\nx : array_like\n    The input array.\nout : array_like, optional\n    A location into which the result is stored. If provided, it must have a\n    shape that the input broadcasts to. If not provided or None, a\n    freshly-allocated boolean array is returned.\n\nReturns\n-------\nout : ndarray\n    A boolean array with the same dimensions as the input.\n    If second argument is not supplied then a numpy boolean array is\n    returned with values True where the corresponding element of the\n    input is negative infinity and values False where the element of\n    the input is not negative infinity.\n    \n    If a second argument is supplied the result is stored there. If the\n    type of that array is a numeric type the result is represented as\n    zeros and ones, if the type is boolean then as False and True. The\n    return value out is then a reference to that array.\n\nSee Also\n--------\nisinf, isposinf, isnan, isfinite\n\nNotes\n-----\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754).\n\nErrors result if the second argument is also supplied when x is a\nscalar input, if first and second arguments have different shapes,\nor if the first argument has complex values.\n\nExamples\n--------\n>>> np.isneginf(np.NINF)\nTrue\n>>> np.isneginf(np.inf)\nFalse\n>>> np.isneginf(np.PINF)\nFalse\n>>> np.isneginf([-np.inf, 0., np.inf])\narray([ True, False, False])\n\n>>> x = np.array([-np.inf, 0., np.inf])\n>>> y = np.array([2, 2, 2])\n>>> np.isneginf(x, y)\narray([1, 0, 0])\n>>> y\narray([1, 0, 0])",
      "code": "def isneginf(x, out=None):\n    \"\"\"\n    Test element-wise for negative infinity, return result as bool array.\n    \n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    out : array_like, optional\n        A location into which the result is stored. If provided, it must have a\n        shape that the input broadcasts to. If not provided or None, a\n        freshly-allocated boolean array is returned.\n    \n    Returns\n    -------\n    out : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a numpy boolean array is\n        returned with values True where the corresponding element of the\n        input is negative infinity and values False where the element of\n        the input is not negative infinity.\n        \n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as\n        zeros and ones, if the type is boolean then as False and True. The\n        return value `out` is then a reference to that array.\n    \n    See Also\n    --------\n    isinf, isposinf, isnan, isfinite\n    \n    Notes\n    -----\n    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n    \n    Errors result if the second argument is also supplied when x is a\n    scalar input, if first and second arguments have different shapes,\n    or if the first argument has complex values.\n    \n    Examples\n    --------\n    >>> np.isneginf(np.NINF)\n    True\n    >>> np.isneginf(np.inf)\n    False\n    >>> np.isneginf(np.PINF)\n    False\n    >>> np.isneginf([-np.inf, 0., np.inf])\n    array([ True, False, False])\n    \n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isneginf(x, y)\n    array([1, 0, 0])\n    >>> y\n    array([1, 0, 0])\n    \n    \"\"\"\n    is_inf = nx.isinf(x)\n    try:\n        signbit = nx.signbit(x)\n    except TypeError as e:\n        dtype = nx.asanyarray(x).dtype\n        raise TypeError(f'This operation is not supported for {dtype} values '\n                        'because it would be ambiguous.') from e\n    else:\n        return nx.logical_and(is_inf, signbit, out)"
    },
    {
      "name": "numpy.isposinf", 
      "category": "Array contents testing",
      "description": "Test element-wise for positive infinity, return result as bool array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.isposinf.html",
      "doc": "Test element-wise for positive infinity, return result as bool array.\n\nParameters\n----------\nx : array_like\n    The input array.\nout : array_like, optional\n    A location into which the result is stored. If provided, it must have a\n    shape that the input broadcasts to. If not provided or None, a\n    freshly-allocated boolean array is returned.\n\nReturns\n-------\nout : ndarray\n    A boolean array with the same dimensions as the input.\n    If second argument is not supplied then a boolean array is returned\n    with values True where the corresponding element of the input is\n    positive infinity and values False where the element of the input\n    is not positive infinity.\n    \n    If a second argument is supplied the result is stored there. If the\n    type of that array is a numeric type the result is represented as\n    zeros and ones, if the type is boolean then as False and True.\n    The return value out is then a reference to that array.\n\nSee Also\n--------\nisinf, isneginf, isfinite, isnan\n\nNotes\n-----\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754).\n\nErrors result if the second argument is also supplied when x is a\nscalar input, if first and second arguments have different shapes,\nor if the first argument has complex values\n\nExamples\n--------\n>>> np.isposinf(np.PINF)\nTrue\n>>> np.isposinf(np.inf)\nTrue\n>>> np.isposinf(np.NINF)\nFalse\n>>> np.isposinf([-np.inf, 0., np.inf])\narray([False, False,  True])\n\n>>> x = np.array([-np.inf, 0., np.inf])\n>>> y = np.array([2, 2, 2])\n>>> np.isposinf(x, y)\narray([0, 0, 1])\n>>> y\narray([0, 0, 1])",
      "code": "def isposinf(x, out=None):\n    \"\"\"\n    Test element-wise for positive infinity, return result as bool array.\n    \n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    out : array_like, optional\n        A location into which the result is stored. If provided, it must have a\n        shape that the input broadcasts to. If not provided or None, a\n        freshly-allocated boolean array is returned.\n    \n    Returns\n    -------\n    out : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a boolean array is returned\n        with values True where the corresponding element of the input is\n        positive infinity and values False where the element of the input\n        is not positive infinity.\n        \n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as\n        zeros and ones, if the type is boolean then as False and True.\n        The return value `out` is then a reference to that array.\n    \n    See Also\n    --------\n    isinf, isneginf, isfinite, isnan\n    \n    Notes\n    -----\n    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n    \n    Errors result if the second argument is also supplied when x is a\n    scalar input, if first and second arguments have different shapes,\n    or if the first argument has complex values\n    \n    Examples\n    --------\n    >>> np.isposinf(np.PINF)\n    True\n    >>> np.isposinf(np.inf)\n    True\n    >>> np.isposinf(np.NINF)\n    False\n    >>> np.isposinf([-np.inf, 0., np.inf])\n    array([False, False,  True])\n    \n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isposinf(x, y)\n    array([0, 0, 1])\n    >>> y\n    array([0, 0, 1])\n    \n    \"\"\"\n    is_inf = nx.isinf(x)\n    try:\n        signbit = ~nx.signbit(x)\n    except TypeError as e:\n        dtype = nx.asanyarray(x).dtype\n        raise TypeError(f'This operation is not supported for {dtype} values '\n                        'because it would be ambiguous.') from e\n    else:\n        return nx.logical_and(is_inf, signbit, out)"
    },
    {
      "name": "numpy.isreal",
      "category": "Array type testing",
      "description": "Returns a bool array, where True if input element is real",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.isreal.html",
      "doc": "Returns a bool array, where True if input element is real.\n\nIf element has complex type with zero imaginary part, the return value\nfor that element is True.\n\nParameters\n----------\nx : array_like\n    Input array.\n\nReturns\n-------\nout : ndarray, bool\n    Boolean array of same shape as x.\n\nSee Also\n--------\niscomplex\nisrealobj : Return True if x is not a complex type.\n\nExamples\n--------\n>>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([False,  True,  True,  True,  True, False])",
      "code": "def isreal(x):\n    \"\"\"\n    Returns a bool array, where True if input element is real.\n    \n    If element has complex type with zero imaginary part, the return value\n    for that element is True.\n    \n    Parameters\n    ----------\n    x : array_like\n        Input array.\n    \n    Returns\n    -------\n    out : ndarray, bool\n        Boolean array of same shape as `x`.\n    \n    See Also\n    --------\n    iscomplex\n    isrealobj : Return True if x is not a complex type.\n    \n    Examples\n    --------\n    >>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([False,  True,  True,  True,  True, False])\n    \n    \"\"\"\n    return imag(x) == 0"
    },
    {
      "name": "numpy.iscomplex",
      "category": "Array type testing",
      "description": "Returns a bool array, where True if input element is complex",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.iscomplex.html",
      "doc": "Returns a bool array, where True if input element is complex.\n\nWhat is tested is whether the input has a non-zero imaginary part, not\nwhether the input type is complex.\n\nParameters\n----------\nx : array_like\n    Input array.\n\nReturns\n-------\nout : ndarray of bools\n    Output array.\n\nSee Also\n--------\nisreal\niscomplexobj : Return True if x is of a complex type.\n\nExamples\n--------\n>>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([ True, False, False, False, False,  True])",
      "code": "def iscomplex(x):\n    \"\"\"\n    Returns a bool array, where True if input element is complex.\n    \n    What is tested is whether the input has a non-zero imaginary part, not\n    whether the input type is complex.\n    \n    Parameters\n    ----------\n    x : array_like\n        Input array.\n    \n    Returns  \n    -------\n    out : ndarray of bools\n        Output array.\n    \n    See Also\n    --------\n    isreal\n    iscomplexobj : Return True if x is of a complex type.\n    \n    Examples\n    --------\n    >>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([ True, False, False, False, False,  True])\n    \n    \"\"\"\n    ax = asanyarray(x)\n    if issubclass(ax.dtype.type, _nx.complexfloating):\n        return ax.imag != 0\n    res = zeros(ax.shape, bool)\n    return res[()]   # convert to scalar if needed"
    },
    {
      "name": "numpy.isrealobj",
      "category": "Array type testing",
      "description": "Return True if x is a not complex type or an array of complex numbers",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.isrealobj.html",
      "doc": "Return True if x is a not complex type or an array of complex numbers.\n\nThe type of the input is checked, not the value. So even if the input\nhas an imaginary part equal to zero, isrealobj evaluates to False\nif the data type is complex.\n\nParameters\n----------\nx : any\n    The input can be of any type and shape.\n\nReturns\n-------\ny : bool\n    The return value, False if x is of a complex type.\n\nSee Also\n--------\niscomplexobj, isreal\n\nExamples\n--------\n>>> np.isrealobj(1)\nTrue\n>>> np.isrealobj(1+0j)\nFalse\n>>> np.isrealobj([3, 1+0j, True])\nFalse",
      "code": "def isrealobj(x):\n    \"\"\"\n    Return True if x is a not complex type or an array of complex numbers.\n    \n    The type of the input is checked, not the value. So even if the input\n    has an imaginary part equal to zero, `isrealobj` evaluates to False\n    if the data type is complex.\n    \n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n    \n    Returns\n    -------\n    y : bool\n        The return value, False if `x` is of a complex type.\n    \n    See Also\n    --------\n    iscomplexobj, isreal\n    \n    Examples\n    --------\n    >>> np.isrealobj(1)\n    True\n    >>> np.isrealobj(1+0j)\n    False\n    >>> np.isrealobj([3, 1+0j, True])\n    False\n    \n    \"\"\"\n    return not iscomplexobj(x)"
    },
    {
      "name": "numpy.iscomplexobj",
      "category": "Array type testing",
      "description": "Check for a complex type or an array of complex numbers",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.iscomplexobj.html",
      "doc": "Check for a complex type or an array of complex numbers.\n\nThe type of the input is checked, not the value. Even if the input\nhas an imaginary part equal to zero, iscomplexobj evaluates to True.\n\nParameters\n----------\nx : any\n    The input can be of any type and shape.\n\nReturns\n-------\niscomplexobj : bool\n    The return value, True if x is of a complex type or has at least\n    one complex element.\n\nSee Also\n--------\nisrealobj, iscomplex\n\nExamples\n--------\n>>> np.iscomplexobj(1)\nFalse\n>>> np.iscomplexobj(1+0j)\nTrue\n>>> np.iscomplexobj([3, 1+0j, True])\nTrue",
      "code": "def iscomplexobj(x):\n    \"\"\"\n    Check for a complex type or an array of complex numbers.\n    \n    The type of the input is checked, not the value. Even if the input\n    has an imaginary part equal to zero, `iscomplexobj` evaluates to True.\n    \n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n    \n    Returns\n    -------\n    iscomplexobj : bool\n        The return value, True if `x` is of a complex type or has at least\n        one complex element.\n    \n    See Also\n    --------\n    isrealobj, iscomplex\n    \n    Examples\n    --------\n    >>> np.iscomplexobj(1)\n    False\n    >>> np.iscomplexobj(1+0j)\n    True\n    >>> np.iscomplexobj([3, 1+0j, True])\n    True\n    \n    \"\"\"\n    try:\n        dtype = x.dtype\n        type_ = dtype.type\n    except AttributeError:\n        type_ = asarray(x).dtype.type\n    return issubclass(type_, _nx.complexfloating)"
    },
    {
      "name": "numpy.array_equal",
      "category": "Array comparison",
      "description": "True if two arrays have the same shape and elements, False otherwise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.array_equal.html",
      "doc": "True if two arrays have the same shape and elements, False otherwise.\n\nParameters\n----------\na1, a2 : array_like\n    Input arrays.\nequal_nan : bool\n    Whether to compare NaN's as equal. If the dtype of a1 and a2 is\n    complex, values will be considered equal if either the real or the\n    imaginary component of a given value is nan.\n    \n    .. versionadded:: 1.19.0\n\nReturns\n-------\nb : bool\n    Returns True if the arrays are equal.\n\nSee Also\n--------\nallclose: Returns True if two arrays are element-wise equal within a\n          tolerance.\narray_equiv: Returns True if input arrays are shape consistent and all\n             elements equal.\n\nExamples\n--------\n>>> np.array_equal([1, 2], [1, 2])\nTrue\n>>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\nTrue\n>>> np.array_equal([1, 2], [1, 2, 3])\nFalse\n>>> np.array_equal([1, 2], [1, 4])\nFalse\n>>> a = np.array([1, np.nan])\n>>> np.array_equal(a, a)\nFalse\n>>> np.array_equal(a, a, equal_nan=True)\nTrue\n\nWhen equal_nan is True, complex values with nan components are\nconsidered equal if either the real or the imaginary components are nan.\n\n>>> a = np.array([1 + 1j])\n>>> b = a.copy()\n>>> a.real = np.nan\n>>> b.imag = np.nan\n>>> np.array_equal(a, b, equal_nan=True)\nTrue",
      "code": "@array_function_dispatch(_array_equal_dispatcher)\ndef array_equal(a1, a2, equal_nan=False):\n    \"\"\"\n    True if two arrays have the same shape and elements, False otherwise.\n    \n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n    equal_nan : bool\n        Whether to compare NaN's as equal. If the dtype of a1 and a2 is\n        complex, values will be considered equal if either the real or the\n        imaginary component of a given value is ``nan``.\n        \n        .. versionadded:: 1.19.0\n    \n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equal.\n    \n    See Also\n    --------\n    allclose: Returns True if two arrays are element-wise equal within a\n              tolerance.\n    array_equiv: Returns True if input arrays are shape consistent and all\n                 elements equal.\n    \n    Examples\n    --------\n    >>> np.array_equal([1, 2], [1, 2])\n    True\n    >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\n    True\n    >>> np.array_equal([1, 2], [1, 2, 3])\n    False\n    >>> np.array_equal([1, 2], [1, 4])\n    False\n    >>> a = np.array([1, np.nan])\n    >>> np.array_equal(a, a)\n    False\n    >>> np.array_equal(a, a, equal_nan=True)\n    True\n    \n    When ``equal_nan`` is True, complex values with nan components are\n    considered equal if either the real *or* the imaginary components are nan.\n    \n    >>> a = np.array([1 + 1j])\n    >>> b = a.copy()\n    >>> a.real = np.nan\n    >>> b.imag = np.nan\n    >>> np.array_equal(a, b, equal_nan=True)\n    True\n    \"\"\"\n    try:\n        a1, a2 = asarray(a1), asarray(a2)\n    except Exception:\n        return False\n    if a1.shape != a2.shape:\n        return False\n    if not equal_nan:\n        return bool(asarray(a1 == a2).all())\n    # Handling NaN values if equal_nan is True\n    a1nan, a2nan = isnan(a1), isnan(a2)\n    # NaN's occur at different locations\n    if not (a1nan == a2nan).all():\n        return False\n    # Shapes of a1, a2 and masks are guaranteed to be consistent by this point\n    return bool(asarray(a1[~a1nan] == a2[~a1nan]).all())"
    },
    {
      "name": "numpy.array_equiv",
      "category": "Array comparison",
      "description": "Returns True if input arrays are shape consistent and all elements equal",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.array_equiv.html",
      "doc": "Returns True if input arrays are shape consistent and all elements equal.\n\nShape consistent means they are either the same shape, or one input array\ncan be broadcasted to create the same shape as the other one.\n\nParameters\n----------\na1, a2 : array_like\n    Input arrays.\n\nReturns\n-------\nout : bool\n    True if equivalent, False otherwise.\n\nExamples\n--------\n>>> np.array_equiv([1, 2], [1, 2])\nTrue\n>>> np.array_equiv([1, 2], [1, 3])\nFalse\n\nShowing the shape equivalence:\n\n>>> np.array_equiv([1, 2], [[1, 2], [1, 2]])\nTrue\n>>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\nFalse\n\n>>> np.array_equiv([1, 2], [[1, 2], [1, 3]])\nFalse",
      "code": "@array_function_dispatch(_array_equiv_dispatcher)\ndef array_equiv(a1, a2):\n    \"\"\"\n    Returns True if input arrays are shape consistent and all elements equal.\n    \n    Shape consistent means they are either the same shape, or one input array\n    can be broadcasted to create the same shape as the other one.\n    \n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n    \n    Returns\n    -------\n    out : bool\n        True if equivalent, False otherwise.\n    \n    Examples\n    --------\n    >>> np.array_equiv([1, 2], [1, 2])\n    True\n    >>> np.array_equiv([1, 2], [1, 3])\n    False\n    \n    Showing the shape equivalence:\n    \n    >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])\n    True\n    >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\n    False\n    \n    >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])\n    False\n    \n    \"\"\"\n    try:\n        a1, a2 = asarray(a1), asarray(a2)\n    except Exception:\n        return False\n    try:\n        multiarray.broadcast(a1, a2)\n    except Exception:\n        return False\n    \n    return bool(asarray(a1 == a2).all())"
    },
    {
      "name": "numpy.allclose",
      "category": "Array comparison",
      "description": "Returns True if two arrays are element-wise equal within a tolerance",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.allclose.html",
      "doc": "Returns True if two arrays are element-wise equal within a tolerance.\n\nThe tolerance values are positive, typically very small numbers. The\nrelative difference (rtol * abs(b)) and the absolute difference\natol are added together to compare against the absolute difference\nbetween a and b.\n\nWarning: The default atol is not appropriate for comparing numbers\nthat are much smaller than one (see Notes).\n\nParameters\n----------\na, b : array_like\n    Input arrays to compare.\nrtol : float\n    The relative tolerance parameter (see Notes).\natol : float\n    The absolute tolerance parameter (see Notes).\nequal_nan : bool\n    Whether to compare NaN's as equal.  If True, NaN's in a will be\n    considered equal to NaN's in b in the output array.\n\nReturns\n-------\nallclose : bool\n    Returns True if the two arrays are equal within the given\n    tolerance; False otherwise.\n\nSee Also\n--------\nisclose, all, any, equal\n\nNotes\n-----\nIf the following equation is element-wise True, then allclose returns\nTrue.\n\n absolute(a - b) <= (atol + rtol * absolute(b))\n\nThe above equation is not symmetric in a and b, so that\nallclose(a, b) might be different from allclose(b, a) in\nsome rare cases.\n\nThe comparison of a and b uses standard broadcasting, which\nmeans that a and b need not have the same shape in order for\nallclose(a, b) to evaluate to True.  The same is true for\nequal but not array_equal.\n\nallclose is not defined for non-numeric data types.\n\nExamples\n--------\n>>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\nFalse\n>>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\nTrue\n>>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\nFalse\n>>> np.allclose([1.0, np.nan], [1.0, np.nan])\nFalse\n>>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\nTrue",
      "code": "@array_function_dispatch(_allclose_dispatcher)\ndef allclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):\n    \"\"\"\n    Returns True if two arrays are element-wise equal within a tolerance.\n    \n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n    \n    .. warning:: The default `atol` is not appropriate for comparing numbers\n                 that are much smaller than one (see Notes).\n    \n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN's as equal.  If True, NaN's in `a` will be\n        considered equal to NaN's in `b` in the output array.\n    \n    Returns\n    -------\n    allclose : bool\n        Returns True if the two arrays are equal within the given\n        tolerance; False otherwise.\n    \n    See Also\n    --------\n    isclose, all, any, equal\n    \n    Notes\n    -----\n    If the following equation is element-wise True, then allclose returns\n    True.\n    \n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n    \n    The above equation is not symmetric in `a` and `b`, so that\n    ``allclose(a, b)`` might be different from ``allclose(b, a)`` in\n    some rare cases.\n    \n    The comparison of `a` and `b` uses standard broadcasting, which\n    means that `a` and `b` need not have the same shape in order for\n    ``allclose(a, b)`` to evaluate to True.  The same is true for\n    `equal` but not `array_equal`.\n    \n    `allclose` is not defined for non-numeric data types.\n    \n    Examples\n    --------\n    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\n    False\n    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\n    True\n    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\n    True\n    \n    \"\"\"\n    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))\n    return builtins.bool(res)"
    },
    {
      "name": "numpy.isclose",
      "category": "Array comparison",
      "description": "Returns a boolean array where two arrays are element-wise equal within a tolerance",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.isclose.html",
      "doc": "Returns a boolean array where two arrays are element-wise equal within a\ntolerance.\n\nThe tolerance values are positive, typically very small numbers. The\nrelative difference (rtol * abs(b)) and the absolute difference\natol are added together to compare against the absolute difference\nbetween a and b.\n\nWarning: The default atol is not appropriate for comparing numbers\nthat are much smaller than one (see Notes).\n\nParameters\n----------\na, b : array_like\n    Input arrays to compare.\nrtol : float\n    The relative tolerance parameter (see Notes).\natol : float\n    The absolute tolerance parameter (see Notes).\nequal_nan : bool\n    Whether to compare NaN's as equal.  If True, NaN's in a will be\n    considered equal to NaN's in b in the output array.\n\nReturns\n-------\ny : array_like\n    Returns a boolean array of where a and b are equal within the\n    given tolerance. If both a and b are scalars, returns a single\n    boolean value.\n\nSee Also\n--------\nallclose\n\nNotes\n-----\n.. versionadded:: 1.7.0\n\nFor finite values, isclose uses the following equation to test whether\ntwo floating point values are equivalent.\n\n absolute(a - b) <= (atol + rtol * absolute(b))\n\nUnlike the built-in math.isclose, the above equation is not symmetric\nin a and b -- it assumes b is the reference value -- so that\nisclose(a, b) might be different from isclose(b, a). Furthermore,\nthe default value of atol is not zero, and is used to determine what\nsmall values should be considered close to zero. The default value is\nappropriate for expected values of order unity: if the expected values\nare significantly smaller than one, it can result in false positives.\natol should be carefully selected for the use case at hand. A zero value\nfor atol will result in False if either a or b is zero.\n\nExamples\n--------\n>>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])\narray([ True, False])\n>>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])\narray([ True, True])\n>>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])\narray([False,  True])\n>>> np.isclose([1.0, np.nan], [1.0, np.nan])\narray([ True, False])\n>>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\narray([ True, True])\n>>> np.isclose([1e-8, 1e-7], [0.0, 0.0])\narray([ True, False])\n>>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)\narray([False, False])\n>>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])\narray([ True,  True])\n>>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)\narray([False,  True])",
      "code": "@array_function_dispatch(_isclose_dispatcher)\ndef isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):\n    \"\"\"\n    Returns a boolean array where two arrays are element-wise equal within a\n    tolerance.\n    \n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n    \n    .. warning:: The default `atol` is not appropriate for comparing numbers\n                 that are much smaller than one (see Notes).\n    \n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN's as equal.  If True, NaN's in `a` will be\n        considered equal to NaN's in `b` in the output array.\n    \n    Returns\n    -------\n    y : array_like\n        Returns a boolean array of where `a` and `b` are equal within the\n        given tolerance. If both `a` and `b` are scalars, returns a single\n        boolean value.\n    \n    See Also\n    --------\n    allclose\n    \n    Notes\n    -----\n    .. versionadded:: 1.7.0\n    \n    For finite values, isclose uses the following equation to test whether\n    two floating point values are equivalent.\n    \n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n    \n    Unlike the built-in `math.isclose`, the above equation is not symmetric\n    in `a` and `b` -- it assumes `b` is the reference value -- so that\n    `isclose(a, b)` might be different from `isclose(b, a)`. Furthermore,\n    the default value of atol is not zero, and is used to determine what\n    small values should be considered close to zero. The default value is\n    appropriate for expected values of order unity: if the expected values\n    are significantly smaller than one, it can result in false positives.\n    `atol` should be carefully selected for the use case at hand. A zero value\n    for `atol` will result in `False` if either `a` or `b` is zero.\n    \n    Examples\n    --------\n    >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])\n    array([ True, False])\n    >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])\n    array([ True, True])\n    >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])\n    array([False,  True])\n    >>> np.isclose([1.0, np.nan], [1.0, np.nan])\n    array([ True, False])\n    >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\n    array([ True, True])\n    >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])\n    array([ True, False])\n    >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)\n    array([False, False])\n    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])\n    array([ True,  True])\n    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)\n    array([False,  True])\n    \"\"\"\n    def within_tol(x, y, atol, rtol):\n        with errstate(invalid='ignore'):\n            return less_equal(abs(x-y), atol + rtol * abs(y))\n    \n    x = asanyarray(a)\n    y = asanyarray(b)\n    \n    # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).\n    # This will cause casting of x later. Also, make sure to allow subclasses\n    # (e.g., for numpy.ma).\n    # NOTE: We explicitly allow timedelta, which used to work. This could\n    #       possibly be deprecated. See also gh-18286.\n    #       timedelta works if `atol` is an integer or also a timedelta.\n    #       Other types probably do not work and we could disallow them here.\n    dt = multiarray.result_type(y, 1.)\n    y = asanyarray(y, dtype=dt)\n    \n    xfin = isfinite(x)\n    yfin = isfinite(y)\n    if all(xfin) and all(yfin):\n        return within_tol(x, y, atol, rtol)\n    else:\n        finite = xfin & yfin\n        cond = zeros_like(finite, subok=True)\n        # Because we're using boolean indexing, x & y must be the same shape.\n        # Ideally, we'd just do x, y = broadcast_arrays(x, y). It's in\n        # lib.stride_tricks, though, so we can't import it here.\n        x = x * ones_like(cond)\n        y = y * ones_like(cond)\n        # Avoid subtraction with infinite/nan values...\n        cond[finite] = within_tol(x[finite], y[finite], atol, rtol)\n        # Check for equality of infinite values...\n        cond[~finite] = (x[~finite] == y[~finite])\n        if equal_nan:\n            # Make NaN == NaN\n            both_nan = isnan(x) & isnan(y)\n            \n            # Needed to treat masked arrays correctly. = True would not work.\n            cond[both_nan] = both_nan[both_nan]\n        \n        return cond[()]  # Flatten 0d arrays to scalars"
    },
    {
      "name": "numpy.greater",
      "category": "Comparison",
      "description": "Return the truth value of (x1 > x2) element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.greater.html",
      "doc": "Return the truth value of (x1 > x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If x1.shape != x2.shape, they must be\n    broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of x1 and x2.\n    Typically of type bool, unless dtype=object is passed.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\ngreater_equal, less, less_equal, equal, not_equal\n\nExamples\n--------\n>>> np.greater([4,2],[2,2])\narray([ True, False])\n\nThe > operator can be used as a shorthand for np.greater on\nndarrays.\n\n>>> a = np.array([4, 2])\n>>> b = np.array([2, 2])\n>>> a > b\narray([ True, False])",
      "code": "C implementation: ufunc 'greater'"
    },
    {
      "name": "numpy.greater_equal",
      "category": "Comparison",
      "description": "Return the truth value of (x1 >= x2) element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.greater_equal.html",
      "doc": "Return the truth value of (x1 >= x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If x1.shape != x2.shape, they must be\n    broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\nout : bool or ndarray of bool\n    Output array, element-wise comparison of x1 and x2.\n    Typically of type bool, unless dtype=object is passed.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\ngreater, less, less_equal, equal, not_equal\n\nExamples\n--------\n>>> np.greater_equal([4, 2, 1], [2, 2, 2])\narray([ True, True, False])",
      "code": "C implementation: ufunc 'greater_equal'"
    },
    {
      "name": "numpy.less",
      "category": "Comparison",
      "description": "Return the truth value of (x1 < x2) element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.less.html",
      "doc": "Return the truth value of (x1 < x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If x1.shape != x2.shape, they must be\n    broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of x1 and x2.\n    Typically of type bool, unless dtype=object is passed.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\ngreater, less_equal, greater_equal, equal, not_equal\n\nExamples\n--------\n>>> np.less([1, 2], [2, 2])\narray([ True, False])",
      "code": "C implementation: ufunc 'less'"
    },
    {
      "name": "numpy.less_equal",
      "category": "Comparison",
      "description": "Return the truth value of (x1 <= x2) element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.less_equal.html",
      "doc": "Return the truth value of (x1 <= x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If x1.shape != x2.shape, they must be\n    broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of x1 and x2.\n    Typically of type bool, unless dtype=object is passed.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\ngreater, less, greater_equal, equal, not_equal\n\nExamples\n--------\n>>> np.less_equal([4, 2, 1], [2, 2, 2])\narray([False,  True,  True])",
      "code": "C implementation: ufunc 'less_equal'"
    },
    {
      "name": "numpy.equal",
      "category": "Comparison",
      "description": "Return (x1 == x2) element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.equal.html",
      "doc": "Return (x1 == x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If x1.shape != x2.shape, they must be\n    broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of x1 and x2.\n    Typically of type bool, unless dtype=object is passed.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\nnot_equal, greater_equal, less_equal, greater, less\n\nExamples\n--------\n>>> np.equal([0, 1, 3], np.arange(3))\narray([ True,  True, False])\n\nWhat is compared are values, not types. So an int (1) and an array of\nlength one can evaluate as True:\n\n>>> np.equal(1, np.ones(1))\narray([ True])\n\nThe == operator can be used as a shorthand for np.equal on\nndarrays.\n\n>>> a = np.array([2, 4, 6])\n>>> b = np.array([2, 4, 2])\n>>> a == b\narray([ True,  True, False])",
      "code": "C implementation: ufunc 'equal'"
    },
    {
      "name": "numpy.not_equal",
      "category": "Comparison",
      "description": "Return (x1 != x2) element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.not_equal.html",
      "doc": "Return (x1 != x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If x1.shape != x2.shape, they must be\n    broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of x1 and x2.\n    Typically of type bool, unless dtype=object is passed.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\nequal, greater, greater_equal, less, less_equal\n\nExamples\n--------\n>>> np.not_equal([1.,2.], [1., 3.])\narray([False,  True])\n>>> np.not_equal([1, 2], [[1, 3],[1, 4]])\narray([[False,  True],\n       [False,  True]])\n\nThe != operator can be used as a shorthand for np.not_equal on\nndarrays.\n\n>>> a = np.array([1., 2.])\n>>> b = np.array([1., 3.])\n>>> a != b\narray([False,  True])",
      "code": "C implementation: ufunc 'not_equal'"
    },
    {
      "name": "numpy.logical_and",
      "category": "Logical operations",
      "description": "Compute the truth value of x1 AND x2 element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.logical_and.html",
      "doc": "Compute the truth value of x1 AND x2 element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. If x1.shape != x2.shape, they must be\n    broadcastable to a common shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\ny : ndarray or bool\n    Boolean result of the logical AND operation applied to the elements\n    of x1 and x2; the shape is determined by broadcasting.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\nlogical_or, logical_not, logical_xor\nbitwise_and\n\nExamples\n--------\n>>> np.logical_and(True, False)\nFalse\n>>> np.logical_and([True, False], [False, False])\narray([False, False])\n\n>>> x = np.arange(5)\n>>> np.logical_and(x>1, x<4)\narray([False, False,  True,  True, False])\n\nThe & operator can be used as a shorthand for np.logical_and on\nboolean ndarrays.\n\n>>> a = np.array([True, False])\n>>> b = np.array([False, False])\n>>> a & b\narray([False, False])",
      "code": "C implementation: ufunc 'logical_and' in numpy/_core/src/umath/loops.c.src"
    },
    {
      "name": "numpy.logical_or",
      "category": "Logical operations",
      "description": "Compute the truth value of x1 OR x2 element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.logical_or.html",
      "doc": "Compute the truth value of x1 OR x2 element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Logical OR is applied to the elements of x1 and x2.\n    If x1.shape != x2.shape, they must be broadcastable to a common\n    shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\ny : ndarray or bool\n    Boolean result of the logical OR operation applied to the elements\n    of x1 and x2; the shape is determined by broadcasting.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\nlogical_and, logical_not, logical_xor\nbitwise_or\n\nExamples\n--------\n>>> np.logical_or(True, False)\nTrue\n>>> np.logical_or([True, False], [False, False])\narray([ True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_or(x < 1, x > 3)\narray([ True, False, False, False,  True])\n\nThe | operator can be used as a shorthand for np.logical_or on\nboolean ndarrays.\n\n>>> a = np.array([True, False])\n>>> b = np.array([False, False])\n>>> a | b\narray([ True, False])",
      "code": "C implementation: ufunc 'logical_or' in numpy/_core/src/umath/loops.c.src"
    },
    {
      "name": "numpy.logical_not",
      "category": "Logical operations",
      "description": "Compute the truth value of NOT x element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.logical_not.html",
      "doc": "Compute the truth value of NOT x element-wise.\n\nParameters\n----------\nx : array_like\n    Logical NOT is applied to the elements of x.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\ny : bool or ndarray of bool\n    Boolean result with the same shape as x of the NOT operation\n    on elements of x.\n    This is a scalar if x is a scalar.\n\nSee Also\n--------\nlogical_and, logical_or, logical_xor\n\nExamples\n--------\n>>> np.logical_not(3)\nFalse\n>>> np.logical_not([True, False, 0, 1])\narray([False,  True,  True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_not(x<3)\narray([False, False, False,  True,  True])",
      "code": "C implementation: ufunc 'logical_not' in numpy/_core/src/umath/loops.c.src"
    },
    {
      "name": "numpy.logical_xor",
      "category": "Logical operations",
      "description": "Compute the truth value of x1 XOR x2, element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.logical_xor.html",
      "doc": "Compute the truth value of x1 XOR x2, element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Logical XOR is applied to the elements of x1 and x2.\n    If x1.shape != x2.shape, they must be broadcastable to a common\n    shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\ny : bool or ndarray of bool\n    Boolean result of the logical XOR operation applied to the elements\n    of x1 and x2; the shape is determined by broadcasting.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\nlogical_and, logical_or, logical_not, bitwise_xor\n\nExamples\n--------\n>>> np.logical_xor(True, False)\nTrue\n>>> np.logical_xor([True, True, False, False], [True, False, True, False])\narray([False,  True,  True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_xor(x < 1, x > 3)\narray([ True, False, False, False,  True])\n\nSimple example showing support of broadcasting\n\n>>> np.logical_xor(0, np.eye(2))\narray([[ True, False],\n       [False,  True]])",
      "code": "C implementation: ufunc 'logical_xor' in numpy/_core/src/umath/loops.c.src"
    },
    {
      "name": "numpy.bitwise_and",
      "category": "Logical operations",
      "description": "Compute the bit-wise AND of two arrays element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.bitwise_and.html",
      "doc": "Compute the bit-wise AND of two arrays element-wise.\n\nComputes the bit-wise AND of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator &.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled.\n    If x1.shape != x2.shape, they must be broadcastable to a common\n    shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\nlogical_and\nbitwise_or, bitwise_xor\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nExamples\n--------\nThe number 13 is represented by 00001101. Likewise, 17 is\nrepresented by 00010001.  The bit-wise AND of 13 and 17 is\ntherefore 000000001, or 1:\n\n>>> np.bitwise_and(13, 17)\n1\n\n>>> np.bitwise_and(14, 13)\n12\n>>> np.binary_repr(12)\n'1100'\n>>> np.bitwise_and([14,3], 13)\narray([12,  1])\n\n>>> np.bitwise_and([11,7], [4,25])\narray([0, 1])\n>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))\narray([ 2,  4, 16])\n>>> np.bitwise_and([True, True], [False, True])\narray([False,  True])\n\nThe & operator can be used as a shorthand for np.bitwise_and on\nndarrays.\n\n>>> x1 = np.array([2, 5, 255])\n>>> x2 = np.array([3, 14, 16])\n>>> x1 & x2\narray([ 2,  4, 16])",
      "code": "C implementation: ufunc 'bitwise_and'"
    },
    {
      "name": "numpy.bitwise_or",
      "category": "Logical operations",
      "description": "Compute the bit-wise OR of two arrays element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.bitwise_or.html",
      "doc": "Compute the bit-wise OR of two arrays element-wise.\n\nComputes the bit-wise OR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator |.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled.\n    If x1.shape != x2.shape, they must be broadcastable to a common\n    shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\nlogical_or\nbitwise_and, bitwise_xor\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nExamples\n--------\nThe number 13 has the binary representation 00001101. Likewise,\n16 is represented by 00010000. The bit-wise OR of 13 and 16 is\nthen 00011101, or 29:\n\n>>> np.bitwise_or(13, 16)\n29\n>>> np.binary_repr(29)\n'11101'\n\n>>> np.bitwise_or(32, 2)\n34\n>>> np.bitwise_or([33, 4], 1)\narray([33,  5])\n>>> np.bitwise_or([33, 4], [1, 2])\narray([33,  6])\n\n>>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))\narray([  6,   5, 255])\n>>> np.array([2, 5, 255]) | np.array([4, 4, 4])\narray([  6,   5, 255])\n>>> np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),\n...               np.array([4, 4, 4, 2147483647], dtype=np.int32))\narray([         6,          5,        255, 2147483647])\n>>> np.bitwise_or([True, True], [False, True])\narray([ True,  True])\n\nThe | operator can be used as a shorthand for np.bitwise_or on\nndarrays.\n\n>>> x1 = np.array([2, 5, 255])\n>>> x2 = np.array([4, 4, 4])\n>>> x1 | x2\narray([  6,   5, 255])",
      "code": "C implementation: ufunc 'bitwise_or'"
    },
    {
      "name": "numpy.bitwise_xor",
      "category": "Logical operations",
      "description": "Compute the bit-wise XOR of two arrays element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.bitwise_xor.html",
      "doc": "Compute the bit-wise XOR of two arrays element-wise.\n\nComputes the bit-wise XOR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ^.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled.\n    If x1.shape != x2.shape, they must be broadcastable to a common\n    shape (which becomes the shape of the output).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if both x1 and x2 are scalars.\n\nSee Also\n--------\nlogical_xor\nbitwise_and, bitwise_or\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nExamples\n--------\nThe number 13 is represented by 00001101. Likewise, 17 is\nrepresented by 00010001.  The bit-wise XOR of 13 and 17 is\ntherefore 00011100, or 28:\n\n>>> np.bitwise_xor(13, 17)\n28\n>>> np.binary_repr(28)\n'11100'\n\n>>> np.bitwise_xor(31, 5)\n26\n>>> np.bitwise_xor([31,3], 5)\narray([26,  6])\n\n>>> np.bitwise_xor([31,3], [5,6])\narray([26,  5])\n>>> np.bitwise_xor([True, True], [False, True])\narray([ True, False])\n\nThe ^ operator can be used as a shorthand for np.bitwise_xor on\nndarrays.\n\n>>> x1 = np.array([True, True])\n>>> x2 = np.array([False, True])\n>>> x1 ^ x2\narray([ True, False])",
      "code": "C implementation: ufunc 'bitwise_xor'"
    },
    {
      "name": "numpy.bitwise_not",
      "category": "Logical operations", 
      "description": "Compute bit-wise inversion, or bit-wise NOT, element-wise",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.bitwise_not.html",
      "doc": "Compute bit-wise inversion, or bit-wise NOT, element-wise.\n\nComputes the bit-wise NOT of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ~.\n\nFor signed integer inputs, the bit-wise NOT of the absolute value is\nreturned. In a two's-complement system, this operation effectively flips\nall the bits, which results in -(x + 1). This is the most common method\nof representing signed integers on computers. A N-bit two's-complement\nsystem can represent every integer in the range -2^(N-1) to +2^(N-1)-1.\n\nParameters\n----------\nx : array_like\n    Only integer and boolean types are handled.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the out array will be set to the ufunc result.\n    Elsewhere, the out array will retain its original value.\n    Note that if an uninitialized out array is created via the default\n    out=None, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    ufunc docs.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if x is a scalar.\n\nSee Also\n--------\nbitwise_and, bitwise_or, bitwise_xor\nlogical_not\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nExamples\n--------\nWe've seen that 13 is represented by 00001101.\nThe invert or bit-wise NOT of 13 is then:\n\n>>> x = np.bitwise_not(np.array(13, dtype=np.uint8))\n>>> x\n242\n>>> np.binary_repr(x, width=8)\n'11110010'\n\nWhen using signed integer types, the result is the bit-wise NOT of\nthe unsigned type, interpreted as a signed integer:\n\n>>> np.bitwise_not(np.array([13], dtype=np.int8))\narray([-14], dtype=int8)\n>>> np.binary_repr(-14, width=8)\n'11110010'\n\nThe ~ operator can be used as a shorthand for np.bitwise_not on\nndarrays.\n\n>>> x1 = np.array([True, False])\n>>> ~x1\narray([False,  True])",
      "code": "C implementation: ufunc 'invert' (alias 'bitwise_not')"
    }
  ]
}