{
  "metadata": {
    "module": "numpy",
    "source": "https://github.com/numpy/numpy/tree/main/numpy",
    "description": "NumPy data type routines for type casting, promotion, testing, and information retrieval",
    "categories": [
      "Type Casting and Promotion",
      "Data Type Information",
      "Data Type Testing",
      "Data Type Creation",
      "Memory and Striding",
      "Miscellaneous Type Utilities"
    ]
  },
  "functions": [
    {
      "name": "numpy.can_cast",
      "category": "Type Casting and Promotion",
      "description": "Returns True if cast between data types can occur according to the casting rule",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.can_cast.html",
      "doc": "Returns whether a cast between data types can occur according to specified casting rules.\n\nParameters\n----------\nfrom_ : dtype, dtype specifier, NumPy scalar, or array\n    Data type, NumPy scalar, or array to cast from.\nto : dtype or dtype specifier\n    Data type to cast to.\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n    Controls what kind of data casting may occur.\n    - 'no': no casting is allowed\n    - 'equiv': only byte-order changes are allowed\n    - 'safe': only casts which can preserve values are allowed\n    - 'same_kind': safe casts or casts within a kind\n    - 'unsafe': any data conversions may be done\n\nReturns\n-------\nout : bool\n    True if cast can occur according to the casting rule.\n\nExamples\n--------\n>>> np.can_cast(np.int32, np.int64)\nTrue\n>>> np.can_cast(np.float64, complex)\nTrue\n>>> np.can_cast(complex, float)\nFalse\n>>> np.can_cast('i8', 'f8')\nTrue\n>>> np.can_cast('i8', 'f4')\nFalse",
      "code": "# C implementation for performance\n# Returns True if cast between data types can occur according to the casting rule\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in multiarray module"
    },
    {
      "name": "numpy.promote_types",
      "category": "Type Casting and Promotion",
      "description": "Returns the data type with the smallest size and smallest scalar kind to which both types may be safely cast",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.promote_types.html",
      "doc": "Returns the data type with the smallest size and smallest scalar kind to which both `type1` and `type2` may be safely cast.\n\nParameters\n----------\ntype1 : dtype or dtype specifier\n    First data type.\ntype2 : dtype or dtype specifier\n    Second data type.\n\nReturns\n-------\nout : dtype\n    The promoted data type.\n\nNotes\n-----\nThis function is symmetric, but rarely associative. It always returns a \"canonical\" dtype in native byte order.\n\nExamples\n--------\n>>> np.promote_types('f4', 'f8')\ndtype('float64')\n>>> np.promote_types('i8', 'f4')\ndtype('float64')\n>>> np.promote_types('i4', 'S8')\ndtype('S11')",
      "code": "# C implementation for performance\n# Returns the data type with the smallest size and smallest scalar kind to which both types may be safely cast\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in multiarray module"
    },
    {
      "name": "numpy.min_scalar_type",
      "category": "Type Casting and Promotion",
      "description": "For scalar a, returns the data type with the smallest size and smallest scalar kind which can hold its value",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.min_scalar_type.html",
      "doc": "For scalar `a`, returns the data type with the smallest size and smallest scalar kind which can hold its value.\n\nParameters\n----------\na : scalar or array_like\n    The value whose minimal data type is to be found.\n\nReturns\n-------\nout : dtype\n    The minimal data type.\n\nNotes\n-----\nFor non-scalar arrays, returns the original dtype. Floating point values are not demoted to integers, and complex values are not demoted to floats.\n\nExamples\n--------\n>>> np.min_scalar_type(10)\ndtype('uint8')\n>>> np.min_scalar_type(-260)\ndtype('int16')\n>>> np.min_scalar_type(3.1)\ndtype('float16')\n>>> np.min_scalar_type(1e50)\ndtype('float64')",
      "code": "# C implementation for performance\n# For scalar a, returns the data type with the smallest size and smallest scalar kind which can hold its value\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in multiarray module"
    },
    {
      "name": "numpy.result_type",
      "category": "Type Casting and Promotion",
      "description": "Returns the type that results from applying the NumPy type promotion rules to the arguments",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.result_type.html",
      "doc": "Returns the type that results from applying NumPy type promotion rules to the arguments.\n\nType promotion in NumPy works similarly to the rules in languages like C++, with some differences. When both scalars and arrays are used, the array's type takes precedence and the scalar's actual value is considered.\n\nParameters\n----------\n*arrays_and_dtypes : list of arrays and dtypes\n    The operands of some operation whose result type is needed.\n\nReturns\n-------\nout : dtype\n    The result type.\n\nExamples\n--------\n>>> np.result_type(3, np.arange(7, dtype='i1'))\ndtype('int8')\n>>> np.result_type('i4', 'c8')\ndtype('complex128')\n>>> np.result_type(3.0, -2)\ndtype('float64')",
      "code": "# C implementation for performance\n# Returns the type that results from applying the NumPy type promotion rules to the arguments\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in multiarray module"
    },
    {
      "name": "numpy.common_type",
      "category": "Type Casting and Promotion",
      "description": "Return a scalar type which is common to the input arrays",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.common_type.html",
      "doc": "Return a scalar type which is common to the input arrays.\n\nThe return type will always be an inexact (floating point) scalar type, even if all the arrays are integer arrays. If one of the inputs is an integer array, the minimum precision type that is returned is a 64-bit floating point dtype.\n\nParameters\n----------\n*arrays : sequence of ndarrays\n    Input arrays.\n\nReturns\n-------\nout : data type code\n    Data type code.\n\nExamples\n--------\n>>> np.common_type(np.arange(2, dtype=np.float32))\n<class 'numpy.float32'>\n>>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n<class 'numpy.float64'>\n>>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n<class 'numpy.complex128'>",
      "code": "\ndef common_type(*arrays):\n    \"\"\"\n    Return a scalar type which is common to the input arrays.\n\n    The return type will always be an inexact (i.e. floating point) scalar\n    type, even if all the arrays are integer arrays. If one of the inputs is\n    an integer array, the minimum precision type that is returned is a\n    64-bit floating point dtype.\n\n    All input arrays except int64 and uint64 can be safely cast to the\n    returned dtype without loss of information.\n\n    Parameters\n    ----------\n    array1, array2, ... : ndarrays\n        Input arrays.\n\n    Returns\n    -------\n    out : data type code\n        Data type code.\n\n    See Also\n    --------\n    dtype, mintypecode\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.common_type(np.arange(2, dtype=np.float32))\n    <class 'numpy.float32'>\n    >>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n    <class 'numpy.float64'>\n    >>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n    <class 'numpy.complex128'>\n\n    \"\"\"\n    is_complex = False\n    precision = 0\n    for a in arrays:\n        t = a.dtype.type\n        if iscomplexobj(a):\n            is_complex = True\n        if issubclass(t, _nx.integer):\n            p = 2  # array_precision[_nx.double]\n        else:\n            p = array_precision.get(t, None)\n            if p is None:\n                raise TypeError(\"can't get common type for non-numeric array\")\n        precision = max(precision, p)\n    if is_complex:\n        return array_type[1][precision]\n    else:\n        return array_type[0][precision]"
    },
    {
      "name": "numpy.dtype",
      "category": "Data Type Creation",
      "description": "Create a data type object",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.dtype.html",
      "doc": "Create a data type object.\n\nA numpy array is homogeneous, and contains elements described by a dtype object. A dtype object can be constructed from different combinations of fundamental numeric types.\n\nParameters\n----------\ndtype : data-type, or dict\n    Object to be converted to a data type object.\nalign : bool, optional\n    Add padding to the fields to match what a C compiler would output for a similar C-struct.\ncopy : bool, optional\n    Make a new copy of the data-type object.\nmetadata : dict, optional\n    An optional dictionary with dtype metadata.\n\nAttributes\n----------\nalignment : int\n    The required alignment (bytes) of this data type.\nbyteorder : str\n    A character indicating the byte-order of this data type.\nitemsize : int\n    The element size of this data type.\nkind : str\n    A character code (one of 'biufcmMOSUV') identifying the general kind of data.\nname : str\n    A bit-width name for this data type.\nshape : tuple of ints\n    Shape tuple of the sub-array if this data type describes a sub-array.\n\nExamples\n--------\n>>> np.dtype(np.int16)\ndtype('int16')\n>>> np.dtype([('f1', np.int16)])\ndtype([('f1', '<i2')])\n>>> np.dtype([('f1', np.uint64), ('f2', np.int32)])\ndtype([('f1', '<u8'), ('f2', '<i4')])",
      "code": "C implementation - numpy dtype is a built-in type"
    },
    {
      "name": "numpy.finfo",
      "category": "Data Type Information",
      "description": "Machine limits for floating point types",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.finfo.html",
      "doc": "Machine limits for floating point types.\n\nParameters\n----------\ndtype : float, dtype, or instance\n    Kind of floating point or complex floating point data-type about which to get information.\n\nAttributes\n----------\nbits : int\n    The number of bits occupied by the type.\ndtype : dtype\n    The dtype for which finfo returns information.\neps : float\n    The smallest representable positive number such that 1.0 + eps != 1.0.\nepsneg : float\n    The smallest representable positive number such that 1.0 - epsneg != 1.0.\niexp : int\n    The number of bits in the exponent portion of the floating point representation.\nmachar : MachAr\n    The object which calculated these parameters and holds more detailed information.\nmachep : int\n    The exponent that yields eps.\nmax : floating point number of the appropriate type\n    The largest representable number.\nmaxexp : int\n    The smallest positive power of the base (2) that causes overflow.\nmin : floating point number of the appropriate type\n    The smallest representable number, typically -max.\nminexp : int\n    The most negative power of the base (2) consistent with there being no leading 0's in the mantissa.\nnegep : int\n    The exponent that yields epsneg.\nnexp : int\n    The number of bits in the exponent including its sign and bias.\nnmant : int\n    The number of bits in the mantissa.\nprecision : int\n    The approximate number of decimal digits to which this kind of float is precise.\nresolution : floating point number of the appropriate type\n    The approximate decimal resolution of this type.\nsmallest_normal : float\n    The smallest positive floating point number with 1 as leading bit in the mantissa.\nsmallest_subnormal : float\n    The smallest positive floating point number with 0 as leading bit in the mantissa.\ntiny : float\n    An alias for smallest_normal.\n\nExamples\n--------\n>>> np.finfo(float)\nfinfo(resolution=1e-15, min=-1.7976931348623157e+308, max=1.7976931348623157e+308, dtype=float64)",
      "code": "# C implementation for performance\n# Machine limits for floating point types\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in getlimits module"
    },
    {
      "name": "numpy.iinfo",
      "category": "Data Type Information",
      "description": "Machine limits for integer types",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.iinfo.html",
      "doc": "Machine limits for integer types.\n\nParameters\n----------\nint_type : integer type, dtype, or instance\n    The kind of integer data type to get information about.\n\nAttributes\n----------\nbits : int\n    The number of bits occupied by the type.\ndtype : dtype\n    The dtype for which iinfo returns information.\nmin : int\n    The smallest integer expressible by the type.\nmax : int\n    The largest integer expressible by the type.\n\nExamples\n--------\n>>> ii16 = np.iinfo(np.int16)\n>>> ii16.min\n-32768\n>>> ii16.max\n32767\n>>> ii32 = np.iinfo(np.int32)\n>>> ii32.min\n-2147483648\n>>> ii32.max\n2147483647",
      "code": "# C implementation for performance\n# Machine limits for integer types\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in getlimits module"
    },
    {
      "name": "numpy.format_parser",
      "category": "Data Type Creation",
      "description": "Class to convert formats, names, titles description to a dtype",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.rec.format_parser.html",
      "doc": "Class to convert formats, names, titles description to a dtype.\n\nAfter constructing the format_parser object, the dtype attribute is the converted data-type.\n\nParameters\n----------\nformats : str or list of str\n    The format description, either specified as a string with comma-separated format descriptions in the form 'f8, i4, S5', or a list of format description strings.\nnames : str or list/tuple of str\n    The field names, either specified as a comma-separated string in the form 'col1, col2, col3', or as a list or tuple of strings.\ntitles : sequence\n    Sequence of title strings. An empty list defaults to None.\naligned : bool, optional\n    If True, align the fields by padding as the C-compiler would.\nbyteorder : str, optional\n    If specified, all the fields will be changed to the provided byte-order.\n\nAttributes\n----------\ndtype : dtype\n    The converted data-type.",
      "code": "Implementation in numpy.rec module"
    },
    {
      "name": "numpy.issubdtype",
      "category": "Data Type Testing",
      "description": "Returns True if first argument is a typecode lower/equal in type hierarchy",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.issubdtype.html",
      "doc": "Returns True if first argument is a typecode lower/equal in type hierarchy.\n\nThis is like the builtin issubclass, but for dtypes.\n\nParameters\n----------\narg1, arg2 : dtype_like\n    dtype or object coercible to one.\n\nReturns\n-------\nout : bool\n\nExamples\n--------\n>>> ints = np.array([1, 2, 3], dtype=np.int32)\n>>> np.issubdtype(ints.dtype, np.integer)\nTrue\n>>> np.issubdtype(ints.dtype, np.floating)\nFalse\n>>> floats = np.array([1, 2, 3], dtype=np.float32)\n>>> np.issubdtype(floats.dtype, np.integer)\nFalse\n>>> np.issubdtype(floats.dtype, np.floating)\nTrue\n>>> np.issubdtype(np.float64, np.float32)\nFalse\n>>> np.issubdtype(np.float32, np.float64)\nFalse\n>>> np.issubdtype(np.float64, np.floating)\nTrue\n>>> np.issubdtype(np.float32, np.floating)\nTrue\n>>> np.issubdtype('S1', np.bytes_)\nTrue\n>>> np.issubdtype('i4', np.signedinteger)\nTrue",
      "code": "\n@set_module('numpy')\ndef issubdtype(arg1, arg2):\n    \"\"\"\n    Returns True if first argument is a typecode lower/equal in type hierarchy.\n\n    This is like the builtin :func:`issubclass`, but for `dtype`\\ s.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype_like\n        `dtype` or object coercible to one\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    :ref:`arrays.scalars` : Overview of the numpy type hierarchy.\n    issubsctype, issubclass_\n\n    Examples\n    --------\n    `issubdtype` can be used to check the type of arrays:\n\n    >>> import numpy as np\n    >>> ints = np.array([1, 2, 3], dtype=np.int32)\n    >>> np.issubdtype(ints.dtype, np.integer)\n    True\n    >>> np.issubdtype(ints.dtype, np.floating)\n    False\n\n    >>> floats = np.array([1, 2, 3], dtype=np.float32)\n    >>> np.issubdtype(floats.dtype, np.integer)\n    False\n    >>> np.issubdtype(floats.dtype, np.floating)\n    True\n\n    Similar types of different sizes are not subdtypes of each other:\n\n    >>> np.issubdtype(np.float64, np.float32)\n    False\n    >>> np.issubdtype(np.float32, np.float64)\n    False\n\n    but both are subtypes of `floating`:\n\n    >>> np.issubdtype(np.float64, np.floating)\n    True\n    >>> np.issubdtype(np.float32, np.floating)\n    True\n\n    For convenience, dtype-like objects are allowed too:\n\n    >>> np.issubdtype('S1', np.bytes_)\n    True\n    >>> np.issubdtype('i4', np.signedinteger)\n    True\n\n    \"\"\"\n    if not issubclass_(arg1, generic):\n        arg1 = dtype(arg1).type\n    if not issubclass_(arg2, generic):\n        arg2 = dtype(arg2).type\n\n    return issubclass(arg1, arg2)"
    },
    {
      "name": "numpy.issubsctype",
      "category": "Data Type Testing",
      "description": "Determine if the first argument is a subclass of the second argument",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.issubsctype.html",
      "doc": "Determine if the first argument is a subclass of the second argument.\n\nParameters\n----------\narg1, arg2 : dtype or dtype specifier\n    Data-types.\n\nReturns\n-------\nout : bool\n    The result.\n\nExamples\n--------\n>>> np.issubsctype('S8', str)\nTrue\n>>> np.issubsctype(np.array([1]), int)\nTrue\n>>> np.issubsctype(np.array([1]), float)\nFalse",
      "code": "\n@set_module('numpy')\ndef issubsctype(arg1, arg2):\n    \"\"\"\n    Determine if the first argument is a subclass of the second argument.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype or dtype specifier\n        Data-types.\n\n    Returns\n    -------\n    out : bool\n        The result.\n\n    See Also\n    --------\n    issctype, issubdtype, obj2sctype\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.issubsctype('S8', str)\n    True\n    >>> np.issubsctype(np.array([1]), int)\n    True\n    >>> np.issubsctype(np.array([1]), float)\n    False\n\n    \"\"\"\n    return issubclass(obj2sctype(arg1), obj2sctype(arg2))"
    },
    {
      "name": "numpy.issubclass_",
      "category": "Data Type Testing",
      "description": "Determine if a class is a subclass of a second class",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.issubclass_.html",
      "doc": "Determine if a class is a subclass of a second class.\n\nissubclass_ is equivalent to the Python built-in issubclass, except that it returns False instead of raising a TypeError if one of the arguments is not a class.\n\nParameters\n----------\narg1 : class\n    Input class. True is returned if arg1 is a subclass of arg2.\narg2 : class or tuple of classes\n    Input class. If a tuple of classes, True is returned if arg1 is a subclass of any of the tuple elements.\n\nReturns\n-------\nout : bool\n    Whether arg1 is a subclass of arg2 or not.\n\nExamples\n--------\n>>> np.issubclass_(np.int32, int)\nFalse\n>>> np.issubclass_(np.int32, float)\nFalse\n>>> np.issubclass_(np.float64, float)\nTrue",
      "code": "\ndef issubclass_(arg1, arg2):\n    \"\"\"\n    Determine if a class is a subclass of a second class.\n\n    `issubclass_` is equivalent to the Python built-in ``issubclass``,\n    except that it returns False instead of raising a TypeError if one\n    of the arguments is not a class.\n\n    Parameters\n    ----------\n    arg1 : class\n        Input class. True is returned if `arg1` is a subclass of `arg2`.\n    arg2 : class or tuple of classes.\n        Input class. If a tuple of classes, True is returned if `arg1` is a\n        subclass of any of the tuple elements.\n\n    Returns\n    -------\n    out : bool\n        Whether `arg1` is a subclass of `arg2` or not.\n\n    See Also\n    --------\n    issubsctype, issubdtype, issctype\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.issubclass_(np.int32, int)\n    False\n    >>> np.issubclass_(np.int32, float)\n    False\n    >>> np.issubclass_(np.float64, float)\n    True\n\n    \"\"\"\n    try:\n        return issubclass(arg1, arg2)\n    except TypeError:\n        return False"
    },
    {
      "name": "numpy.find_common_type",
      "category": "Data Type Testing",
      "description": "Determine common type following standard coercion rules",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.find_common_type.html",
      "doc": "Determine common type following standard coercion rules.\n\nDeprecated since version 1.25.0: Use `numpy.result_type` or `numpy.promote_types` instead.\n\nParameters\n----------\narray_types : sequence\n    A list of dtypes or dtype convertible objects representing arrays.\nscalar_types : sequence\n    A list of dtypes or dtype convertible objects representing scalars.\n\nReturns\n-------\ndatatype : dtype\n    The common data type, which is the maximum of array_types ignoring scalar_types, unless the maximum of scalar_types is of a different kind. If the kind is not understood, then None is returned.",
      "code": "\n@set_module('numpy')\ndef find_common_type(array_types, scalar_types):\n    \"\"\"\n    Determine common type following standard coercion rules.\n\n    .. deprecated:: 1.25.0\n        This function is deprecated. Use `numpy.result_type` or\n        `numpy.promote_types` instead. To achieve semantics for the\n        `scalar_types` argument, use `numpy.result_type` and pass the Python\n        values `0`, `0.0`, or `0j`.\n        \n    Parameters\n    ----------\n    array_types : sequence\n        A list of dtypes or dtype convertible objects representing arrays.\n    scalar_types : sequence\n        A list of dtypes or dtype convertible objects representing scalars.\n\n    Returns\n    -------\n    datatype : dtype\n        The common data type, which is the maximum of `array_types` ignoring\n        `scalar_types`, unless the maximum of `scalar_types` is of a\n        different kind (`dtype.kind`). If the kind is not understood, then\n        None is returned.\n\n    See Also\n    --------\n    dtype, common_type, can_cast, mintypecode\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.find_common_type([], [np.int64, np.float32, complex])\n    dtype('complex128')\n    >>> np.find_common_type([np.int64, np.float32], [])\n    dtype('float64')\n\n    The standard casting rules ensure that a scalar cannot up-cast an\n    array unless the scalar is of a fundamentally different kind of data\n    (i.e. under a different hierarchy in the data type hierarchy) then\n    the array:\n\n    >>> np.find_common_type([np.float32], [np.int64, np.float64])\n    dtype('float32')\n\n    Complex is of a different type, so it will return a complex type:\n\n    >>> np.find_common_type([np.float32], [complex])\n    dtype('complex128')\n\n    Type specifier strings are convertible to dtypes and can therefore\n    be used instead of dtypes:\n\n    >>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])\n    dtype('complex128')\n\n    \"\"\"\n    # Deprecated 2022-11-07, NumPy 1.25\n    warnings.warn(\n        \"`find_common_type` is deprecated. \"\n        \"Use `numpy.result_type` or `numpy.promote_types`\\n\"\n        \"See: https://numpy.org/doc/stable/reference/generated/\"\n        \"numpy.find_common_type.html#numpy-find-common-type  (Deprecated NumPy 1.25)\",\n        DeprecationWarning,\n        stacklevel=2\n    )\n\n    # Rest of implementation..."
    },
    {
      "name": "numpy.typename",
      "category": "Miscellaneous Type Utilities",
      "description": "Return a description for the given data type code",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.typename.html",
      "doc": "Return a description for the given data type code.\n\nParameters\n----------\nchar : str\n    Data type code.\n\nReturns\n-------\nout : str\n    Description of the input data type code.\n\nExamples\n--------\n>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n>>> for typechar in typechars:\n...     print(typechar, ' : ', np.typename(typechar))\n...\nS1  :  character\n?  :  bool\nB  :  unsigned char\nD  :  complex double precision\nG  :  complex long double precision\nF  :  complex single precision\nI  :  unsigned integer\nH  :  unsigned short\nL  :  unsigned long integer\nO  :  object\nQ  :  unsigned long long integer\nS  :  character\nU  :  unicode\nV  :  void\nb  :  signed char\nd  :  double precision\ng  :  long precision\nf  :  single precision\ni  :  integer\nh  :  short\nl  :  long integer\nq  :  long long integer",
      "code": "# C implementation for performance\n# Return a description for the given data type code\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in multiarray module"
    },
    {
      "name": "numpy.sctype2char",
      "category": "Miscellaneous Type Utilities",
      "description": "Return the string representation of a scalar dtype",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.sctype2char.html",
      "doc": "Return the string representation of a scalar dtype.\n\nParameters\n----------\nsctype : scalar dtype or object\n    If a scalar dtype, the corresponding string character is returned. If an object, sctype2char tries to infer its scalar type and then return the corresponding string character.\n\nReturns\n-------\ntypechar : str\n    The string character corresponding to the scalar type.\n\nRaises\n------\nValueError\n    If sctype is an object for which the type cannot be inferred.\n\nExamples\n--------\n>>> for sctype in [np.int32, np.double, np.complex_, np.bytes_, np.ndarray]:\n...     print(np.sctype2char(sctype))\n...\nl\nd\nD\nS\nO\n\n>>> x = np.array([1., 2-1.j])\n>>> np.sctype2char(x)\n'D'\n>>> np.sctype2char(list)\n'O'",
      "code": "\n@set_module('numpy')\ndef sctype2char(sctype):\n    \"\"\"\n    Return the string representation of a scalar dtype.\n\n    Parameters\n    ----------\n    sctype : scalar dtype or object\n        If a scalar dtype, the corresponding string character is\n        returned. If an object, ``sctype2char`` tries to infer its scalar type\n        and then return the corresponding string character.\n\n    Returns\n    -------\n    typechar : str\n        The string character corresponding to the scalar type.\n\n    Raises\n    ------\n    ValueError\n        If `sctype` is an object for which the type cannot be inferred.\n\n    See Also\n    --------\n    obj2sctype, issctype, issubsctype, mintypecode\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> for sctype in [np.int32, np.double, np.complex_, np.bytes_, np.ndarray]:\n    ...     print(np.sctype2char(sctype))\n    l # may vary\n    d\n    D\n    S\n    O\n\n    >>> x = np.array([1., 2-1.j])\n    >>> np.sctype2char(x)\n    'D'\n    >>> np.sctype2char(list)\n    'O'\n\n    \"\"\"\n    sctype = obj2sctype(sctype)\n    if sctype is None:\n        raise ValueError(\"unrecognized type\")\n    if sctype not in sctypeDict.values():\n        # catches void, void pointer and user-defined structured dtypes\n        raise KeyError(sctype)\n    return dtype(sctype).char"
    },
    {
      "name": "numpy.mintypecode",
      "category": "Miscellaneous Type Utilities",
      "description": "Return the character for the minimum-size type to which given types can be safely cast",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.mintypecode.html",
      "doc": "Return the character for the minimum-size type to which given types can be safely cast.\n\nParameters\n----------\ntypechars : list of str or array_like\n    If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.\ntypeset : str or list of str, optional\n    The set of characters that the returned character is chosen from. The default set is 'GDFgdf'.\ndefault : str, optional\n    The default character if none in typeset matches.\n\nReturns\n-------\ntypechar : str\n    The character representing the minimum-size type found.\n\nExamples\n--------\n>>> np.mintypecode(['d', 'f', 'S'])\n'd'\n>>> x = np.array([1.1, 2-3.j])\n>>> np.mintypecode(x)\n'D'\n>>> np.mintypecode('abceh', default='G')\n'G'",
      "code": "\ndef mintypecode(typechars, typeset='GDFgdf', default='d'):\n    \"\"\"\n    Return the character for the minimum-size type to which given types can\n    be safely cast.\n\n    The returned type character must be the smallest size dtype such that an\n    array of the returned type can handle the data from an array of all types\n    in `typechars` (or if `typechars` is an array, then its dtype.char).\n\n    Parameters\n    ----------\n    typechars : list of str or array_like\n        If a list of strings, each string should represent a dtype.\n        If array_like, the character representation of the array dtype is used.\n    typeset : str or list of str, optional\n        The set of characters that the returned character is chosen from.\n        The default set is 'GDFgdf'.\n    default : str, optional\n        The default character, this is returned if none of the characters in\n        `typechars` matches a character in `typeset`.\n\n    Returns\n    -------\n    typechar : str\n        The character representing the minimum-size type found.\n\n    See Also\n    --------\n    dtype, sctype2char, maximum_sctype\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.mintypecode(['d', 'f', 'S'])\n    'd'\n    >>> x = np.array([1.1, 2-3.j])\n    >>> np.mintypecode(x)\n    'D'\n\n    >>> np.mintypecode('abceh', default='G')\n    'G'\n\n    \"\"\"\n    typecodes = ((isinstance(t, str) and t) or asarray(t).dtype.char\n                 for t in typechars)\n    intersection = set(t for t in typecodes if t in typeset)\n    if not intersection:\n        return default\n    if 'F' in intersection and 'd' in intersection:\n        return 'D'\n    return min(intersection, key=lambda x: (typeset.index(x) if x in typeset else len(typeset)))"
    },
    {
      "name": "numpy.maximum_sctype",
      "category": "Miscellaneous Type Utilities",
      "description": "Return the scalar type of highest precision of the same kind as the input",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.maximum_sctype.html",
      "doc": "Return the scalar type of highest precision of the same kind as the input.\n\nParameters\n----------\nt : dtype or dtype specifier\n    The input data type. This can be a dtype object or an object that is convertible to a dtype.\n\nReturns\n-------\nout : dtype\n    The highest precision data type of the same kind as t.\n\nExamples\n--------\n>>> np.maximum_sctype(int)\n<class 'numpy.int64'>\n>>> np.maximum_sctype(np.uint8)\n<class 'numpy.uint64'>\n>>> np.maximum_sctype(complex)\n<class 'numpy.complex256'>\n>>> np.maximum_sctype(str)\n<class 'numpy.str_'>\n>>> np.maximum_sctype('i2')\n<class 'numpy.int64'>\n>>> np.maximum_sctype('f4')\n<class 'numpy.float128'>",
      "code": "Implementation in numpy._core.numerictypes module"
    },
    {
      "name": "numpy.issctype",
      "category": "Data Type Testing",
      "description": "Determines whether the given object represents a scalar data-type",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.issctype.html",
      "doc": "Determines whether the given object represents a scalar data-type.\n\nParameters\n----------\nrep : any\n    If rep is an instance of a scalar dtype, True is returned. If not, False is returned.\n\nReturns\n-------\nout : bool\n    Boolean result of check whether rep is a scalar dtype.\n\nExamples\n--------\n>>> np.issctype(np.int32)\nTrue\n>>> np.issctype(list)\nFalse\n>>> np.issctype(1.1)\nFalse",
      "code": "\n@set_module('numpy')\ndef issctype(rep):\n    \"\"\"\n    Determines whether the given object represents a scalar data-type.\n\n    Parameters\n    ----------\n    rep : any\n        If `rep` is an instance of a scalar dtype, True is returned. If not,\n        False is returned.\n\n    Returns\n    -------\n    out : bool\n        Boolean result of check whether `rep` is a scalar dtype.\n\n    See Also\n    --------\n    issubsctype, issubdtype, obj2sctype, sctype2char\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.issctype(np.int32)\n    True\n    >>> np.issctype(list)\n    False\n    >>> np.issctype(1.1)\n    False\n\n    Strings are also a scalar type:\n\n    >>> np.issctype(np.dtype('str'))\n    True\n\n    \"\"\"\n    if not isinstance(rep, (type, dtype)):\n        return False\n    try:\n        res = obj2sctype(rep)\n        if res and res != object_:\n            return True\n        return False\n    except Exception:\n        return False"
    },
    {
      "name": "numpy.obj2sctype",
      "category": "Miscellaneous Type Utilities",
      "description": "Return the scalar dtype or NumPy equivalent of Python type of an object",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.obj2sctype.html",
      "doc": "Return the scalar dtype or NumPy equivalent of Python type of an object.\n\nParameters\n----------\nrep : any\n    The object of which the type is returned.\ndefault : any, optional\n    If given, this is returned for objects whose types cannot be determined. If not given, None is returned for those objects.\n\nReturns\n-------\ndtype : dtype or Python type\n    The data type of rep.\n\nExamples\n--------\n>>> np.obj2sctype(np.int32)\n<class 'numpy.int32'>\n>>> np.obj2sctype(np.array([1., 2.]))\n<class 'numpy.float64'>\n>>> np.obj2sctype(np.array([1.j]))\n<class 'numpy.complex128'>\n>>> np.obj2sctype(dict)\n<class 'numpy.object_'>\n>>> np.obj2sctype('string')\n>>> np.obj2sctype(1, default=list)\n<class 'list'>",
      "code": "\n@set_module('numpy')\ndef obj2sctype(rep, default=None):\n    \"\"\"\n    Return the scalar dtype or NumPy equivalent of Python type of an object.\n\n    Parameters\n    ----------\n    rep : any\n        The object of which the type is returned.\n    default : any, optional\n        If given, this is returned for objects whose types can not be\n        determined. If not given, None is returned for those objects.\n\n    Returns\n    -------\n    dtype : dtype or Python type\n        The data type of `rep`.\n\n    See Also\n    --------\n    sctype2char, issctype, issubsctype, issubdtype, maximum_sctype\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.obj2sctype(np.int32)\n    <class 'numpy.int32'>\n    >>> np.obj2sctype(np.array([1., 2.]))\n    <class 'numpy.float64'>\n    >>> np.obj2sctype(np.array([1.j]))\n    <class 'numpy.complex128'>\n\n    >>> np.obj2sctype(dict)\n    <class 'numpy.object_'>\n    >>> np.obj2sctype('string')\n\n    >>> np.obj2sctype(1, default=list)\n    <class 'list'>\n\n    \"\"\"\n    # prevent abstract types (these are classes, not instances)\n    if isinstance(rep, type) and issubclass(rep, generic):\n        return rep\n    # extract dtype from arrays\n    if isinstance(rep, ndarray):\n        return rep.dtype.type\n    # fall back on dtype to convert\n    try:\n        res = dtype(rep)\n    except Exception:\n        return default\n    else:\n        return res.type"
    },
    {
      "name": "numpy.isdtype",
      "category": "Data Type Testing",
      "description": "Determine if a provided dtype is of a specified data type kind",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.isdtype.html",
      "doc": "Determine if a provided dtype is of a specified data type kind.\n\nThis function only supports built-in NumPy's data types. Third-party dtypes are not yet supported.\n\nParameters\n----------\ndtype : dtype\n    The input dtype.\nkind : dtype or str or tuple of dtypes/strs\n    dtype or dtype kind. Allowed dtype kinds are:\n    - 'bool': boolean kind\n    - 'signed integer': signed integer data types\n    - 'unsigned integer': unsigned integer data types\n    - 'integral': integer data types\n    - 'real floating': real-valued floating-point data types\n    - 'complex floating': complex floating-point data types\n    - 'numeric': numeric data types\n\nReturns\n-------\nout : bool\n    True if the input dtype is of the specified kind.\n\nExamples\n--------\n>>> np.isdtype(np.float32, np.floating)\nTrue\n>>> np.isdtype(np.float32, 'real floating')\nTrue\n>>> np.isdtype(np.complex128, 'real floating')\nFalse\n>>> np.isdtype(np.complex128, 'complex floating')\nTrue\n>>> np.isdtype(np.int16, 'integral')\nTrue\n>>> np.isdtype(np.int16, 'numeric')\nTrue",
      "code": "\n@set_module('numpy')\ndef isdtype(dtype, kind):\n    \"\"\"\n    Determine if a provided dtype is of a specified data type kind.\n\n    This function only supports built-in NumPy's data types.\n    Third-party dtypes are not yet supported.\n\n    Parameters\n    ----------\n    dtype : dtype\n        The input dtype.\n    kind : dtype or str or tuple of dtypes/strs.\n        dtype or dtype kind. Allowed dtype kinds are:\n        * ``'bool'`` : boolean kind\n        * ``'signed integer'`` : signed integer data types\n        * ``'unsigned integer'`` : unsigned integer data types\n        * ``'integral'`` : integer data types\n        * ``'real floating'`` : real-valued floating-point data types\n        * ``'complex floating'`` : complex floating-point data types\n        * ``'numeric'`` : numeric data types\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    issubdtype\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.isdtype(np.float32, np.floating)\n    True\n    >>> np.isdtype(np.float32, \"real floating\")\n    True\n    >>> np.isdtype(np.complex128, \"real floating\")\n    False\n    >>> np.isdtype(np.complex128, \"complex floating\")\n    True\n    >>> np.isdtype(np.int16, \"integral\")\n    True\n    >>> np.isdtype(np.int16, \"numeric\")\n    True\n\n    \"\"\"\n    dtype = np.dtype(dtype)\n    if isinstance(kind, tuple):\n        return any(isdtype(dtype, k) for k in kind)\n    elif isinstance(kind, np.dtype):\n        return dtype == kind\n    elif isinstance(kind, str):\n        if kind == \"bool\":\n            return dtype == np.bool_\n        elif kind == \"signed integer\":\n            return dtype.kind == 'i'\n        elif kind == \"unsigned integer\":\n            return dtype.kind == 'u'\n        elif kind == \"integral\":\n            return dtype.kind in 'iu'\n        elif kind == \"real floating\":\n            return dtype.kind == 'f'\n        elif kind == \"complex floating\":\n            return dtype.kind == 'c'\n        elif kind == \"numeric\":\n            return dtype.kind in 'biufc'\n        else:\n            raise ValueError(f\"Unknown kind: {kind}\")\n    elif kind is None:\n        return True\n    else:\n        return np.issubdtype(dtype, kind)"
    },
    {
      "name": "numpy.typecodes",
      "category": "Miscellaneous Type Utilities",
      "description": "Dictionary mapping strings to corresponding type character codes",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.typecodes.html",
      "doc": "typecodes : dict\n\nA dictionary with string keys that represent NumPy dtype categories and string values that contain type codes for the NumPy data types in each category.\n\nKeys include:\n- 'Character': 'S1'\n- 'Integer': 'bhilqnp'\n- 'UnsignedInteger': 'BHILQNP'\n- 'Float': 'fdg'\n- 'Complex': 'FDG'\n- 'AllInteger': 'bBhHiIlLqQnNpP'\n- 'AllFloat': 'fdgFDG'\n- 'Datetime': 'Mm'\n- 'All': '?bhilqnpBHILQNPfdgFDGSUVOMm'\n\nThis is useful for iterating over all dtypes of a certain kind.\n\nExamples\n--------\n>>> np.typecodes['Character']\n'S1'\n>>> for typechar in np.typecodes['Integer']:\n...     print(typechar)\n...\nb\nh\ni\nl\nq\nn\np",
      "code": "typecodes = {\n    'Character': 'S1',\n    'Integer': 'bhilqnp',\n    'UnsignedInteger': 'BHILQNP',\n    'Float': 'fdg',\n    'Complex': 'FDG',\n    'AllInteger': 'bBhHiIlLqQnNpP',\n    'AllFloat': 'fdgFDG',\n    'Datetime': 'Mm',\n    'All': '?bhilqnpBHILQNPfdgFDGSUVOMm'\n}"
    },
    {
      "name": "numpy.as_strided",
      "category": "Memory and Striding",
      "description": "Create a view into the array with the given shape and strides",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.lib.stride_tricks.as_strided.html",
      "doc": "Create a view into the array with the given shape and strides.\n\nWarning: This function has to be used with extreme care, see notes.\n\nParameters\n----------\nx : ndarray\n    Array to create a new view for.\nshape : sequence of int, optional\n    The shape of the new array. Defaults to x.shape.\nstrides : sequence of int, optional\n    The strides of the new array. Defaults to x.strides.\nsubok : bool, optional\n    If True, subclasses are preserved.\nwriteable : bool, optional\n    If set to False, the returned array will always be readonly.\n\nReturns\n-------\nview : ndarray\n\nNotes\n-----\nas_strided creates a view into the array given the exact strides and shape. This means it manipulates the internal data structure of ndarray and, if done incorrectly, the array elements can point to invalid memory and can corrupt results or crash your program.\n\nExamples\n--------\n>>> x = np.array([1, 2, 3, 4, 5])\n>>> np.lib.stride_tricks.as_strided(x, shape=(3,), strides=(8,))\narray([1, 2, 3])",
      "code": "\ndef as_strided(x, shape=None, strides=None, subok=False, writeable=True):\n    \"\"\"\n    Create a view into the array with the given shape and strides.\n\n    .. warning:: This function has to be used with extreme care, see notes.\n\n    Parameters\n    ----------\n    x : ndarray\n        Array to create a new view for.\n    shape : sequence of int, optional\n        The shape of the new array. Defaults to ``x.shape``.\n    strides : sequence of int, optional\n        The strides of the new array. Defaults to ``x.strides``.\n    subok : bool, optional\n        .. versionadded:: 1.10\n\n        If True, subclasses are preserved.\n    writeable : bool, optional\n        .. versionadded:: 1.12\n\n        If set to False, the returned array will always be readonly.\n        Otherwise it will be writable if the original array was. It\n        is advisable to set this to False if possible (see Notes).\n\n    Returns\n    -------\n    view : ndarray\n\n    See also\n    --------\n    ndarray.strides : The array's strides.\n    ndarray.shape : The array's shape.\n    broadcast_to : broadcast an array to a given shape.\n    reshape : reshape an array.\n    lib.index_tricks.sliding_window_view :\n        userfriendly and safe function for rolling window views.\n\n    Notes\n    -----\n    ``as_strided`` creates a view into the array given the exact strides\n    and shape. This means it manipulates the internal data structure of\n    ndarray and, if done incorrectly, the array elements can point to\n    invalid memory and can corrupt results or crash your program.\n    It is advisable to always use the original ``x.strides`` when\n    calculating new strides to avoid reliance on a contiguous memory\n    layout.\n\n    Furthermore, arrays created with this function often contain self\n    overlapping memory, so that two elements are identical.\n    Vectorized write operations on such arrays will typically be\n    unpredictable. They may even give different results for small, large,\n    or transposed arrays.\n    Since writing to these arrays has to be tested and done with great\n    care, you may want to use ``writeable=False`` to avoid accidental write\n    operations.\n\n    For these reasons it is advisable to avoid ``as_strided`` when\n    possible.\n    \"\"\"\n    # first convert input to array, possibly keeping subclass\n    x = np.array(x, copy=None, subok=subok)\n    interface = dict(x.__array_interface__)\n    if shape is not None:\n        interface['shape'] = tuple(shape)\n    if strides is not None:\n        interface['strides'] = tuple(strides)\n\n    array = np.asarray(DummyArray(interface, base=x))\n    # The array interface should ensure that the array is already in\n    # exactly the state we want, but check just in case...\n    # 2022-07-08 1.24.0.dev0+236.g86ba6cc1f7\n    # assert array.dtype == x.dtype\n    # Since dtype is not part of the interface, it may have gotten\n    # lost in the np.asarray call above. Explicitly re-assign it\n    # as a workaround.\n    # See: https://github.com/numpy/numpy/issues/21871\n    array.dtype = x.dtype\n\n    view = _maybe_view_as_subclass(x, array)\n\n    if view.flags.writeable and not writeable:\n        view.flags.writeable = False\n\n    return view"
    },
    {
      "name": "numpy.shares_memory",
      "category": "Memory and Striding",
      "description": "Determine if two arrays share memory",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.shares_memory.html",
      "doc": "Determine if two arrays share memory.\n\nWarning: This function can be exponentially slow for some inputs, see Notes.\n\nParameters\n----------\na, b : ndarray\n    Input arrays.\nmax_work : int, optional\n    Effort to spend on solving the overlap problem.\n\nReturns\n-------\nout : bool\n    True if a and b share memory.\n\nRaises\n------\nnumpy.exceptions.TooHardError\n    Exceeded max_work.\n\nNotes\n-----\ncan_share_memory bounds the problem complexity.\n\nExamples\n--------\n>>> x = np.array([1, 2, 3, 4])\n>>> np.shares_memory(x, x)\nTrue\n>>> np.shares_memory(x, x.copy())\nFalse",
      "code": "# C implementation for performance\n# Determine if two arrays share memory\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in multiarray module"
    },
    {
      "name": "numpy.may_share_memory",
      "category": "Memory and Striding",
      "description": "Determine if two arrays might share memory",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.may_share_memory.html",
      "doc": "Determine if two arrays might share memory.\n\nA return of True does not necessarily mean that the two arrays share any element. It just means that they might.\n\nOnly the memory bounds of a and b are checked by default.\n\nParameters\n----------\na, b : ndarray\n    Input arrays.\nmax_work : int, optional\n    Effort to spend on solving the overlap problem. See shares_memory for details. Default is MAY_SHARE_BOUNDS.\n\nReturns\n-------\nout : bool\n    True if a and b might share memory.\n\nExamples\n--------\n>>> np.may_share_memory(np.array([1,2]), np.array([5,6]))\nFalse\n>>> x = np.zeros([3, 4])\n>>> np.may_share_memory(x[:,0], x[:,1])\nTrue",
      "code": "# C implementation for performance\n# Determine if two arrays might share memory\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in multiarray module"
    }
  ]
}