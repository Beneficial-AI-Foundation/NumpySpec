{
  "metadata": {
    "module": "numpy.lib._arraysetops_impl",
    "source": "https://github.com/numpy/numpy/blob/main/numpy/lib/_arraysetops_impl.py",
    "description": "Set operations for arrays based on sorting"
  },
  "functions": [
    {
      "name": "numpy.unique",
      "category": "Unique operations",
      "description": "Find the unique elements of an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.unique.html",
      "doc": "Find the unique elements of an array.\n\nReturns the sorted unique elements of an array. There are three optional\noutputs in addition to the unique elements:\n\n* the indices of the input array that give the unique values\n* the indices of the unique array that reconstruct the input array\n* the number of times each unique value comes up in the input array\n\nParameters\n----------\nar : array_like\n    Input array. Unless `axis` is specified, this will be flattened if it\n    is not already 1-D.\nreturn_index : bool, optional\n    If True, also return the indices of `ar` (along the specified axis,\n    if provided, or in the flattened array) that result in the unique array.\nreturn_inverse : bool, optional\n    If True, also return the indices of the unique array (for the specified\n    axis, if provided) that can be used to reconstruct `ar`.\nreturn_counts : bool, optional\n    If True, also return the number of times each unique item appears\n    in `ar`.\naxis : int or None, optional\n    The axis to operate on. If None, `ar` will be flattened. If an integer,\n    the subarrays indexed by the given axis will be flattened and treated\n    as the elements of a 1-D array with the dimension of the given axis,\n    see the notes for more details.  Object arrays or structured arrays\n    that contain objects are not supported if the `axis` kwarg is used. The\n    default is None.\n\n    .. versionadded:: 1.13.0\n\nequal_nan : bool, optional\n    If True, collapses multiple NaN values in the return array into one.\n\n    .. versionadded:: 1.24\n\nReturns\n-------\nunique : ndarray\n    The sorted unique values.\nunique_indices : ndarray, optional\n    The indices of the first occurrences of the unique values in the\n    original array. Only provided if `return_index` is True.\nunique_inverse : ndarray, optional\n    The indices to reconstruct the original array from the\n    unique array. Only provided if `return_inverse` is True.\nunique_counts : ndarray, optional\n    The number of times each of the unique values comes up in the\n    original array. Only provided if `return_counts` is True.\n\n    .. versionadded:: 1.9.0",
      "code": "def unique(ar, return_index=False, return_inverse=False,\n           return_counts=False, axis=None, *, equal_nan=True):\n    \"\"\"\n    Find the unique elements of an array.\n\n    Returns the sorted unique elements of an array. There are three optional\n    outputs in addition to the unique elements:\n\n    * the indices of the input array that give the unique values\n    * the indices of the unique array that reconstruct the input array\n    * the number of times each unique value comes up in the input array\n\n    Parameters\n    ----------\n    ar : array_like\n        Input array. Unless `axis` is specified, this will be flattened if it\n        is not already 1-D.\n    return_index : bool, optional\n        If True, also return the indices of `ar` (along the specified axis,\n        if provided, or in the flattened array) that result in the unique array.\n    return_inverse : bool, optional\n        If True, also return the indices of the unique array (for the specified\n        axis, if provided) that can be used to reconstruct `ar`.\n    return_counts : bool, optional\n        If True, also return the number of times each unique item appears\n        in `ar`.\n    axis : int or None, optional\n        The axis to operate on. If None, `ar` will be flattened. If an integer,\n        the subarrays indexed by the given axis will be flattened and treated\n        as the elements of a 1-D array with the dimension of the given axis,\n        see the notes for more details.  Object arrays or structured arrays\n        that contain objects are not supported if the `axis` kwarg is used. The\n        default is None.\n\n        .. versionadded:: 1.13.0\n\n    equal_nan : bool, optional\n        If True, collapses multiple NaN values in the return array into one.\n\n        .. versionadded:: 1.24\n\n    Returns\n    -------\n    unique : ndarray\n        The sorted unique values.\n    unique_indices : ndarray, optional\n        The indices of the first occurrences of the unique values in the\n        original array. Only provided if `return_index` is True.\n    unique_inverse : ndarray, optional\n        The indices to reconstruct the original array from the\n        unique array. Only provided if `return_inverse` is True.\n    unique_counts : ndarray, optional\n        The number of times each of the unique values comes up in the\n        original array. Only provided if `return_counts` is True.\n\n        .. versionadded:: 1.9.0\n\n    See Also\n    --------\n    repeat : Repeat elements of an array.\n\n    Notes\n    -----\n    When an axis is specified the subarrays indexed by the axis are sorted.\n    This is done by making the specified axis the first dimension of the array\n    (move the axis to the first dimension to keep the order of the other axes)\n    and then flattening the subarrays in C order. The flattened subarrays are\n    then viewed as a structured type with each element given a label, with the\n    effect that we end up with a 1-D array of structured types that can be\n    treated in the same way as any other 1-D array. The result is that the\n    flattened subarrays are sorted in lexicographic order starting with the\n    first element.\n\n    .. versionchanged: 1.21\n        If nan values are in the input array, a single nan is put\n        to the end of the sorted unique values.\n\n        Also for complex arrays all NaN values are considered equivalent\n        (no matter whether the NaN is in the real or imaginary part).\n        As the representant for the returned array the smallest one in the\n        lexicographical order is chosen - see np.sort for how the lexicographical\n        order is defined for complex arrays.\n\n    .. versionchanged: 2.0\n        For multi-dimensional inputs, ``unique_inverse`` is reshaped\n        such that the input can be reconstructed using\n        ``np.take(unique, unique_inverse, axis=axis)``. The result is\n        now not 1-dimensional when ``axis=None``.\n\n        Note that in NumPy 2.0.0 a higher dimensional array was returned also\n        when ``axis`` was not ``None``.  This was reverted, but\n        ``inverse.reshape(-1)`` can be used to ensure compatibility with both\n        versions.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.unique([1, 1, 2, 2, 3, 3])\n    array([1, 2, 3])\n    >>> a = np.array([[1, 1], [2, 3]])\n    >>> np.unique(a)\n    array([1, 2, 3])\n\n    Return the unique rows of a 2D array\n\n    >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])\n    >>> np.unique(a, axis=0)\n    array([[1, 0, 0], [2, 3, 4]])\n\n    Return the indices of the original array that give the unique values:\n\n    >>> a = np.array(['a', 'b', 'b', 'c', 'a'])\n    >>> u, indices = np.unique(a, return_index=True)\n    >>> u\n    array(['a', 'b', 'c'], dtype='<U1')\n    >>> indices\n    array([0, 1, 3])\n    >>> a[indices]\n    array(['a', 'b', 'c'], dtype='<U1')\n\n    Reconstruct the input array from the unique values and inverse:\n\n    >>> a = np.array([1, 2, 6, 4, 2, 3, 2])\n    >>> u, indices = np.unique(a, return_inverse=True)\n    >>> u\n    array([1, 2, 3, 4, 6])\n    >>> indices\n    array([0, 1, 4, 3, 1, 2, 1])\n    >>> u[indices]\n    array([1, 2, 6, 4, 2, 3, 2])\n\n    Reconstruct the input values from the unique values and counts:\n\n    >>> a = np.array([1, 2, 6, 4, 2, 3, 2])\n    >>> values, counts = np.unique(a, return_counts=True)\n    >>> values\n    array([1, 2, 3, 4, 6])\n    >>> counts\n    array([1, 3, 1, 1, 1])\n    >>> np.repeat(values, counts)\n    array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved\n\n    \"\"\"\n    ar = np.asanyarray(ar)\n    if axis is None:\n        ret = _unique1d(ar, return_index, return_inverse, return_counts, \n                        equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)\n        return _unpack_tuple(ret)\n\n    # axis was specified and not None\n    try:\n        ar = np.moveaxis(ar, axis, 0)\n    except np.exceptions.AxisError:\n        # this removes the \"axis1\" or \"axis2\" prefix from the error message\n        raise np.exceptions.AxisError(axis, ar.ndim) from None\n    inverse_shape = [1] * ar.ndim\n    inverse_shape[axis] = ar.shape[0]\n\n    # Must reshape to a contiguous 2D array for this to work...\n    orig_shape, orig_dtype = ar.shape, ar.dtype\n    ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))\n    ar = np.ascontiguousarray(ar)\n    dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]\n\n    # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured\n    # data type with `m` fields where each field has the data type of `ar`.\n    # In the following, we create the array `consolidated`, which has\n    # shape `(n,)` with data type `dtype`.\n    try:\n        if ar.shape[1] > 0:\n            consolidated = ar.view(dtype)\n        else:\n            # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is\n            # a data type with itemsize 0, and the call `ar.view(dtype)` will\n            # fail.  Instead, we'll use `np.empty` to explicitly create the\n            # array with shape `(len(ar),)`.  Because `dtype` in this case has\n            # itemsize 0, the total size of the result is still 0 bytes.\n            consolidated = np.empty(len(ar), dtype=dtype)\n    except TypeError as e:\n        # There's no good way to do this for object arrays, etc...\n        msg = 'The axis argument to unique is not supported for dtype {dt}'\n        raise TypeError(msg.format(dt=ar.dtype)) from e\n\n    def reshape_uniq(uniq):\n        n = len(uniq)\n        uniq = uniq.view(orig_dtype)\n        uniq = uniq.reshape(n, *orig_shape[1:])\n        uniq = np.moveaxis(uniq, 0, axis)\n        return uniq\n\n    output = _unique1d(consolidated, return_index,\n                       return_inverse, return_counts,\n                       equal_nan=equal_nan, inverse_shape=inverse_shape,\n                       axis=axis)\n    output = (reshape_uniq(output[0]),) + output[1:]\n    return _unpack_tuple(output)"
    },
    {
      "name": "numpy.in1d",
      "category": "Testing membership",
      "description": "Test whether each element of a 1-D array is also present in a second array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.in1d.html",
      "doc": "Test whether each element of a 1-D array is also present in a second array.\n\n.. deprecated:: 2.0\n    Use :func:`isin` instead of `in1d` for new code.\n\nReturns a boolean array the same length as `ar1` that is True\nwhere an element of `ar1` is in `ar2` and False otherwise.\n\nParameters\n----------\nar1 : (M,) array_like\n    Input array.\nar2 : array_like\n    The values against which to test each value of `ar1`.\nassume_unique : bool, optional\n    If True, the input arrays are both assumed to be unique, which\n    can speed up the calculation.  Default is False.\ninvert : bool, optional\n    If True, the values in the returned array are inverted (that is,\n    False where an element of `ar1` is in `ar2` and True otherwise).\n    Default is False. ``np.in1d(a, b, invert=True)`` is equivalent\n    to (but is faster than) ``np.invert(in1d(a, b))``.\nkind : {None, 'sort', 'table'}, optional\n    The algorithm to use. This will not affect the final result,\n    but will affect the speed and memory use. The default, None,\n    will select automatically based on memory considerations.\n\n    * If 'sort', will use a mergesort-based approach. This will have\n      a memory usage of roughly 6 times the sum of the sizes of\n      `ar1` and `ar2`, not accounting for size of dtypes.\n    * If 'table', will use a lookup table approach similar\n      to a counting sort. This is only available for boolean and\n      integer arrays. This will have a memory usage of the\n      size of `ar1` plus the max-min value of `ar2`. `assume_unique`\n      has no effect when the 'table' option is used.\n    * If None, will automatically choose 'table' if\n      the required memory allocation is less than or equal to\n      6 times the sum of the sizes of `ar1` and `ar2`,\n      otherwise will use 'sort'. This is done to not use\n      a large amount of memory by default, even though\n      'table' may be faster in most cases. If 'table' is chosen,\n      `assume_unique` will have no effect.\n\n    .. versionadded:: 1.8.0\n\nReturns\n-------\nin1d : (M,) ndarray, bool\n    The values `ar1[in1d]` are in `ar2`.",
      "code": "def in1d(ar1, ar2, assume_unique=False, invert=False, *, kind=None):\n    \"\"\"\n    Test whether each element of a 1-D array is also present in a second array.\n\n    .. deprecated:: 2.0\n        Use :func:`isin` instead of `in1d` for new code.\n\n    Returns a boolean array the same length as `ar1` that is True\n    where an element of `ar1` is in `ar2` and False otherwise.\n\n    Parameters\n    ----------\n    ar1 : (M,) array_like\n        Input array.\n    ar2 : array_like\n        The values against which to test each value of `ar1`.\n    assume_unique : bool, optional\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n    invert : bool, optional\n        If True, the values in the returned array are inverted (that is,\n        False where an element of `ar1` is in `ar2` and True otherwise).\n        Default is False. ``np.in1d(a, b, invert=True)`` is equivalent\n        to (but is faster than) ``np.invert(in1d(a, b))``.\n    kind : {None, 'sort', 'table'}, optional\n        The algorithm to use. This will not affect the final result,\n        but will affect the speed and memory use. The default, None,\n        will select automatically based on memory considerations.\n\n        * If 'sort', will use a mergesort-based approach. This will have\n          a memory usage of roughly 6 times the sum of the sizes of\n          `ar1` and `ar2`, not accounting for size of dtypes.\n        * If 'table', will use a lookup table approach similar\n          to a counting sort. This is only available for boolean and\n          integer arrays. This will have a memory usage of the\n          size of `ar1` plus the max-min value of `ar2`. `assume_unique`\n          has no effect when the 'table' option is used.\n        * If None, will automatically choose 'table' if\n          the required memory allocation is less than or equal to\n          6 times the sum of the sizes of `ar1` and `ar2`,\n          otherwise will use 'sort'. This is done to not use\n          a large amount of memory by default, even though\n          'table' may be faster in most cases. If 'table' is chosen,\n          `assume_unique` will have no effect.\n\n        .. versionadded:: 1.8.0\n\n    Returns\n    -------\n    in1d : (M,) ndarray, bool\n        The values `ar1[in1d]` are in `ar2`.\n\n    See Also\n    --------\n    isin                  : Version of this function that preserves the\n                            shape of ar1.\n\n    Notes\n    -----\n    `in1d` can be considered as an element-wise function version of the\n    python keyword `in`, for 1-D sequences. ``in1d(a, b)`` is roughly\n    equivalent to ``np.array([item in b for item in a])``.\n    However, this idea fails if `ar2` is a set, or similar (non-sequence)\n    container:  As ``ar2`` is converted to an array, in those cases\n    ``asarray(ar2)`` is an object array rather than the expected array of\n    contained values.\n\n    Using ``kind='table'`` tends to be faster than `kind='sort'` if the\n    following relationship is true:\n    ``log10(len(ar2)) > (log10(max(ar2)-min(ar2)) - 2.27) / 0.927``,\n    but may use greater memory. The default value for `kind` will\n    be automatically selected based only on memory usage, so one may\n    manually set ``kind='table'`` if memory constraints can be relaxed.\n\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> test = np.array([0, 1, 2, 5, 0])\n    >>> states = [0, 2]\n    >>> mask = np.in1d(test, states)\n    >>> mask\n    array([ True, False,  True, False,  True])\n    >>> test[mask]\n    array([0, 2, 0])\n    >>> mask = np.in1d(test, states, invert=True)\n    >>> mask\n    array([False,  True, False,  True, False])\n    >>> test[mask]\n    array([1, 5])\n    \"\"\"\n\n    # Deprecated in NumPy 2.0, 2023-08-18\n    warnings.warn(\n        \"`in1d` is deprecated. Use `np.isin` instead.\",\n        DeprecationWarning,\n        stacklevel=2\n    )\n\n    return _in1d(ar1, ar2, assume_unique, invert, kind=kind)"
    },
    {
      "name": "numpy.isin",
      "category": "Testing membership",
      "description": "Element-wise test for membership in another array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.isin.html",
      "doc": "Calculates ``element in test_elements``, broadcasting over `element` only.\nReturns a boolean array of the same shape as `element` that is True\nwhere an element of `element` is in `test_elements` and False otherwise.\n\nParameters\n----------\nelement : array_like\n    Input array.\ntest_elements : array_like\n    The values against which to test each value of `element`.\n    This argument is flattened if it is an array or array_like.\n    See notes for behavior with non-array-like parameters.\nassume_unique : bool, optional\n    If True, the input arrays are both assumed to be unique, which\n    can speed up the calculation.  Default is False.\ninvert : bool, optional\n    If True, the values in the returned array are inverted, as if\n    calculating `element not in test_elements`. Default is False.\n    ``np.isin(a, b, invert=True)`` is equivalent to (but faster\n    than) ``np.invert(np.isin(a, b))``.\nkind : {None, 'sort', 'table'}, optional\n    The algorithm to use. This will not affect the final result,\n    but will affect the speed and memory use. The default, None,\n    will select automatically based on memory considerations.\n\n    * If 'sort', will use a mergesort-based approach. This will have\n      a memory usage of roughly 6 times the sum of the sizes of\n      `element` and `test_elements`, not accounting for size of dtypes.\n    * If 'table', will use a lookup table approach similar\n      to a counting sort. This is only available for boolean and\n      integer arrays. This will have a memory usage of the\n      size of `element` plus the max-min value of `test_elements`.\n      `assume_unique` has no effect when the 'table' option is used.\n    * If None, will automatically choose 'table' if\n      the required memory allocation is less than or equal to\n      6 times the sum of the sizes of `element` and `test_elements`,\n      otherwise will use 'sort'. This is done to not use\n      a large amount of memory by default, even though\n      'table' may be faster in most cases. If 'table' is chosen,\n      `assume_unique` will have no effect.\n\n\nReturns\n-------\nisin : ndarray, bool\n    Has the same shape as `element`. The values `element[isin]`\n    are in `test_elements`.",
      "code": "def isin(element, test_elements, assume_unique=False, invert=False, *,\n         kind=None):\n    \"\"\"\n    Calculates ``element in test_elements``, broadcasting over `element` only.\n    Returns a boolean array of the same shape as `element` that is True\n    where an element of `element` is in `test_elements` and False otherwise.\n\n    Parameters\n    ----------\n    element : array_like\n        Input array.\n    test_elements : array_like\n        The values against which to test each value of `element`.\n        This argument is flattened if it is an array or array_like.\n        See notes for behavior with non-array-like parameters.\n    assume_unique : bool, optional\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n    invert : bool, optional\n        If True, the values in the returned array are inverted, as if\n        calculating `element not in test_elements`. Default is False.\n        ``np.isin(a, b, invert=True)`` is equivalent to (but faster\n        than) ``np.invert(np.isin(a, b))``.\n    kind : {None, 'sort', 'table'}, optional\n        The algorithm to use. This will not affect the final result,\n        but will affect the speed and memory use. The default, None,\n        will select automatically based on memory considerations.\n\n        * If 'sort', will use a mergesort-based approach. This will have\n          a memory usage of roughly 6 times the sum of the sizes of\n          `element` and `test_elements`, not accounting for size of dtypes.\n        * If 'table', will use a lookup table approach similar\n          to a counting sort. This is only available for boolean and\n          integer arrays. This will have a memory usage of the\n          size of `element` plus the max-min value of `test_elements`.\n          `assume_unique` has no effect when the 'table' option is used.\n        * If None, will automatically choose 'table' if\n          the required memory allocation is less than or equal to\n          6 times the sum of the sizes of `element` and `test_elements`,\n          otherwise will use 'sort'. This is done to not use\n          a large amount of memory by default, even though\n          'table' may be faster in most cases. If 'table' is chosen,\n          `assume_unique` will have no effect.\n\n\n    Returns\n    -------\n    isin : ndarray, bool\n        Has the same shape as `element`. The values `element[isin]`\n        are in `test_elements`.\n\n    Notes\n    -----\n\n    `isin` is an element-wise function version of the python keyword `in`.\n    ``isin(a, b)`` is roughly equivalent to\n    ``np.array([item in b for item in a])`` if `a` and `b` are 1-D sequences.\n\n    `element` and `test_elements` are converted to arrays if they are not\n    already. If `test_elements` is a set (or other non-sequence collection)\n    it will be converted to an object array with one element, rather than an\n    array of the values contained in `test_elements`. This is a consequence\n    of the `array` constructor's way of handling non-sequence collections.\n    Converting the set to a list usually gives the desired behavior.\n\n    Using ``kind='table'`` tends to be faster than `kind='sort'` if the\n    following relationship is true:\n    ``log10(len(test_elements)) >\n    (log10(max(test_elements)-min(test_elements)) - 2.27) / 0.927``,\n    but may use greater memory. The default value for `kind` will\n    be automatically selected based only on memory usage, so one may\n    manually set ``kind='table'`` if memory constraints can be relaxed.\n\n    .. versionadded:: 1.13.0\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> element = 2*np.arange(4).reshape((2, 2))\n    >>> element\n    array([[0, 2],\n           [4, 6]])\n    >>> test_elements = [1, 2, 4, 8]\n    >>> mask = np.isin(element, test_elements)\n    >>> mask\n    array([[False,  True],\n           [ True, False]])\n    >>> element[mask]\n    array([2, 4])\n\n    The indices of the matched values can be obtained with `nonzero`:\n\n    >>> np.nonzero(mask)\n    (array([0, 1]), array([1, 0]))\n\n    The test can also be inverted:\n\n    >>> mask = np.isin(element, test_elements, invert=True)\n    >>> mask\n    array([[ True, False],\n           [False,  True]])\n    >>> element[mask]\n    array([0, 6])\n\n    Because of how `array` handles sets, the following does not\n    work as expected:\n\n    >>> test_set = {1, 2, 4, 8}\n    >>> np.isin(element, test_set)\n    array([[False, False],\n           [False, False]])\n\n    Casting the set to a list gives the expected result:\n\n    >>> np.isin(element, list(test_set))\n    array([[False,  True],\n           [ True, False]])\n    \"\"\"\n    element = np.asarray(element)\n    return _in1d(element, test_elements, assume_unique=assume_unique,\n                 invert=invert, kind=kind).reshape(element.shape)"
    },
    {
      "name": "numpy.intersect1d",
      "category": "Set operations",
      "description": "Find the intersection of two arrays",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.intersect1d.html",
      "doc": "Find the intersection of two arrays.\n\nReturn the sorted, unique values that are in both of the input arrays.\n\nParameters\n----------\nar1, ar2 : array_like\n    Input arrays. Will be flattened if not already 1D.\nassume_unique : bool\n    If True, the input arrays are both assumed to be unique, which\n    can speed up the calculation.  If True but ``ar1`` or ``ar2`` are not\n    unique, incorrect results and out-of-bounds indices could result.\n    Default is False.\nreturn_indices : bool\n    If True, the indices which correspond to the intersection of the two\n    arrays are returned. The first instance of a value is used if there are\n    multiple. Default is False.\n\n    .. versionadded:: 1.15.0\n\nReturns\n-------\nintersect1d : ndarray\n    Sorted 1D array of common and unique elements.\ncomm1 : ndarray\n    The indices of the first occurrences of the common values in `ar1`.\n    Only provided if `return_indices` is True.\ncomm2 : ndarray\n    The indices of the first occurrences of the common values in `ar2`.\n    Only provided if `return_indices` is True.",
      "code": "def intersect1d(ar1, ar2, assume_unique=False, return_indices=False):\n    \"\"\"\n    Find the intersection of two arrays.\n\n    Return the sorted, unique values that are in both of the input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays. Will be flattened if not already 1D.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  If True but ``ar1`` or ``ar2`` are not\n        unique, incorrect results and out-of-bounds indices could result.\n        Default is False.\n    return_indices : bool\n        If True, the indices which correspond to the intersection of the two\n        arrays are returned. The first instance of a value is used if there are\n        multiple. Default is False.\n\n        .. versionadded:: 1.15.0\n\n    Returns\n    -------\n    intersect1d : ndarray\n        Sorted 1D array of common and unique elements.\n    comm1 : ndarray\n        The indices of the first occurrences of the common values in `ar1`.\n        Only provided if `return_indices` is True.\n    comm2 : ndarray\n        The indices of the first occurrences of the common values in `ar2`.\n        Only provided if `return_indices` is True.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])\n    array([1, 3])\n\n    To intersect more than two arrays, use functools.reduce:\n\n    >>> from functools import reduce\n    >>> reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))\n    array([3])\n\n    To return the indices of the values common to the input arrays\n    along with the intersected values:\n\n    >>> x = np.array([1, 1, 2, 3, 4])\n    >>> y = np.array([2, 1, 4, 6])\n    >>> xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)\n    >>> x_ind, y_ind\n    (array([0, 2, 4]), array([1, 0, 2]))\n    >>> xy, x[x_ind], y[y_ind]\n    (array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))\n\n    \"\"\"\n    ar1 = np.asanyarray(ar1)\n    ar2 = np.asanyarray(ar2)\n\n    if not assume_unique:\n        if return_indices:\n            ar1, ind1 = unique(ar1, return_index=True)\n            ar2, ind2 = unique(ar2, return_index=True)\n        else:\n            ar1 = unique(ar1)\n            ar2 = unique(ar2)\n    else:\n        ar1 = ar1.ravel()\n        ar2 = ar2.ravel()\n\n    aux = np.concatenate((ar1, ar2))\n    if return_indices:\n        aux_sort_indices = np.argsort(aux, kind='mergesort')\n        aux = aux[aux_sort_indices]\n    else:\n        aux.sort()\n\n    mask = aux[1:] == aux[:-1]\n    int1d = aux[:-1][mask]\n\n    if return_indices:\n        ar1_indices = aux_sort_indices[:-1][mask]\n        ar2_indices = aux_sort_indices[1:][mask] - ar1.size\n        if not assume_unique:\n            ar1_indices = ind1[ar1_indices]\n            ar2_indices = ind2[ar2_indices]\n\n        return int1d, ar1_indices, ar2_indices\n    else:\n        return int1d"
    },
    {
      "name": "numpy.union1d",
      "category": "Set operations",
      "description": "Find the union of two arrays",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.union1d.html",
      "doc": "Find the union of two arrays.\n\nReturn the unique, sorted array of values that are in either of the two\ninput arrays.\n\nParameters\n----------\nar1, ar2 : array_like\n    Input arrays. They are flattened if they are not already 1D.\n\nReturns\n-------\nunion1d : ndarray\n    Unique, sorted union of the input arrays.",
      "code": "def union1d(ar1, ar2):\n    \"\"\"\n    Find the union of two arrays.\n\n    Return the unique, sorted array of values that are in either of the two\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays. They are flattened if they are not already 1D.\n\n    Returns\n    -------\n    union1d : ndarray\n        Unique, sorted union of the input arrays.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.union1d([-1, 0, 1], [-2, 0, 2])\n    array([-2, -1,  0,  1,  2])\n\n    To find the union of more than two arrays, use functools.reduce:\n\n    >>> from functools import reduce\n    >>> reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))\n    array([1, 2, 3, 4, 6])\n    \"\"\"\n    return unique(np.concatenate((ar1, ar2), axis=None))"
    },
    {
      "name": "numpy.setdiff1d",
      "category": "Set operations",
      "description": "Find the set difference of two arrays",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.setdiff1d.html",
      "doc": "Find the set difference of two arrays.\n\nReturn the unique values in `ar1` that are not in `ar2`.\n\nParameters\n----------\nar1 : array_like\n    Input array.\nar2 : array_like\n    Input comparison array.\nassume_unique : bool\n    If True, the input arrays are both assumed to be unique, which\n    can speed up the calculation.  Default is False.\n\nReturns\n-------\nsetdiff1d : ndarray\n    1D array of values in `ar1` that are not in `ar2`. The result\n    is sorted when `assume_unique=False`, but otherwise only sorted\n    if the input is sorted.",
      "code": "def setdiff1d(ar1, ar2, assume_unique=False):\n    \"\"\"\n    Find the set difference of two arrays.\n\n    Return the unique values in `ar1` that are not in `ar2`.\n\n    Parameters\n    ----------\n    ar1 : array_like\n        Input array.\n    ar2 : array_like\n        Input comparison array.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    setdiff1d : ndarray\n        1D array of values in `ar1` that are not in `ar2`. The result\n        is sorted when `assume_unique=False`, but otherwise only sorted\n        if the input is sorted.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([1, 2, 3, 2, 4, 1])\n    >>> b = np.array([3, 4, 5, 6])\n    >>> np.setdiff1d(a, b)\n    array([1, 2])\n\n    \"\"\"\n    if assume_unique:\n        ar1 = np.asarray(ar1).ravel()\n    else:\n        ar1 = unique(ar1)\n        ar2 = unique(ar2)\n    return ar1[_in1d(ar1, ar2, assume_unique=True, invert=True)]"
    },
    {
      "name": "numpy.setxor1d",
      "category": "Set operations",
      "description": "Find the set exclusive-or of two arrays",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.setxor1d.html",
      "doc": "Find the set exclusive-or of two arrays.\n\nReturn the sorted, unique values that are in only one (not both) of the\ninput arrays.\n\nParameters\n----------\nar1, ar2 : array_like\n    Input arrays.\nassume_unique : bool\n    If True, the input arrays are both assumed to be unique, which\n    can speed up the calculation. Default is False.\n\nReturns\n-------\nsetxor1d : ndarray\n    Sorted 1D array of unique values that are in only one of the input\n    arrays.",
      "code": "def setxor1d(ar1, ar2, assume_unique=False):\n    \"\"\"\n    Find the set exclusive-or of two arrays.\n\n    Return the sorted, unique values that are in only one (not both) of the\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation. Default is False.\n\n    Returns\n    -------\n    setxor1d : ndarray\n        Sorted 1D array of unique values that are in only one of the input\n        arrays.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([1, 2, 3, 2, 4])\n    >>> b = np.array([2, 3, 5, 7, 5])\n    >>> np.setxor1d(a,b)\n    array([1, 4, 5, 7])\n\n    \"\"\"\n    if not assume_unique:\n        ar1 = unique(ar1)\n        ar2 = unique(ar2)\n\n    aux = np.concatenate((ar1, ar2), axis=None)\n    if aux.size == 0:\n        return aux\n\n    aux.sort()\n    flag = np.concatenate(([True], aux[1:] != aux[:-1], [True]))\n    return aux[flag[1:] & flag[:-1]]"
    }
  ]
}