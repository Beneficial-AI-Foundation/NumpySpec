{
  "metadata": {
    "module": "numpy.testing",
    "source": "https://github.com/numpy/numpy/blob/main/numpy/testing/_private/utils.py",
    "description": "NumPy testing utilities module - provides assertion functions, decorators, and utilities for testing NumPy code and array computations"
  },
  "functions": [
    {
      "name": "numpy.testing.assert_equal",
      "category": "Assertion Functions",
      "description": "Raises an AssertionError if two objects are not equal",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_equal.html",
      "doc": "Raises an AssertionError if two objects are not equal.\n\nGiven two objects (scalars, lists, tuples, dictionaries or numpy arrays), check that all elements of these objects are equal. An exception is raised at the first conflicting values.\n\nThis function handles NaN comparisons as if NaN was a \"normal\" number. That is, AssertionError is not raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.",
      "code": "def assert_equal(actual, desired, err_msg='', verbose=True, *, strict=False):\n    \"\"\"\n    Raises an AssertionError if two objects are not equal.\n\n    Given two objects (scalars, lists, tuples, dictionaries or numpy arrays),\n    check that all elements of these objects are equal. An exception is raised\n    at the first conflicting values.\n\n    This function handles NaN comparisons as if NaN was a \"normal\" number.\n    That is, AssertionError is not raised if both objects have NaNs in the same\n    positions.  This is in contrast to the IEEE standard on NaNs, which says\n    that NaN compared to anything must return False.\n\n    Parameters\n    ----------\n    actual : array_like\n        The object to check.\n    desired : array_like\n        The expected object.\n    err_msg : str, optional\n        The error message to be printed in case of failure.\n    verbose : bool, optional\n        If True, the conflicting values are appended to the error message.\n    strict : bool, optional\n        If True and either of the `actual` and `desired` arguments is an array,\n        raise an ``AssertionError`` when either the shape or the data type of\n        the arguments does not match. If neither argument is an array, this\n        parameter has no effect.\n\n        .. versionadded:: 2.0.0\n\n    Raises\n    ------\n    AssertionError\n        If actual and desired are not equal.\n\n    See Also\n    --------\n    assert_allclose\n    assert_array_almost_equal_nulp,\n    assert_array_max_ulp,\n\n    Notes\n    -----\n    When one of `actual` and `desired` is a scalar and the other is array_like, the\n    function checks that each element of the array_like is equal to the scalar.\n    Note that empty arrays are therefore considered equal to scalars.\n    This behaviour can be disabled by setting ``strict==True``.\n\n    Examples\n    --------\n    >>> np.testing.assert_equal([4, 5], [4, 6])\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Items are not equal:\n    item=1\n     ACTUAL: 5\n     DESIRED: 6\n\n    The following comparison does not raise an exception.  There are NaNs\n    in the inputs, but they are in the same positions.\n\n    >>> np.testing.assert_equal(np.array([1.0, 2.0, np.nan]), [1, 2, np.nan])\n\n    As mentioned in the Notes section, `assert_equal` has special\n    handling for scalars when one of the arguments is an array.\n    Here, the test checks that each value in `x` is 3:\n\n    >>> x = np.full((2, 5), fill_value=3)\n    >>> np.testing.assert_equal(x, 3)\n\n    Use `strict` to raise an AssertionError when comparing a scalar with an\n    array of a different shape:\n\n    >>> np.testing.assert_equal(x, 3, strict=True)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not equal\n    <BLANKLINE>\n    (shapes (2, 5), () mismatch)\n     ACTUAL: array([[3, 3, 3, 3, 3],\n           [3, 3, 3, 3, 3]])\n     DESIRED: array(3)\n\n    The `strict` parameter also ensures that the array data types match:\n\n    >>> x = np.array([2, 2, 2])\n    >>> y = np.array([2., 2., 2.], dtype=np.float32)\n    >>> np.testing.assert_equal(x, y, strict=True)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not equal\n    <BLANKLINE>\n    (dtypes int64, float32 mismatch)\n     ACTUAL: array([2, 2, 2])\n     DESIRED: array([2., 2., 2.], dtype=float32)\n    \"\"\"\n    __tracebackhide__ = True  # Hide traceback for py.test\n    if isinstance(desired, dict):\n        if not isinstance(actual, dict):\n            raise AssertionError(repr(type(actual)))\n        assert_equal(len(actual), len(desired), err_msg, verbose)\n        for k, i in desired.items():\n            if k not in actual:\n                raise AssertionError(repr(k))\n            assert_equal(actual[k], desired[k], f'key={k!r}\\n{err_msg}',\n                         verbose)\n        return\n    if isinstance(desired, (list, tuple)) and isinstance(actual, (list, tuple)):\n        assert_equal(len(actual), len(desired), err_msg, verbose)\n        for k in range(len(desired)):\n            assert_equal(actual[k], desired[k], f'item={k!r}\\n{err_msg}',\n                         verbose)\n        return\n    from numpy import imag, iscomplexobj, real\n    from numpy._core import isscalar, ndarray, signbit\n    if isinstance(actual, ndarray) or isinstance(desired, ndarray):\n        return assert_array_equal(actual, desired, err_msg, verbose,\n                                  strict=strict)\n    msg = build_err_msg([actual, desired], err_msg, verbose=verbose)\n\n    # Handle complex numbers: separate into real/imag to handle\n    # nan/inf/negative zero correctly\n    # XXX: catch ValueError for subclasses of ndarray where iscomplex fail\n    try:\n        usecomplex = iscomplexobj(actual) or iscomplexobj(desired)\n    except (ValueError, TypeError):\n        usecomplex = False\n\n    if usecomplex:\n        if iscomplexobj(actual):\n            actualr = real(actual)\n            actuali = imag(actual)\n        else:\n            actualr = actual\n            actuali = 0\n        if iscomplexobj(desired):\n            desiredr = real(desired)\n            desiredi = imag(desired)\n        else:\n            desiredr = desired\n            desiredi = 0\n        try:\n            assert_equal(actualr, desiredr)\n            assert_equal(actuali, desiredi)\n        except AssertionError:\n            raise AssertionError(msg)\n\n    # isscalar test to check cases such as [np.nan] != np.nan\n    if isscalar(desired) != isscalar(actual):\n        raise AssertionError(msg)\n\n    try:\n        isdesnat = isnat(desired)\n        isactnat = isnat(actual)\n        dtypes_match = (np.asarray(desired).dtype.type ==\n                        np.asarray(actual).dtype.type)\n        if isdesnat and isactnat:\n            # If both are NaT (and have the same dtype -- datetime or\n            # timedelta) they are considered equal.\n            if dtypes_match:\n                return\n            else:\n                raise AssertionError(msg)\n\n    except (TypeError, ValueError, NotImplementedError):\n        pass\n\n    # Inf/nan/negative zero handling\n    try:\n        isdesnan = isnan(desired)\n        isactnan = isnan(actual)\n        if isdesnan and isactnan:\n            return  # both nan, so equal\n\n        # handle signed zero specially for floats\n        array_actual = np.asarray(actual)\n        array_desired = np.asarray(desired)\n        if (array_actual.dtype.char in 'Mm' or\n                array_desired.dtype.char in 'Mm'):\n            # version 1.18\n            # until this version, isnan failed for datetime64 and timedelta64.\n            # Now it succeeds but comparison to scalar with a different type\n            # emits a DeprecationWarning.\n            # Avoid that by skipping the next check\n            raise NotImplementedError('cannot compare to a scalar '\n                                      'with a different type')\n\n        if desired == 0 and actual == 0:\n            if not signbit(desired) == signbit(actual):\n                raise AssertionError(msg)\n\n    except (TypeError, ValueError, NotImplementedError):\n        pass\n\n    try:\n        # Explicitly use __eq__ for comparison, gh-2552\n        if not (desired == actual):\n            raise AssertionError(msg)\n\n    except (DeprecationWarning, FutureWarning) as e:\n        # this handles the case when the two types are not even comparable\n        if 'elementwise == comparison' in e.args[0]:\n            raise AssertionError(msg)\n        else:\n            raise"
    },
    {
      "name": "numpy.testing.assert_allclose",
      "category": "Assertion Functions",
      "description": "Raises an AssertionError if two objects are not equal up to desired tolerance",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_allclose.html", 
      "doc": "Raises an AssertionError if two objects are not equal up to desired tolerance.\n\nGiven two array_like objects, check that their shapes and all elements are equal (but see the Notes for the special handling of a scalar). An exception is raised if the shapes mismatch or any values conflict. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.\n\nThe test is equivalent to ``allclose(actual, desired, rtol, atol)`` (note that ``allclose`` has different default values). It compares the difference between `actual` and `desired` to ``atol + rtol * abs(desired)``.",
      "code": "def assert_allclose(actual, desired, rtol=1e-7, atol=0, equal_nan=True,\n                    err_msg='', verbose=True, *, strict=False):\n    \"\"\"\n    Raises an AssertionError if two objects are not equal up to desired\n    tolerance.\n\n    Given two array_like objects, check that their shapes and all elements\n    are equal (but see the Notes for the special handling of a scalar). An\n    exception is raised if the shapes mismatch or any values conflict. In\n    contrast to the standard usage in numpy, NaNs are compared like numbers,\n    no assertion is raised if both objects have NaNs in the same positions.\n\n    The test is equivalent to ``allclose(actual, desired, rtol, atol)`` (note\n    that ``allclose`` has different default values). It compares the difference\n    between `actual` and `desired` to ``atol + rtol * abs(desired)``.\n\n    Parameters\n    ----------\n    actual : array_like\n        Array obtained.\n    desired : array_like\n        Array desired.\n    rtol : float, optional\n        Relative tolerance.\n    atol : float, optional\n        Absolute tolerance.\n    equal_nan : bool, optional.\n        If True, NaNs will compare equal.\n    err_msg : str, optional\n        The error message to be printed in case of failure.\n    verbose : bool, optional\n        If True, the conflicting values are appended to the error message.\n    strict : bool, optional\n        If True, raise an ``AssertionError`` when either the shape or the data\n        type of the arguments does not match. The special handling of scalars\n        mentioned in the Notes section is disabled.\n\n        .. versionadded:: 2.0.0\n\n    Raises\n    ------\n    AssertionError\n        If actual and desired are not equal up to specified precision.\n\n    See Also\n    --------\n    assert_array_almost_equal_nulp, assert_array_max_ulp\n\n    Notes\n    -----\n    When one of `actual` and `desired` is a scalar and the other is array_like, the\n    function performs the comparison as if the scalar were broadcasted to the shape\n    of the array. Note that empty arrays are therefore considered equal to scalars.\n    This behaviour can be disabled by setting ``strict==True``.\n\n    Examples\n    --------\n    >>> x = [1e-5, 1e-3, 1e-1]\n    >>> y = np.arccos(np.cos(x))\n    >>> np.testing.assert_allclose(x, y, rtol=1e-5, atol=0)\n\n    As mentioned in the Notes section, `assert_allclose` has special\n    handling for scalars. Here, the test checks that the value of `numpy.sin`\n    is nearly zero at integer multiples of π.\n\n    >>> x = np.arange(3) * np.pi\n    >>> np.testing.assert_allclose(np.sin(x), 0, atol=1e-15)\n\n    Use `strict` to raise an ``AssertionError`` when comparing an array\n    with one or more dimensions against a scalar.\n\n    >>> np.testing.assert_allclose(np.sin(x), 0, atol=1e-15, strict=True)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Not equal to tolerance rtol=1e-07, atol=1e-15\n    <BLANKLINE>\n    (shapes (3,), () mismatch)\n     ACTUAL: array([ 0.000000e+00,  1.224647e-16, -2.449294e-16])\n     DESIRED: array(0)\n\n    The `strict` parameter also ensures that the array data types match:\n\n    >>> y = np.zeros(3, dtype=np.float32)\n    >>> np.testing.assert_allclose(np.sin(x), y, atol=1e-15, strict=True)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Not equal to tolerance rtol=1e-07, atol=1e-15\n    <BLANKLINE>\n    (dtypes float64, float32 mismatch)\n     ACTUAL: array([ 0.000000e+00,  1.224647e-16, -2.449294e-16])\n     DESIRED: array([0., 0., 0.], dtype=float32)\n\n    \"\"\"\n    __tracebackhide__ = True  # Hide traceback for py.test\n    import numpy as np\n\n    def compare(x, y):\n        return np._core.numeric.isclose(x, y, rtol=rtol, atol=atol,\n                                       equal_nan=equal_nan)\n\n    actual, desired = np.asanyarray(actual), np.asanyarray(desired)\n    header = f'Not equal to tolerance rtol={rtol:g}, atol={atol:g}'\n    assert_array_compare(compare, actual, desired, err_msg=str(err_msg),\n                         verbose=verbose, header=header, equal_nan=equal_nan,\n                         strict=strict)"
    },
    {
      "name": "numpy.testing.assert_array_equal",
      "category": "Assertion Functions",
      "description": "Raises an AssertionError if two array_like objects are not equal",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_array_equal.html",
      "doc": "Raises an AssertionError if two array_like objects are not equal.\n\nGiven two array_like objects, check that the shape is equal and all elements of these objects are equal (but see the Notes for the special handling of a scalar). An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.\n\nThe usual caution for verifying equality with floating point numbers is advised.",
      "code": "def assert_array_equal(actual, desired, err_msg='', verbose=True, *,\n                       strict=False):\n    \"\"\"\n    Raises an AssertionError if two array_like objects are not equal.\n\n    Given two array_like objects, check that the shape is equal and all\n    elements of these objects are equal (but see the Notes for the special\n    handling of a scalar). An exception is raised at shape mismatch or\n    conflicting values. In contrast to the standard usage in numpy, NaNs\n    are compared like numbers, no assertion is raised if both objects have\n    NaNs in the same positions.\n\n    The usual caution for verifying equality with floating point numbers is\n    advised.\n\n    .. note:: When either `actual` or `desired` is already an instance of\n        `numpy.ndarray` and `desired` is not a ``dict``, the behavior of\n        ``assert_equal(actual, desired)`` is identical to the behavior of this\n        function. Otherwise, this function performs `np.asanyarray` on the\n        inputs before comparison, whereas `assert_equal` defines special\n        comparison rules for common Python types. For example, only\n        `assert_equal` can be used to compare nested Python lists. In new code,\n        consider using only `assert_equal`, explicitly converting either\n        `actual` or `desired` to arrays if the behavior of `assert_array_equal`\n        is desired.\n\n    Parameters\n    ----------\n    actual : array_like\n        The actual object to check.\n    desired : array_like\n        The desired, expected object.\n    err_msg : str, optional\n        The error message to be printed in case of failure.\n    verbose : bool, optional\n        If True, the conflicting values are appended to the error message.\n    strict : bool, optional\n        If True, raise an AssertionError when either the shape or the data\n        type of the array_like objects does not match. The special\n        handling for scalars mentioned in the Notes section is disabled.\n\n        .. versionadded:: 1.24.0\n\n    Raises\n    ------\n    AssertionError\n        If actual and desired objects are not equal.\n\n    See Also\n    --------\n    assert_allclose: Compare two array_like objects for equality with desired\n                     relative and/or absolute precision.\n    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal\n\n    Notes\n    -----\n    When one of `actual` and `desired` is a scalar and the other is array_like, the\n    function checks that each element of the array_like is equal to the scalar.\n    Note that empty arrays are therefore considered equal to scalars.\n    This behaviour can be disabled by setting ``strict==True``.\n\n    Examples\n    --------\n    The first assert does not raise an exception:\n\n    >>> np.testing.assert_array_equal([1.0,2.33333,np.nan],\n    ...                               [np.exp(0),2.33333, np.nan])\n\n    Assert fails with numerical imprecision with floats:\n\n    >>> np.testing.assert_array_equal([1.0,np.pi,np.nan],\n    ...                               [1, np.sqrt(np.pi)**2, np.nan])\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not equal\n    <BLANKLINE>\n    Mismatched elements: 1 / 3 (33.3%)\n    Max absolute difference among violations: 4.4408921e-16\n    Max relative difference among violations: 1.41357986e-16\n     ACTUAL: array([1.      , 3.141593,      nan])\n     DESIRED: array([1.      , 3.141593,      nan])\n\n    Use `assert_allclose` or one of the nulp (number of floating point values)\n    functions for these cases instead:\n\n    >>> np.testing.assert_allclose([1.0,np.pi,np.nan],\n    ...                            [1, np.sqrt(np.pi)**2, np.nan],\n    ...                            rtol=1e-10, atol=0)\n\n    As mentioned in the Notes section, `assert_array_equal` has special\n    handling for scalars. Here the test checks that each value in `x` is 3:\n\n    >>> x = np.full((2, 5), fill_value=3)\n    >>> np.testing.assert_array_equal(x, 3)\n\n    Use `strict` to raise an AssertionError when comparing a scalar with an\n    array:\n\n    >>> np.testing.assert_array_equal(x, 3, strict=True)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not equal\n    <BLANKLINE>\n    (shapes (2, 5), () mismatch)\n     ACTUAL: array([[3, 3, 3, 3, 3],\n           [3, 3, 3, 3, 3]])\n     DESIRED: array(3)\n\n    The `strict` parameter also ensures that the array data types match:\n\n    >>> x = np.array([2, 2, 2])\n    >>> y = np.array([2., 2., 2.], dtype=np.float32)\n    >>> np.testing.assert_array_equal(x, y, strict=True)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not equal\n    <BLANKLINE>\n    (dtypes int64, float32 mismatch)\n     ACTUAL: array([2, 2, 2])\n     DESIRED: array([2., 2., 2.], dtype=float32)\n    \"\"\"\n    __tracebackhide__ = True  # Hide traceback for py.test\n    assert_array_compare(operator.__eq__, actual, desired, err_msg=err_msg,\n                         verbose=verbose, header='Arrays are not equal',\n                         strict=strict)"
    },
    {
      "name": "numpy.testing.assert_array_almost_equal",
      "category": "Assertion Functions", 
      "description": "Raises an AssertionError if two objects are not equal up to desired precision",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_array_almost_equal.html",
      "doc": "Raises an AssertionError if two objects are not equal up to desired precision.\n\nThe test verifies identical shapes and that the elements of ``actual`` and ``desired`` satisfy ``abs(desired-actual) < 1.5 * 10**(-decimal)``.\n\nThe equality of NaN values is checked. If the dtype of the arrays is float32, then the threshold for the absolute difference is 1e-5.\n\nException is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.",
      "code": "def assert_array_almost_equal(actual, desired, decimal=6, err_msg='',\n                              verbose=True):\n    \"\"\"\n    Raises an AssertionError if two objects are not equal up to desired\n    precision.\n\n    The test verifies identical shapes and that the elements of ``actual``\n    and ``desired`` satisfy ``abs(desired-actual) < 1.5 * 10**(-decimal)``.\n\n    The equality of NaN values is checked.  If the dtype of the arrays is\n    float32, then the threshold for the absolute difference is 1e-5.\n\n    Exception is raised at shape mismatch or conflicting values. In contrast\n    to the standard usage in numpy, NaNs are compared like numbers, no\n    assertion is raised if both objects have NaNs in the same positions.\n\n    Parameters\n    ----------\n    actual : array_like\n        The actual object to check.\n    desired : array_like\n        The desired, expected object.\n    decimal : int, optional\n        Desired precision, default is 6.\n    err_msg : str, optional\n        The error message to be printed in case of failure.\n    verbose : bool, optional\n        If True, the conflicting values are appended to the error message.\n\n    Raises\n    ------\n    AssertionError\n        If actual and desired are not equal up to specified precision.\n\n    See Also\n    --------\n    assert_allclose: Compare two array_like objects for equality with desired\n                     relative and/or absolute precision.\n    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal\n\n    Examples\n    --------\n    the first assert does not raise an exception\n\n    >>> np.testing.assert_array_almost_equal([1.0,2.333,np.nan],\n    ...                                      [1.0,2.333,np.nan])\n\n    >>> np.testing.assert_array_almost_equal([1.0,2.33333,np.nan],\n    ...                                      [1.0,2.33339,np.nan], decimal=5)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not almost equal to 5 decimals\n    <BLANKLINE>\n    Mismatched elements: 1 / 3 (33.3%)\n    Max absolute difference among violations: 6.e-05\n    Max relative difference among violations: 2.57136612e-05\n     ACTUAL: array([1.     , 2.33333,     nan])\n     DESIRED: array([1.     , 2.33339,     nan])\n\n    >>> np.testing.assert_array_almost_equal([1.0,2.33333,np.nan],\n    ...                                      [1.0,2.33333, 5], decimal=5)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not almost equal to 5 decimals\n    <BLANKLINE>\n    NaN location mismatch:\n     ACTUAL: array([1.     , 2.33333,     nan])\n     DESIRED: array([1.     , 2.33333, 5.     ])\n\n    \"\"\"\n    __tracebackhide__ = True  # Hide traceback for py.test\n    from numpy import number, float_, result_type\n    def compare(x, y):\n        try:\n            if np.issubdtype(x.dtype, number) and np.issubdtype(y.dtype, number):\n                if hasattr(y, 'dtype'):\n                    dtype = result_type(x, y)\n                else:\n                    dtype = x.dtype\n                if np.issubdtype(dtype, float_):\n                    dtype = np.dtype(float_)\n                x_isnan, y_isnan = isnan(x), isnan(y)\n                x_isinf, y_isinf = isinf(x), isinf(y)\n                \n                # Remove NaN (and inf) unless both are NaN (or inf) at the same\n                # locations.\n                x_id_nan_inf = x_isnan | x_isinf\n                y_id_nan_inf = y_isnan | y_isinf\n                # Only do the removal if NaN (or inf) is present (expensive for\n                # large arrays).\n                if np.any(x_id_nan_inf) or np.any(y_id_nan_inf):\n                    # NaN and inf are considered \"equal\"\n                    if not (x_id_nan_inf == y_id_nan_inf).all():\n                        return False\n                    val = np.empty_like(x, dtype=dtype).flat\n                    val[:] = [0 if x_id_nan_inf[i]\n                              else x[i] for i in ndindex(x.shape)]\n                    x = val\n                    val = np.empty_like(y, dtype=dtype).flat\n                    val[:] = [0 if y_id_nan_inf[i]\n                              else y[i] for i in ndindex(y.shape)]\n                    y = val\n            # Check that inexact dtypes are not mixed with exact dtypes\n            elif (np.issubdtype(x.dtype, np.inexact) != \n                  np.issubdtype(y.dtype, np.inexact)):\n                return False\n        except (ValueError, TypeError):\n            return False\n        # Divide by 2 to avoid overflow issues with uint8\n        if decimal >= 1:\n            if np.issubdtype(y.dtype, np.integer):\n                return (np.abs(x.astype(float_) - y.astype(float_)) <\n                        0.5 * 10.0**(-decimal)).all()\n            else:\n                return (np.abs(x - y) < 1.5 * 10.0**(-decimal)).all()\n        else:\n            return (np.abs(x - y) < 10.0**(-decimal)).all()\n    assert_array_compare(compare, actual, desired, err_msg=err_msg,\n                         verbose=verbose,\n                         header=('Arrays are not almost equal to %d decimals' %\n                                 decimal), precision=decimal)"
    },
    {
      "name": "numpy.testing.assert_array_less",
      "category": "Assertion Functions",
      "description": "Raises an AssertionError if two array_like objects are not ordered by less than",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_array_less.html",
      "doc": "Raises an AssertionError if two array_like objects are not ordered by less than.\n\nGiven two array_like objects, check that the shape is equal and all elements of the first object are strictly less than those of the second object. An exception is raised at shape mismatch or when values are incorrectly ordered. Shape mismatch does not raise if an object has zero dimension.\n\nIn contrast to the standard usage in numpy, NaNs are compared, no assertion is raised if both objects have NaNs in the same positions.",
      "code": "def assert_array_less(x, y, err_msg='', verbose=True, *, strict=False):\n    \"\"\"\n    Raises an AssertionError if two array_like objects are not ordered by less\n    than.\n\n    Given two array_like objects, check that the shape is equal and all\n    elements of the first object are less than those of the second object.\n    An exception is raised at shape mismatch or incorrectly ordered values.\n    Shape mismatch does not raise if an object has zero dimension. In contrast\n    to the standard usage in numpy, NaNs are compared, no assertion is raised\n    if both objects have NaNs in the same positions.\n\n    Parameters\n    ----------\n    x : array_like\n      The smaller object to check.\n    y : array_like\n      The larger object to compare.\n    err_msg : str, optional\n        The error message to be printed in case of failure.\n    verbose : bool, optional\n        If True, the conflicting values are appended to the error message.\n    strict : bool, optional\n        If True, raise an AssertionError when the shape of ``x`` and ``y``\n        don't match (in addition to the case when ``x`` is not less than\n        ``y`` elementwise). Otherwise, this function will perform\n        comparison on all pairs of elements that can be\n        broadcast from ``x`` and ``y``.\n\n        .. versionadded:: 2.0.0\n\n    Raises\n    ------\n    AssertionError\n        If x is not strictly smaller than y, element-wise.\n\n    See Also\n    --------\n    assert_array_equal: tests objects for equality\n    assert_array_almost_equal: test objects for equality up to precision\n\n    Examples\n    --------\n    >>> np.testing.assert_array_less([1.0, 1.0, np.nan], [1.1, 2.0, np.nan])\n    >>> np.testing.assert_array_less([1.0, 1.0, np.nan], [1, 2.0, np.nan])\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not less-ordered\n    <BLANKLINE>\n    Mismatched elements: 1 / 3 (33.3%)\n    Max absolute difference among violations: 1.\n    Max relative difference among violations: 0.5\n     ACTUAL: array([ 1.,  1., nan])\n     DESIRED: array([ 1.,  2., nan])\n\n    >>> np.testing.assert_array_less([1.0, 4.0], 3)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not less-ordered\n    <BLANKLINE>\n    Mismatched elements: 1 / 2 (50%)\n    Max absolute difference among violations: 1.\n    Max relative difference among violations: 0.33333333\n     ACTUAL: array([1., 4.])\n     DESIRED: array(3)\n\n    >>> np.testing.assert_array_less([1.0, 2.0, 3.0], [4])\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not less-ordered\n    <BLANKLINE>\n    (shapes (3,), (1,) mismatch)\n     ACTUAL: array([1., 2., 3.])\n     DESIRED: array([4])\n\n    When ``strict`` is True, the ``x`` and ``y`` arrays must have the same\n    shape:\n\n    >>> np.testing.assert_array_less([1.0, 2.0, 3.0], [4], strict=True)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not less-ordered\n    <BLANKLINE>\n    (shapes (3,), (1,) mismatch)\n     ACTUAL: array([1., 2., 3.])\n     DESIRED: array([4])\n\n    The ``strict`` parameter also ensures that the array data types match:\n\n    >>> x = np.array([1, 2, 3])\n    >>> y = np.array([1., 2., 3.])\n    >>> np.testing.assert_array_less(x, y, strict=True)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not less-ordered\n    <BLANKLINE>\n    (dtypes int64, float64 mismatch)\n     ACTUAL: array([1, 2, 3])\n     DESIRED: array([1., 2., 3.])\n\n    \"\"\"\n    __tracebackhide__ = True  # Hide traceback for py.test\n    assert_array_compare(operator.__lt__, x, y, err_msg=err_msg,\n                         verbose=verbose,\n                         header='Arrays are not less-ordered',\n                         equal_inf=False, strict=strict)"
    },
    {
      "name": "numpy.testing.assert_string_equal",
      "category": "Assertion Functions",
      "description": "Test if two strings are equal",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_string_equal.html",
      "doc": "Test if two strings are equal.\n\nIf the given strings are equal, `assert_string_equal` does nothing. If they are not equal, an AssertionError is raised, and the diff between the strings is shown.",
      "code": "def assert_string_equal(actual, desired):\n    \"\"\"\n    Test if two strings are equal.\n\n    If the given strings are equal, `assert_string_equal` does nothing.\n    If they are not equal, an AssertionError is raised, and the diff\n    between the strings is shown.\n\n    Parameters\n    ----------\n    actual : str\n        The string to test for equality against the expected string.\n    desired : str\n        The expected string.\n\n    Examples\n    --------\n    >>> np.testing.assert_string_equal('abc', 'abc')\n    >>> np.testing.assert_string_equal('abc', 'abcd')\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    ...\n    AssertionError: Differences in strings:\n    - abc+ abcd?    +\n\n    \"\"\"\n    # delay import of difflib to reduce startup time\n    __tracebackhide__ = True  # Hide traceback for py.test\n    import difflib\n\n    if not isinstance(actual, str):\n        raise AssertionError(repr(type(actual)))\n    if not isinstance(desired, str):\n        raise AssertionError(repr(type(desired)))\n    if desired == actual:\n        return\n\n    diff = list(difflib.Differ().compare(actual.splitlines(True),\n                                         desired.splitlines(True)))\n    diff_list = []\n    while diff:\n        d1 = diff.pop(0)\n        if d1.startswith('  '):\n            continue\n        if d1.startswith('- '):\n            l = [d1]\n            d2 = diff.pop(0)\n            if d2.startswith('? '):\n                l.append(d2)\n                d3 = diff.pop(0)\n                if d3.startswith('+ '):\n                    l.append(d3)\n                    d4 = diff.pop(0)\n                    if d4.startswith('? '):\n                        l.append(d4)\n                    else:\n                        diff.insert(0, d4)\n                else:\n                    diff.insert(0, d3)\n            else:\n                diff.insert(0, d2)\n            diff_list.extend(l)\n        if d1.startswith('+ '):\n            diff_list.append(d1)\n            d2 = diff.pop(0)\n            if d2.startswith('? '):\n                diff_list.append(d2)\n            else:\n                diff.insert(0, d2)\n    if not diff_list:\n        return\n    msg = f\"Differences in strings:\\n{''.join(diff_list).rstrip()}\"\n    raise AssertionError(msg)"
    },
    {
      "name": "numpy.testing.assert_approx_equal",
      "category": "Assertion Functions",
      "description": "Raises an AssertionError if two items are not approximately equal to specified significant figures",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_approx_equal.html",
      "doc": "Raises an AssertionError if two items are not equal up to significant digits.\n\nGiven two numbers, check that they are approximately equal. Approximately equal is defined as the number of significant digits that agree.",
      "code": "def assert_approx_equal(actual, desired, significant=7, err_msg='',\n                        verbose=True):\n    \"\"\"\n    Raises an AssertionError if two items are not equal up to significant\n    digits.\n\n    .. note:: It is recommended to use one of `assert_allclose`,\n              `assert_array_almost_equal_nulp` or `assert_array_max_ulp`\n              instead of this function for more consistent floating point\n              comparisons.\n\n    Given two numbers, check that they are approximately equal.\n    Approximately equal is defined as the number of significant digits\n    that agree.\n\n    Parameters\n    ----------\n    actual : scalar\n        The object to check.\n    desired : scalar\n        The expected object.\n    significant : int, optional\n        Desired precision, default is 7.\n    err_msg : str, optional\n        The error message to be printed in case of failure.\n    verbose : bool, optional\n        If True, the conflicting values are appended to the error message.\n\n    Raises\n    ------\n    AssertionError\n      If actual and desired are not equal up to specified precision.\n\n    See Also\n    --------\n    assert_allclose: Compare two array_like objects for equality with desired\n                     relative and/or absolute precision.\n    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal\n\n    Examples\n    --------\n    >>> np.testing.assert_approx_equal(0.12345677777777e-20, 0.1234567e-20)\n    >>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345671e-20,\n    ...                                significant=8)\n    >>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345672e-20,\n    ...                                significant=8)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Items are not equal to 8 significant digits:\n     ACTUAL: 1.234567e-21\n     DESIRED: 1.2345672e-21\n\n    the evaluated condition that raises the exception is\n\n    >>> abs(0.12345670e-20/1e-21 - 0.12345672e-20/1e-21) >= 10**-(8-1)\n    True\n\n    \"\"\"\n    __tracebackhide__ = True  # Hide traceback for py.test\n    import numpy as np\n\n    (actual, desired) = map(float, (actual, desired))\n    if desired == actual:\n        return\n    # Normalized the numbers to be in range (-10.0,10.0)\n    # scale = float(pow(10,floor(log10(0.5*(abs(desired)+abs(actual))))))\n    with np.errstate(invalid='ignore'):\n        scale = 0.5*(np.abs(desired) + np.abs(actual))\n        scale = np.power(10, np.floor(np.log10(scale)))\n    try:\n        sc_desired = desired/scale\n    except ZeroDivisionError:\n        sc_desired = 0.0\n    try:\n        sc_actual = actual/scale\n    except ZeroDivisionError:\n        sc_actual = 0.0\n    msg = build_err_msg(\n        [actual, desired], err_msg,\n        header='Items are not equal to %d significant digits:' % significant,\n        verbose=verbose)\n    try:\n        # If one of desired/actual is not finite, handle it specially here:\n        # check that both are nan if any is a nan, and test for equality\n        # otherwise\n        if not (gisfinite(desired) and gisfinite(actual)):\n            if gisnan(desired) or gisnan(actual):\n                if not (gisnan(desired) and gisnan(actual)):\n                    raise AssertionError(msg)\n            else:\n                if not desired == actual:\n                    raise AssertionError(msg)\n            return\n    except (TypeError, ValueError, NotImplementedError):\n        pass\n    if np.abs(sc_desired - sc_actual) >= np.power(10., -(significant-1)):\n        raise AssertionError(msg)"
    },
    {
      "name": "numpy.testing.assert_almost_equal",
      "category": "Assertion Functions",
      "description": "Raises an AssertionError if two items are not equal up to desired precision",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_almost_equal.html",
      "doc": "Raises an AssertionError if two items are not equal up to desired precision.\n\nThe test verifies that the elements of ``actual`` and ``desired`` satisfy ``abs(desired-actual) < float64(1.5 * 10**(-decimal))``.\n\nNote: It is recommended to use one of `assert_allclose`, `assert_array_almost_equal_nulp` or `assert_array_max_ulp` instead of this function for more consistent floating point comparisons.",
      "code": "def assert_almost_equal(actual, desired, decimal=7, err_msg='', verbose=True):\n    \"\"\"\n    Raises an AssertionError if two items are not equal up to desired\n    precision.\n\n    .. note:: It is recommended to use one of `assert_allclose`,\n              `assert_array_almost_equal_nulp` or `assert_array_max_ulp`\n              instead of this function for more consistent floating point\n              comparisons.\n\n    The test verifies that the elements of ``actual`` and ``desired`` satisfy::\n\n        abs(desired-actual) < float64(1.5 * 10**(-decimal))\n\n    That is a looser test than originally documented, but agrees with what the\n    actual implementation did up to rounding vagaries. An exception is raised\n    at conflicting values. For ndarrays this delegates to assert_array_almost_equal\n\n    Parameters\n    ----------\n    actual : array_like\n        The object to check.\n    desired : array_like\n        The expected object.\n    decimal : int, optional\n        Desired precision, default is 7.\n    err_msg : str, optional\n        The error message to be printed in case of failure.\n    verbose : bool, optional\n        If True, the conflicting values are appended to the error message.\n\n    Raises\n    ------\n    AssertionError\n      If actual and desired are not equal up to specified precision.\n\n    See Also\n    --------\n    assert_allclose: Compare two array_like objects for equality with desired\n                     relative and/or absolute precision.\n    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal\n\n    Examples\n    --------\n    >>> np.testing.assert_almost_equal(2.3333333333333, 2.33333334)\n    >>> np.testing.assert_almost_equal(2.3333333333333, 2.33333334, decimal=10)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not almost equal to 10 decimals\n     ACTUAL: 2.3333333333333\n     DESIRED: 2.33333334\n\n    >>> np.testing.assert_almost_equal(np.array([1.0,2.3333333333333]),\n    ...                                np.array([1.0,2.33333334]), decimal=9)\n    Traceback (most recent call last):\n        ...\n    AssertionError:\n    Arrays are not almost equal to 9 decimals\n    <BLANKLINE>\n    Mismatched elements: 1 / 2 (50%)\n    Max absolute difference among violations: 6.66669964e-09\n    Max relative difference among violations: 2.85715698e-09\n     ACTUAL: array([1.         , 2.333333333])\n     DESIRED: array([1.        , 2.33333334])\n\n    \"\"\"\n    __tracebackhide__ = True  # Hide traceback for py.test\n    from numpy._core import ndarray\n    from numpy import isscalar, signbit\n    from numpy.lib import iscomplexobj, real, imag\n\n    if isinstance(actual, ndarray) or isinstance(desired, ndarray):\n        return assert_array_almost_equal(actual, desired, decimal, err_msg)\n    try:\n        # If one of desired/actual is not finite, handle it specially here:\n        # check that both are nan if any is a nan, and test for equality\n        # otherwise\n        if not (gisfinite(desired) and gisfinite(actual)):\n            if gisnan(desired) or gisnan(actual):\n                if not (gisnan(desired) and gisnan(actual)):\n                    raise AssertionError(msg)\n            else:\n                if not desired == actual:\n                    raise AssertionError(msg)\n            return\n    except (NotImplementedError, TypeError):\n        pass\n    if abs(desired - actual) >= np.float64(1.5 * 10.0**(-decimal)):\n        # For `assert_almost_equal`, we consider the following two cases\n        # as special:\n        # (1) if either `desired` or `actual` is a complex with zero\n        #     imaginary part, then the imaginary part is ignored\n        # (2) if neither `desired` nor `actual` is a scalar, then\n        #     `assert_array_almost_equal` is called instead.\n        # Therefore, for two complex numbers close to each other with\n        # non-zero imaginary parts, `assert_almost_equal` will fail while\n        # `assert_array_almost_equal` will pass.\n        if iscomplexobj(actual) or iscomplexobj(desired):\n            # Handle special case that the imaginary part is exactly zero\n            if iscomplexobj(actual):\n                actualr = real(actual)\n                actuali = imag(actual)\n            else:\n                actualr = actual\n                actuali = 0\n            if iscomplexobj(desired):\n                desiredr = real(desired)\n                desiredi = imag(desired)\n            else:\n                desiredr = desired\n                desiredi = 0\n            if actuali == 0 and desiredi == 0:\n                assert_almost_equal(actualr, desiredr, decimal=decimal)\n            return\n        # Handle special case of signed zeros for floats\n        # If actual and desired are both negative, then we're good.\n        # If actual and desired are both positive, then we're good.\n        # If actual and desired have opposite signs, then x and y are\n        # not close to each other (even if both are zero)\n        if (isscalar(desired) and isscalar(actual) and\n                desired == 0 and actual == 0):\n            if signbit(desired) != signbit(actual):\n                msg = build_err_msg([actual, desired], err_msg,\n                                    verbose=verbose,\n                                    header='Arrays are not almost equal '\n                                           '(signbit mismatch) to %d decimals'\n                                            % decimal)\n                raise AssertionError(msg)\n\n        standard_msg = '%s != %s within %d places' % (actual,\n                                                       desired,\n                                                       decimal)\n        msg = build_err_msg([actual, desired], err_msg,\n                            verbose=verbose,\n                            header='Arrays are not almost equal to '\n                                   '%d decimals' % decimal)\n        try:\n            # If one of desired/actual is not finite, handle it specially here:\n            # check that both are nan if any is a nan, and test for equality\n            # otherwise\n            if not (gisfinite(desired) and gisfinite(actual)):\n                if gisnan(desired) or gisnan(actual):\n                    if not (gisnan(desired) and gisnan(actual)):\n                        raise AssertionError(msg)\n                else:\n                    if not desired == actual:\n                        raise AssertionError(msg)\n                return\n        except (TypeError, ValueError, NotImplementedError):\n            pass\n        raise AssertionError(msg)"
    },
    {
      "name": "numpy.testing.assert_raises",
      "category": "Assertion Functions",
      "description": "Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_raises.html",
      "doc": "assert_raises(exception_class, callable, *args, **kwargs)\nassert_raises(exception_class)\n\nFail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs. If a different type of exception is thrown, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.\n\nAlternatively, `assert_raises` can be used as a context manager.",
      "code": "def assert_raises(*args, **kwargs):\n    \"\"\"\n    assert_raises(exception_class, callable, *args, **kwargs)\n    assert_raises(exception_class)\n\n    Fail unless an exception of class exception_class is thrown\n    by callable when invoked with arguments args and keyword\n    arguments kwargs. If a different type of exception is\n    thrown, it will not be caught, and the test case will be\n    deemed to have suffered an error, exactly as for an\n    unexpected exception.\n\n    Alternatively, `assert_raises` can be used as a context manager:\n\n    >>> from numpy.testing import assert_raises\n    >>> with assert_raises(ZeroDivisionError):\n    ...     1 / 0\n\n    is equivalent to\n\n    >>> def div(x, y):\n    ...     return x / y\n    >>> assert_raises(ZeroDivisionError, div, 1, 0)\n\n    \"\"\"\n    __tracebackhide__ = True  # Hide traceback for py.test\n    return _d.assertRaises(*args, **kwargs)"
    },
    {
      "name": "numpy.testing.assert_warns",
      "category": "Assertion Functions",
      "description": "Fail unless the given callable throws the specified warning",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_warns.html",
      "doc": "Fail unless the given callable throws the specified warning.\n\nA warning of class warning_class should be thrown by the callable when invoked with arguments args and keyword arguments kwargs. If a different type of warning is thrown, it will not be caught.\n\nIf called with all arguments other than the warning class omitted, may be used as a context manager.",
      "code": "def assert_warns(warning_class, *args, **kwargs):\n    \"\"\"\n    Fail unless the given callable throws the specified warning.\n\n    A warning of class warning_class should be thrown by the callable when\n    invoked with arguments args and keyword arguments kwargs.\n    If a different type of warning is thrown, it will not be caught.\n\n    If called with all arguments other than the warning class omitted, may be\n    used as a context manager::\n\n        with assert_warns(SomeWarning):\n            do_something()\n\n    The ability to be used as a context manager is new in NumPy v1.11.0.\n\n    Parameters\n    ----------\n    warning_class : class\n        The class defining the warning that `func` is expected to throw.\n    func : callable, optional\n        Callable to test\n    *args : Arguments\n        Arguments for `func`.\n    **kwargs : Kwargs\n        Keyword arguments for `func`.\n\n    Returns\n    -------\n    The value returned by `func`.\n\n    Examples\n    --------\n    >>> import warnings\n    >>> def deprecated_func(num):\n    ...     warnings.warn(\"Please upgrade\", DeprecationWarning)\n    ...     return num*num\n    >>> with np.testing.assert_warns(DeprecationWarning):\n    ...     assert deprecated_func(4) == 16\n    >>> # or passing a func\n    >>> ret = np.testing.assert_warns(DeprecationWarning, deprecated_func, 4)\n    >>> assert ret == 16\n    \"\"\"\n    if not args and not kwargs:\n        return _assert_warns_context(warning_class)\n    elif len(args) < 1:\n        if \"match\" in kwargs:\n            raise RuntimeError(\n                \"assert_warns does not use 'match' kwarg, \"\n                \"use pytest.warns instead\"\n            )\n        raise TypeError(\n            \"assert_warns expected at least a callable 'func', \"\n            \"but received: {}\".format(args or None)\n        )\n    else:\n        with _assert_warns_context(warning_class, name=args[0]):\n            return args[0](*args[1:], **kwargs)"
    },
    {
      "name": "numpy.testing.assert_no_warnings",
      "category": "Assertion Functions",
      "description": "Fail if the given callable produces any warnings",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_no_warnings.html",
      "doc": "Fail if the given callable produces any warnings.\n\nIf called with all arguments omitted, may be used as a context manager.",
      "code": "def assert_no_warnings(*args, **kwargs):\n    \"\"\"\n    Fail if the given callable produces any warnings.\n\n    If called with all arguments omitted, may be used as a context manager::\n\n        with assert_no_warnings():\n            do_something()\n\n    The ability to be used as a context manager is new in NumPy v1.11.0.\n\n    Parameters\n    ----------\n    func : callable\n        The callable to test.\n    *args : Arguments\n        Arguments passed to `func`.\n    **kwargs : Kwargs\n        Keyword arguments passed to `func`.\n\n    Returns\n    -------\n    The value returned by `func`.\n\n    \"\"\"\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        if not args and not kwargs:\n            return sys._getframe(0).f_locals\n        else:\n            return args[0](*args[1:], **kwargs)"
    },
    {
      "name": "numpy.testing.assert_raises_regex",
      "category": "Assertion Functions",
      "description": "Fail unless an exception of class exception_class and with message matching expected_regexp is thrown by callable when invoked with arguments args and keyword arguments kwargs",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_raises_regex.html",
      "doc": "assert_raises_regex(exception_class, expected_regexp, callable, *args, **kwargs)\nassert_raises_regex(exception_class, expected_regexp)\n\nFail unless an exception of class exception_class and with message matching expected_regexp is thrown by callable when invoked with arguments args and keyword arguments kwargs.\n\nAlternatively, can be used as a context manager.",
      "code": "def assert_raises_regex(exception_class, expected_regexp, *args, **kwargs):\n    \"\"\"\n    assert_raises_regex(exception_class, expected_regexp, callable, *args,\n                        **kwargs)\n    assert_raises_regex(exception_class, expected_regexp)\n\n    Fail unless an exception of class exception_class and with message that\n    matches expected_regexp is thrown by callable when invoked with arguments\n    args and keyword arguments kwargs.\n\n    Alternatively, can be used as a context manager.\n\n    Notes\n    -----\n    .. versionadded:: 1.9.0\n\n    \"\"\"\n    __tracebackhide__ = True  # Hide traceback for py.test\n    return _d.assertRaisesRegex(exception_class, expected_regexp,\n                                *args, **kwargs)"
    },
    {
      "name": "numpy.testing.assert_array_compare",
      "category": "Assertion Functions",
      "description": "Asserts that comparison between two array_like objects is satisfied",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_array_compare.html",
      "doc": "Asserts that comparison between two array_like objects is satisfied.\n\nThe comparison is performed elementwise, and the objects are only considered equal if their shapes are the same, and the comparison returns True for all elements.",
      "code": "def assert_array_compare(comparison, x, y, err_msg='', verbose=True, header='',\n                         precision=6, equal_nan=True, equal_inf=True,\n                         *, strict=False):\n    __tracebackhide__ = True  # Hide traceback for py.test\n    from numpy._core import array2string, empty, float_, ndarray, ones\n    \n    x = np.asanyarray(x)\n    y = np.asanyarray(y)\n    \n    # original shapes for comparison\n    x_original_shape = x.shape\n    y_original_shape = y.shape\n    \n    def array_repr(a):\n        if a.shape == ():\n            return f\"array({a})\"\n        else:\n            return np.array2string(a, separator=\", \", prefix=\" \"*9,\n                                  threshold=30)\n\n    def func_assert_same_pos(x, y, func=isnan, hasval='nan'):\n        \"\"\"Handling nan/inf.\n\n        Combine results of running func on x and y, checking that they are True\n        at the same locations.\n        \"\"\"\n        __tracebackhide__ = True  # Hide traceback for py.test\n        \n        x_id = func(x)\n        y_id = func(y)\n        # We include work-arounds here to handle three types of slightly\n        # pathological ndarray subclasses:\n        # (1) all() on `masked` array scalars can return masked arrays, so we\n        #     use != True\n        # (2) __eq__ on some ndarray subclasses returns Python scalars\n        # (3) subclasses with bare-bones __array_function__ implementations may\n        #     not implement np.all(), so favor using the .all() method\n        # We are not committed to supporting such subclasses, but it's nice to\n        # support them if possible.\n        if x_id == y_id:\n            return True\n        \n        if hasattr(x_id, 'all'):\n            x_id = x_id.all()\n            y_id = y_id.all()\n        else:\n            x_id = np.all(x_id)\n            y_id = np.all(y_id)\n        \n        if (x_id == False) and (y_id == False):\n            return True\n        \n        msg = build_err_msg([x, y],\n                            err_msg + f'\\nx and y {hasval} location mismatch:',\n                            verbose=verbose, header=header,\n                            names=('x', 'y'), precision=precision)\n        raise AssertionError(msg)\n\n    # If the arrays are not the same shape, the comparison is False\n    if (x.shape != y.shape) and not strict:\n        # It is possible that the shapes do not match, but the comparison\n        # may still succeed, e.g. if broadcasting can make them the same.\n        # We do the comparison first, with a trap for RecursionError, because\n        # broadcasting does not always work as one might expect, e.g. if\n        # y.shape == (1, 1, ..., 1). If the comparison fails, we try to\n        # broadcast one against the other. If that fails, or the comparison\n        # still fails, then we re-raise the comparison failure.\n        if x.shape == () or y.shape == ():\n            xy_comparison = comparison(x, y)\n        else:\n            # Catch exceptions so we can do the comparison one element at a\n            # time.\n            #\n            # TODO: If a RecursionError is raised, we can fall back to\n            # looping.\n            try:\n                xy_comparison = comparison(x, y)\n            except Exception:\n                xy_comparison = False\n\n        if np.all(xy_comparison == False):\n            # Shapes do not match and the comparison failed, check if either\n            # can be broadcast.\n            try:\n                np.broadcast_shapes(x.shape, y.shape)\n            except ValueError:\n                msg = build_err_msg([x, y],\n                                    err_msg\n                                    + f'\\n(shapes {x.shape}, '\n                                    + f'{y.shape} mismatch)',\n                                    verbose=verbose, header=header,\n                                    names=('x', 'y'), precision=precision)\n                raise AssertionError(msg) from None\n            \n            # They can be broadcast, but the comparison failed.\n            # Cast y to the shape of x for simplicity.\n            y = y * ones(x.shape, bool)\n            x_original_shape = x.shape\n            y_original_shape = y.shape\n            \n            # We need to pass the exception inside the context manager because\n            # it may raise other exceptions when its string representation is\n            # computed.\n            with _assert_no_warnings_context():\n                xy_comparison = comparison(x, y)\n            # If the comparison raises an exception, re-raise the original\n            # exception.\n            if np.any(xy_comparison == False):\n                msg = build_err_msg([x, y],\n                                    err_msg\n                                    + f'\\n(shapes {x_original_shape}, '\n                                    + f'{y_original_shape} mismatch)',\n                                    verbose=verbose, header=header,\n                                    names=('x', 'y'), precision=precision)\n                raise AssertionError(msg)\n\n        if np.all(xy_comparison != False):\n            # Comparison succeeded\n            return\n    \n    if strict:\n        # Ensure no broadcasting, shape and dtype must match exactly\n        if x_original_shape != y_original_shape:\n            msg = build_err_msg([x, y],\n                                err_msg\n                                + f'\\n(shapes {x_original_shape}, '\n                                + f'{y_original_shape} mismatch)',\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n            raise AssertionError(msg)\n\n        if x.dtype != y.dtype:\n            msg = build_err_msg([x, y],\n                                err_msg\n                                + f'\\n(dtypes {x.dtype}, {y.dtype} mismatch)',\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n            raise AssertionError(msg)\n\n    if not comparison(x, y).all():\n        if equal_nan:\n            func_assert_same_pos(x, y, func=isnan, hasval='nan')\n        if equal_inf:\n            func_assert_same_pos(x, y, func=lambda xy: xy == +inf,\n                                hasval='+inf')\n            func_assert_same_pos(x, y, func=lambda xy: xy == -inf,\n                                hasval='-inf')\n\n        mismatch = np.logical_not(comparison(x, y))\n        mismatch_flat = mismatch.ravel()\n        if mismatch_flat.ndim == 0:\n            mismatch_flat = mismatch_flat[None]\n        if np.all(mismatch_flat):\n            msg = build_err_msg([x, y],\n                                err_msg,\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n        \n        n_mismatch = mismatch_flat.sum()\n        n_elements = mismatch_flat.size\n        if n_elements <= 10:\n            msg = build_err_msg([x, y],\n                                err_msg,\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n        else:\n            msg = build_err_msg([x_mismatch, y_mismatch],\n                                err_msg,\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n        raise AssertionError(msg)"
    },
    {
      "name": "numpy.testing.assert_array_almost_equal_nulp",
      "category": "Assertion Functions",
      "description": "Compare two arrays relative to their spacing",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_array_almost_equal_nulp.html",
      "doc": "Compare two arrays relative to their spacing.\n\nThis is a relatively robust method to compare two arrays whose amplitude is variable.",
      "code": "def assert_array_almost_equal_nulp(x, y, nulp=1):\n    \"\"\"\n    Compare two arrays relative to their spacing.\n\n    This is a relatively robust method to compare two arrays whose amplitude\n    is variable.\n\n    Parameters\n    ----------\n    x, y : array_like\n        Input arrays.\n    nulp : int, optional\n        The maximum number of unit in the last place for tolerance (see Notes).\n        Default is 1.\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    AssertionError\n        If the spacing between `x` and `y` for one or more elements is larger\n        than `nulp`.\n\n    See Also\n    --------\n    assert_array_max_ulp : Check that all items of arrays differ in at most\n        N Units in the Last Place.\n    spacing : Return the distance between x and the nearest adjacent number.\n\n    Notes\n    -----\n    An assertion is raised if the following condition is not met::\n\n        abs(x - y) <= nulp * spacing(maximum(abs(x), abs(y)))\n\n    Examples\n    --------\n    >>> x = np.array([1., 1e-10, 1e-20])\n    >>> eps = np.finfo(x.dtype).eps\n    >>> np.testing.assert_array_almost_equal_nulp(x, x*eps/2 + x)\n\n    >>> np.testing.assert_array_almost_equal_nulp(x, x*eps + x)\n    Traceback (most recent call last):\n        ...\n    AssertionError: X and Y are not equal to 1 ULP (max is 2)\n\n    \"\"\"\n    __tracebackhide__ = True  # Hide traceback for py.test\n    import numpy as np\n    ax = np.abs(x)\n    ay = np.abs(y)\n    ref = nulp * np.spacing(np.where(ax > ay, ax, ay))\n    if not np.all(np.abs(x-y) <= ref):\n        if np.iscomplexobj(x) or np.iscomplexobj(y):\n            msg = \"X and Y are not equal to %d ULP\" % nulp\n        else:\n            max_nulp = np.max(nulp_diff(x, y))\n            msg = \"X and Y are not equal to %d ULP (max is %g)\" % (nulp, max_nulp)\n        raise AssertionError(msg)"
    },
    {
      "name": "numpy.testing.assert_array_max_ulp",
      "category": "Assertion Functions",
      "description": "Check that all items of arrays differ in at most N Units in the Last Place",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_array_max_ulp.html",
      "doc": "Check that all items of arrays differ in at most N Units in the Last Place.\n\nParameters\n----------\na, b : array_like\n    Input arrays to be compared.\nmaxulp : int, optional\n    The maximum number of units in the last place that elements of `a` and `b` can differ. Default is 1.\ndtype : dtype, optional\n    Data-type to convert `a` and `b` to if given. Default is None.",
      "code": "def assert_array_max_ulp(a, b, maxulp=1, dtype=None):\n    \"\"\"\n    Check that all items of arrays differ in at most N Units in the Last Place.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to be compared.\n    maxulp : int, optional\n        The maximum number of units in the last place that elements of `a` and\n        `b` can differ. Default is 1.\n    dtype : dtype, optional\n        Data-type to convert `a` and `b` to if given. Default is None.\n\n    Returns\n    -------\n    ret : ndarray\n        Array containing number of representable floating point numbers between\n        items in `a` and `b`.\n\n    Raises\n    ------\n    AssertionError\n        If one or more elements differ by more than `maxulp`.\n\n    Notes\n    -----\n    For computing the ULP difference, this API does not differentiate between\n    various representations of NAN (ULP difference between 0x7fc00000 and 0xffc00000\n    is zero).\n\n    See Also\n    --------\n    assert_array_almost_equal_nulp : Compare two arrays relative to their\n        spacing.\n\n    Examples\n    --------\n    >>> a = np.linspace(0., 1., 100)\n    >>> res = np.testing.assert_array_max_ulp(a, np.arcsin(np.sin(a)))\n\n    \"\"\"\n    __tracebackhide__ = True  # Hide traceback for py.test\n    import numpy as np\n    ret = nulp_diff(a, b, dtype)\n    if not np.all(ret <= maxulp):\n        raise AssertionError(\"Arrays are not almost equal up to %g ULP\" %\n                             maxulp)\n    return ret"
    },
    {
      "name": "numpy.testing.assert_no_gc_cycles",
      "category": "Testing Utilities",
      "description": "Fail if the given callable produces any reference cycles",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_no_gc_cycles.html",
      "doc": "Fail if the given callable produces any reference cycles.\n\nIf called with all arguments omitted, may be used as a context manager.\n\nNote: This function should be used only for debugging purposes, and not in unit tests because it is not reliable. It only checks for cycles in tracked objects which are those that are part of a Python object's reference cycle detector.",
      "code": "def assert_no_gc_cycles(*args, **kwargs):\n    \"\"\"\n    Fail if the given callable produces any reference cycles.\n\n    If called with all arguments omitted, may be used as a context manager::\n\n        with assert_no_gc_cycles():\n            do_something()\n\n    .. versionadded:: 1.15.0\n\n    Parameters\n    ----------\n    func : callable\n        The callable to test.\n    *args : Arguments\n        Arguments passed to `func`.\n    **kwargs : Kwargs\n        Keyword arguments passed to `func`.\n\n    Returns\n    -------\n    Nothing. The result is deliberately discarded to ensure that all cycles\n    are found.\n\n    \"\"\"\n    if not args and not kwargs:\n        return _assert_no_gc_cycles_context()\n    \n    func = args[0]\n    args = args[1:]\n    with _assert_no_gc_cycles_context(name=func.__name__):\n        func(*args, **kwargs)"
    },
    {
      "name": "numpy.testing.break_cycles",
      "category": "Testing Utilities",
      "description": "Break reference cycles",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.break_cycles.html",
      "doc": "Break reference cycles.\n\nDo a full garbage collection and assure that all temporary objects are freed. It is not advisable to use this in unit tests because it is not reliable. It only frees tracked objects which are those that are part of a Python object's reference cycle detector. NumPy dtype objects are not tracked.",
      "code": "def break_cycles():\n    \"\"\"\n    Break reference cycles.\n\n    Calling this function a few times may break some reference cycles. We use\n    it on teardown with the `assert_no_gc_cycles` context manager.\n\n    \"\"\"\n    gc.collect()\n    gc.collect()\n    gc.collect()"
    },
    {
      "name": "numpy.testing.decorate_methods",
      "category": "Decorators",
      "description": "Apply a decorator to all methods in a class matching a regular expression",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.decorate_methods.html",
      "doc": "Apply a decorator to all methods in a class matching a regular expression.\n\nThe given decorator is applied to all public methods of `cls` that are matched by the regular expression `testmatch` (``testmatch.search(methodname)``). Methods that are private, i.e. start with an underscore, are ignored.",
      "code": "def decorate_methods(cls, decorator, testmatch=None):\n    \"\"\"\n    Apply a decorator to all methods in a class matching a regular expression.\n\n    The given decorator is applied to all public methods of `cls` that are\n    matched by the regular expression `testmatch`\n    (``testmatch.search(methodname)``). Methods that are private, i.e. start\n    with an underscore, are ignored.\n\n    Parameters\n    ----------\n    cls : class\n        Class whose methods to decorate.\n    decorator : function\n        Decorator to apply to methods\n    testmatch : compiled regexp or str, optional\n        The regular expression. Default value is None, in which case the\n        nose default (``re.compile(r'(?:^|[\\\\b_\\\\.%s-])[Tt]est' % os.sep)``)\n        is used.\n        If `testmatch` is a string, it is compiled to a regular expression\n        first.\n\n    \"\"\"\n    if testmatch is None:\n        testmatch = re.compile(r'(?:^|[\\\\b_\\\\.%s-])[Tt]est' % os.sep)\n    else:\n        testmatch = re.compile(testmatch)\n    cls_attr = cls.__dict__\n\n    methods = [_m for _m in cls_attr.values()\n               if hasattr(_m, '__call__')]\n    for function in methods:\n        try:\n            if hasattr(function, 'compat_func_name'):\n                funcname = function.compat_func_name\n            else:\n                funcname = function.__name__\n        except AttributeError:\n            # not a function\n            continue\n        if testmatch.search(funcname) and not funcname.startswith('_'):\n            setattr(cls, funcname, decorator(function))\n    return"
    },
    {
      "name": "numpy.testing.measure",
      "category": "Testing Utilities",
      "description": "Return elapsed time for executing code in the namespace of the caller",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.measure.html",
      "doc": "Return elapsed time for executing code in the namespace of the caller.\n\nThe supplied code string is compiled with the Python builtin ``compile``. The precision of the timing is 10 milli-seconds. If the code will execute fast on this timescale, it can be executed many times to get reasonable timing accuracy.",
      "code": "def measure(code_str, times=1, label=None):\n    \"\"\"\n    Return elapsed time for executing code in the namespace of the caller.\n\n    The supplied code string is compiled with the Python builtin ``compile``.\n    The precision of the timing is 10 milli-seconds. If the code will execute\n    fast on this timescale, it can be executed many times to get reasonable\n    timing accuracy.\n\n    Parameters\n    ----------\n    code_str : str\n        The code to be timed.\n    times : int, optional\n        The number of times the code is executed. Default is 1. The code is\n        only compiled once.\n    label : str, optional\n        A label to identify `code_str` with. This is passed into ``compile``\n        as the second argument (for run-time error messages).\n\n    Returns\n    -------\n    elapsed : float\n        Total elapsed time in seconds for executing `code_str` `times` times.\n\n    Examples\n    --------\n    >>> times = 10\n    >>> etime = np.testing.measure('for i in range(1000): np.sqrt(i**2)', times=times)\n    >>> print(\"Time for a single execution : \", etime / times, \"s\")  # doctest: +SKIP\n    Time for a single execution :  0.005 s\n\n    \"\"\"\n    frame = sys._getframe(1)\n    locs, globs = frame.f_locals, frame.f_globals\n\n    code = compile(code_str, \"Test name: %s \" % label, 'exec')\n    i = 0\n    elapsed = jiffies()\n    while i < times:\n        i += 1\n        exec(code, globs, locs)\n    elapsed = jiffies() - elapsed\n    return 0.01*elapsed"
    },
    {
      "name": "numpy.testing.rundocs",
      "category": "Test Running",
      "description": "Run doctests found in the given file",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.rundocs.html",
      "doc": "Run doctests found in the given file.\n\nBy default `rundocs` raises an AssertionError on failure.",
      "code": "def rundocs(filename=None, raise_on_error=True):\n    \"\"\"\n    Run doctests found in the given file.\n\n    By default `rundocs` raises an AssertionError on failure.\n\n    Parameters\n    ----------\n    filename : str\n        The path to the file for which the doctests are run.\n    raise_on_error : bool\n        Whether to raise an AssertionError when a doctest fails. Default is\n        True.\n\n    Notes\n    -----\n    The doctests can be run by the user/developer by adding the ``doctests``\n    argument to the ``test()`` call. For example, to run all tests (including\n    doctests) for `numpy.lib`::\n\n        >>> np.lib.test(doctests=True)  # doctest: +SKIP\n    \"\"\"\n    from numpy._core import arange\n    import doctest\n\n    if filename is None:\n        f = sys._getframe(1)\n        filename = f.f_globals['__file__']\n    name = os.path.splitext(os.path.basename(filename))[0]\n    m = sys.modules.get(name)\n\n    if m is None:\n        raise ImportError(name)\n\n    tests = doctest.DocTestFinder().find(m)\n    runner = doctest.DocTestRunner(verbose=True)\n\n    msg = \"Some doctests failed:\\n\"\n    had_failure = False\n\n    for test in tests:\n        failures, tries = runner.run(test)\n\n        if failures > 0:\n            had_failure = True\n            msg += \"\\n\".join(\n                [test.name, \"-\"*70, runner.failures[0][0].getvalue()])\n\n    if had_failure and raise_on_error:\n        raise AssertionError(msg)"
    },
    {
      "name": "numpy.testing.suppress_warnings",
      "category": "Testing Utilities",
      "description": "Context manager and decorator doing much the same as warnings.catch_warnings",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.suppress_warnings.html",
      "doc": "Context manager and decorator doing much the same as ``warnings.catch_warnings``.\n\nHowever, it also provides a filter mechanism to work around https://bugs.python.org/issue4180.\n\nThis bug causes Python before 3.4 to not reliably show warnings again after they have been ignored once (even within catch_warnings). It means that no \"ignore\" filter can be used easily, since following tests might need to see the warning. Additionally it allows easier specificity for testing warnings and can be nested.",
      "code": "class suppress_warnings:\n    \"\"\"\n    Context manager and decorator doing much the same as\n    ``warnings.catch_warnings``.\n\n    However, it also provides a filter mechanism to work around\n    https://bugs.python.org/issue4180.\n\n    This bug causes Python before 3.4 to not reliably show warnings again\n    after they have been ignored once (even within catch_warnings). It\n    means that no \"ignore\" filter can be used easily, since following\n    tests might need to see the warning. Additionally it allows easier\n    specificity for testing warnings and can be nested.\n\n    Parameters\n    ----------\n    forwarding_rule : str, optional\n        One of \"always\", \"once\", \"module\", or \"location\". Analogous to\n        the usual warnings module filter mode, it is useful to reduce\n        noise mostly on the outmost level. Unsuppressed and unrecorded\n        warnings will be forwarded based on this rule. Defaults to \"always\".\n        \"location\" is equivalent to the warnings \"default\", match by exact\n        location the warning warning originated from.\n\n    Notes\n    -----\n    Filters added inside the context manager will be discarded again\n    when leaving it. Upon entering all filters defined outside a\n    context will be applied automatically.\n\n    When a recording filter is added, matching warnings are stored in the\n    ``log`` attribute as well as in the list returned by ``record``.\n\n    If filters are added and the ``module`` keyword is given, the\n    warning registry of this module will additionally be cleared when\n    applying it, entering the context, or exiting it. This could cause\n    warnings to appear a second time after leaving the context if they\n    were configured to be printed once (default) and were already\n    printed before the context was entered.\n\n    Nesting this context manager will work as expected when the\n    forwarding rule is \"always\" (default). Unfiltered and unrecorded\n    warnings will be passed out and be matched by the outer level.\n    On the outmost level they will be printed (or caught by another\n    warnings context). The forwarding rule argument can modify this\n    behaviour.\n\n    Like ``catch_warnings`` this context manager is not threadsafe.\n\n    Examples\n    --------\n    >>> import warnings\n    >>> with np.testing.suppress_warnings() as sup:\n    ...     sup.filter(DeprecationWarning, \"Some text\")\n    ...     sup.filter(UserWarning.py)\n    ...     # Do something which triggers a warning. The warning will be\n    ...     # ignored and recorded internally by the context manager.\n    ...     sup.record(FutureWarning, \"Does this occur?\")\n    ...     # The FutureWarning was given and the above will have an entry\n    ...     # of length 1.\n    ...     sup.filter(module=np.ma.core)\n    ...     # When leaving, the default behaviour is restored\n\n    Or as a decorator::\n\n        sup = np.testing.suppress_warnings()\n        sup.filter(DeprecationWarning, \"Some text\")\n        sup.filter(UserWarning.py)\n\n        @sup\n        def my_function():\n            # do something which triggers a warning\n    \"\"\"\n    def __init__(self, forwarding_rule=\"always\"):\n        self._entered = False\n        self._suppressions = []\n\n        if forwarding_rule not in {\"always\", \"module\", \"location\", \"once\"}:\n            raise ValueError(\"unsupported forwarding rule.\")\n        self._forwarding_rule = forwarding_rule\n\n    def _clear_registries(self, modules):\n        if modules is None:\n            return\n        for module in modules:\n            if hasattr(module, \"__warningregistry__\"):\n                module.__warningregistry__.clear()\n\n    def _filter(self, category=Warning, message=\"\", module=None, record=False):\n        if record:\n            record = []\n        else:\n            record = None\n        if self._entered:\n            if module is None:\n                warnings.filterwarnings(\n                    \"always\", category=category, message=message)\n            else:\n                module_regex = module.__name__.replace('.', r'\\.') + '$'\n                warnings.filterwarnings(\n                    \"always\", category=category, message=message,\n                    module=module_regex)\n                self._tmp_modules.add(module)\n                self._clear_registries([module])\n\n            self._tmp_suppressions.append(\n                (category, message, re.compile(message, re.I), module, record))\n        else:\n            self._suppressions.append(\n                (category, message, re.compile(message, re.I), module, record))\n\n        return record\n\n    def filter(self, category=Warning, message=\"\", module=None):\n        \"\"\"\n        Add a new suppressing filter or apply it if the state is entered.\n\n        Parameters\n        ----------\n        category : class, optional\n            Warning class to filter\n        message : string, optional\n            Regular expression matching the warning message.\n        module : module, optional\n            Module to filter for. Note that the module (and its file)\n            must match exactly and cannot be a submodule. This may make\n            it unreliable for external modules.\n\n        Notes\n        -----\n        When added within a context, filters are only added inside\n        the context and will be forgotten when the context is exited.\n        \"\"\"\n        self._filter(category=category, message=message, module=module,\n                     record=False)\n\n    def record(self, category=Warning, message=\"\", module=None):\n        \"\"\"\n        Append a new recording filter or apply it if the state is entered.\n\n        All warnings matching will be appended to the ``log`` attribute.\n\n        Parameters\n        ----------\n        category : class, optional\n            Warning class to filter\n        message : string, optional\n            Regular expression matching the warning message.\n        module : module, optional\n            Module to filter for. Note that the module (and its file)\n            must match exactly and cannot be a submodule. This may make\n            it unreliable for external modules.\n\n        Returns\n        -------\n        log : list\n            A list which will be filled with all matched warnings.\n\n        Notes\n        -----\n        When added within a context, filters are only added inside\n        the context and will be forgotten when the context is exited.\n        \"\"\"\n        return self._filter(category=category, message=message, module=module,\n                            record=True)\n\n    def __enter__(self):\n        if self._entered:\n            raise RuntimeError(\"cannot enter suppress_warnings twice.\")\n\n        self._orig_show = warnings.showwarning\n        self._filters = warnings.filters\n        warnings.filters = self._filters[:]\n\n        self._entered = True\n        self._tmp_suppressions = []\n        self._tmp_modules = set()\n        self._forwarded = set()\n\n        self.log = []  # reset global log (no need to keep same list)\n\n        for cat, mess, _, mod, log in self._suppressions:\n            if log is not None:\n                del log[:]  # clear the log\n            if mod is None:\n                warnings.filterwarnings(\n                    \"always\", category=cat, message=mess)\n            else:\n                module_regex = mod.__name__.replace('.', r'\\.') + '$'\n                warnings.filterwarnings(\n                    \"always\", category=cat, message=mess,\n                    module=module_regex)\n                self._tmp_modules.add(mod)\n        warnings.showwarning = self._showwarning\n        self._clear_registries(self._tmp_modules)\n\n        return self\n\n    def __exit__(self, *exc_info):\n        warnings.showwarning = self._orig_show\n        warnings.filters = self._filters\n        self._clear_registries(self._tmp_modules)\n        self._entered = False\n        del self._orig_show\n        del self._filters\n\n    def _showwarning(self, message, category, filename, lineno,\n                     *args, use_warnmsg=None, **kwargs):\n        # NumPy's overridden implementation of showwarning massages\n        # the arguments before passing them to the original\n        # showwarning. The attributes ._showwarning and ._orig_show\n        # allow this function to call the original function even\n        # when nested in another instance of suppress_warnings.\n        use_warnmsg = kwargs.pop(\"_use_warnmsg\", use_warnmsg)\n        for cat, _, pattern, mod, rec in (\n                self._suppressions + self._tmp_suppressions)[::-1]:\n            if (issubclass(category, cat) and\n                    pattern.match(message.args[0]) is not None):\n                if mod is None:\n                    # Message and category match, regardless of module\n                    # (unless module was explicitly tested)\n                    if rec is not None:\n                        msg = WarningMessage(message, category, filename,\n                                             lineno, **kwargs)\n                        self.log.append(msg)\n                        rec.append(msg)\n                    return\n                # Use startswith, because warnings strips the cwd from\n                # a module's filename.\n                if filename.startswith(mod.__file__):\n                    # The message and module (filename) match\n                    if rec is not None:\n                        msg = WarningMessage(message, category,  filename,\n                                             lineno, **kwargs)\n                        self.log.append(msg)\n                        rec.append(msg)\n                    return\n\n        # There is no filter in place, so pass to the outside handler\n        # unless we should only pass it once\n        if self._forwarding_rule == \"always\":\n            if use_warnmsg is None:\n                self._orig_show(message, category, filename, lineno,\n                                *args, **kwargs)\n            else:\n                self._orig_showmsg(use_warnmsg)\n            return\n\n        if self._forwarding_rule == \"once\":\n            signature = (message.args, category)\n        elif self._forwarding_rule == \"module\":\n            signature = (message.args, category, filename)\n        elif self._forwarding_rule == \"location\":\n            signature = (message.args, category, filename, lineno)\n\n        if signature in self._forwarded:\n            return\n        self._forwarded.add(signature)\n        if use_warnmsg is None:\n            self._orig_show(message, category, filename, lineno,\n                            *args, **kwargs)\n        else:\n            self._orig_showmsg(use_warnmsg)\n\n    def __call__(self, func):\n        \"\"\"\n        Function decorator to apply certain suppressions to a whole\n        function.\n        \"\"\"\n        @wraps(func)\n        def new_func(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n\n        return new_func"
    },
    {
      "name": "numpy.testing.clear_and_catch_warnings",
      "category": "Testing Utilities",
      "description": "Context manager that resets warning registry for catching warnings",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.clear_and_catch_warnings.html",
      "doc": "Context manager that resets warning registry for catching warnings.\n\nWarnings can be slippery, because, whenever a warning is triggered, Python adds a ``__warningregistry__`` member to the *calling* module. This makes it impossible to retrigger the warning in this module, whatever you put in the warnings filters. This context manager accepts a sequence of `modules` as a keyword argument to its constructor and:\n\n* stores and removes any ``__warningregistry__`` entries in given `modules` on entry;\n* resets ``__warningregistry__`` to its previous state on exit.\n\nThis makes it possible to trigger any warning afresh inside the context manager without disturbing the state of warnings outside.",
      "code": "class clear_and_catch_warnings(warnings.catch_warnings):\n    \"\"\" Context manager that resets warning registry for catching warnings\n\n    Warnings can be slippery, because, whenever a warning is triggered, Python\n    adds a ``__warningregistry__`` member to the *calling* module.  This makes\n    it impossible to retrigger the warning in this module, whatever you put in\n    the warnings filters.  This context manager accepts a sequence of `modules`\n    as a keyword argument to its constructor and:\n\n    * stores and removes any ``__warningregistry__`` entries in given `modules`\n      on entry;\n    * resets ``__warningregistry__`` to its previous state on exit.\n\n    This makes it possible to trigger any warning afresh inside the context\n    manager without disturbing the state of warnings outside.\n\n    For compatibility with Python, please consider all arguments to be\n    keyword-only.\n\n    Parameters\n    ----------\n    record : bool, optional\n        Specifies whether warnings should be captured by a custom\n        implementation of ``warnings.showwarning()`` and be appended to a list\n        returned by the context manager. Otherwise None is returned by the\n        context manager. The objects appended to the list are arguments whose\n        attributes mirror the arguments to ``showwarning()``.\n    modules : sequence, optional\n        Sequence of modules for which to reset warnings registry on entry and\n        restore on exit. To work correctly, all 'ignore' filters should\n        filter by one of these modules.\n\n    Examples\n    --------\n    >>> import warnings\n    >>> with np.testing.clear_and_catch_warnings(\n    ...         modules=[np._core.fromnumeric]):\n    ...     warnings.simplefilter('always')\n    ...     warnings.filterwarnings('ignore', module='np._core.fromnumeric')\n    ...     # do something that raises a warning but ignore those in\n    ...     # np._core.fromnumeric\n    \"\"\"\n    class_modules = ()\n\n    def __init__(self, record=False, modules=()):\n        self.modules = set(modules).union(self.class_modules)\n        self._warnreg_copies = {}\n        super().__init__(record=record)\n\n    def __enter__(self):\n        for mod in self.modules:\n            if hasattr(mod, '__warningregistry__'):\n                mod_reg = mod.__warningregistry__\n                self._warnreg_copies[mod] = mod_reg.copy()\n                mod_reg.clear()\n        return super().__enter__()\n\n    def __exit__(self, *exc_info):\n        super().__exit__(*exc_info)\n        for mod in self.modules:\n            if hasattr(mod, '__warningregistry__'):\n                mod.__warningregistry__.clear()\n            if mod in self._warnreg_copies:\n                mod.__warningregistry__.update(self._warnreg_copies[mod])"
    },
    {
      "name": "numpy.testing.overrides.get_overridable_numpy_ufuncs",
      "category": "Overrides Module",
      "description": "List all numpy ufuncs overridable via __array_ufunc__",
      "url": "https://numpy.org/doc/stable/reference/testing.overrides.html",
      "doc": "List all numpy ufuncs overridable via `__array_ufunc__`.\n\nReturns a set containing all overridable ufuncs in the public numpy API.",
      "code": "def get_overridable_numpy_ufuncs():\n    \"\"\"List all numpy ufuncs overridable via `__array_ufunc__`\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    set\n        A set containing all overridable ufuncs in the public numpy API.\n    \"\"\"\n    ufuncs = {obj for obj in _umath.__dict__.values()\n              if isinstance(obj, _ufunc)}\n    return ufuncs"
    },
    {
      "name": "numpy.testing.overrides.allows_array_ufunc_override",
      "category": "Overrides Module",
      "description": "Determine if a function can be overridden via __array_ufunc__",
      "url": "https://numpy.org/doc/stable/reference/testing.overrides.html",
      "doc": "Determine if a function can be overridden via `__array_ufunc__`.\n\nThis function is equivalent to ``isinstance(func, np.ufunc)`` and will work correctly for ufuncs defined outside of Numpy.",
      "code": "def allows_array_ufunc_override(func):\n    \"\"\"Determine if a function can be overridden via `__array_ufunc__`\n\n    Parameters\n    ----------\n    func : callable\n        Function that may be overridable via `__array_ufunc__`\n\n    Returns\n    -------\n    bool\n        `True` if `func` is overridable via `__array_ufunc__` and\n        `False` otherwise.\n\n    Notes\n    -----\n    This function is equivalent to ``isinstance(func, np.ufunc)`` and\n    will work correctly for ufuncs defined outside of Numpy.\n\n    \"\"\"\n    return isinstance(func, _ufunc)"
    },
    {
      "name": "numpy.testing.overrides.get_overridable_numpy_array_functions", 
      "category": "Overrides Module",
      "description": "List all numpy functions overridable via __array_function__",
      "url": "https://numpy.org/doc/stable/reference/testing.overrides.html",
      "doc": "List all numpy functions overridable via `__array_function__`.\n\nReturns a set containing all functions in the public numpy API that are overridable via `__array_function__`.",
      "code": "def get_overridable_numpy_array_functions():\n    \"\"\"List all numpy functions overridable via `__array_function__`\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    set\n        A set containing all functions in the public numpy API that are\n        overridable via `__array_function__`.\n\n    \"\"\"\n    # 'import numpy' doesn't import recfunctions, so make sure it's imported\n    # so ufuncs defined there show up in the ufunc listing\n    from numpy.lib import recfunctions  # noqa: F401\n    return _array_functions.copy()"
    },
    {
      "name": "numpy.testing.overrides.allows_array_function_override",
      "category": "Overrides Module", 
      "description": "Determine if a Numpy function can be overridden via __array_function__",
      "url": "https://numpy.org/doc/stable/reference/testing.overrides.html",
      "doc": "Determine if a Numpy function can be overridden via `__array_function__`.\n\nReturns True if `func` is a function in the Numpy API that is overridable via `__array_function__` and False otherwise.",
      "code": "def allows_array_function_override(func):\n    \"\"\"Determine if a Numpy function can be overridden via `__array_function__`\n\n    Parameters\n    ----------\n    func : callable\n        Function that may be overridable via `__array_function__`\n\n    Returns\n    -------\n    bool\n        `True` if `func` is a function in the Numpy API that is\n        overridable via `__array_function__` and `False` otherwise.\n    \"\"\"\n    return func in _array_functions"
    }
  ]
}