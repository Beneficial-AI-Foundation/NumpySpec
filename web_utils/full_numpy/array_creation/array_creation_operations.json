{
  "From shape or value": [
    {
      "name": "numpy.empty",
      "category": "From shape or value",
      "description": "Return a new array of given shape and type, without initializing entries",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.empty.html",
      "doc": "\nReturn a new array of given shape and type, without initializing entries.\n\nParameters\n----------\nshape : int or tuple of int\n    Shape of the empty array, e.g., (2, 3) or 2.\ndtype : data-type, optional\n    Desired output data-type for the array, e.g., numpy.int8. Default is numpy.float64.\norder : {'C', 'F'}, optional, default: 'C'\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.\ndevice : str, optional\n    Device on which to place the created array. Default: None. For Array-API interoperability only, must be \"cpu\" if specified.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\nout : ndarray\n    Array of uninitialized (arbitrary) data of the given shape, dtype, and order.\n\nNotes\n-----\nUnlike other array creation functions (e.g. zeros, ones, full), empty does not initialize the values of the array, \nand may therefore be marginally faster. However, the values stored in the newly allocated array are arbitrary.\n\nExamples\n--------\n>>> np.empty([2, 2])\narray([[ -9.74499359e+001,   6.69583040e-309],\n       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized\n\n>>> np.empty([2, 2], dtype=int)\narray([[-1073741821, -1067949133],\n       [  496041986,    19249760]])                     #uninitialized\n",
      "code": "# numpy.empty is implemented in C as part of the multiarray module\n# Python wrapper:\ndef empty(shape, dtype=float, order='C', *, device=None, like=None):\n    \"\"\"\n    Return a new array of given shape and type, without initializing entries.\n    \"\"\"\n    # Implementation is in C - multiarray.empty\n    # This is a low-level function that allocates memory without initialization\n    pass",
      "signature": "numpy.empty(shape, dtype=float, order='C', *, device=None, like=None)"
    },
    {
      "name": "numpy.empty_like",
      "category": "From shape or value",
      "description": "Return a new array with the same shape and type as a given array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.empty_like.html",
      "doc": "\nReturn a new array with the same shape and type as a given array.\n\nParameters\n----------\nprototype : array_like\n    The shape and data-type of prototype define these same attributes of the returned array.\ndtype : data-type, optional\n    Overrides the data type of the result.\norder : {'C', 'F', 'A', or 'K'}, optional\n    Overrides the memory layout of the result. 'C' means C-order, 'F' means Fortran-order, \n    'A' means 'F' if prototype is Fortran contiguous, 'C' otherwise. 'K' means match the \n    layout of prototype as closely as possible.\nsubok : bool, optional\n    If True, then the newly created array will use the sub-class type of prototype, \n    otherwise it will be a base-class array. Defaults to True.\nshape : int or sequence of ints, optional\n    Overrides the shape of the result.\n\nReturns\n-------\nout : ndarray\n    Array of uninitialized (arbitrary) data with the same shape and type as prototype.\n\nExamples\n--------\n>>> a = ([1,2,3], [4,5,6])\n>>> np.empty_like(a)\narray([[-1073741821,          -1,    1000000],    #uninitialized\n       [         10,           0, -2147483648]])\n",
      "code": "@array_function_dispatch(_empty_like_dispatcher)\ndef empty_like(prototype, dtype=None, order='K', subok=True, shape=None, *, device=None):\n    \"\"\"\n    Return a new array with the same shape and type as a given array.\n    \"\"\"\n    # This function is implemented in the multiarray module\n    # It creates an uninitialized array matching the prototype's properties\n    pass",
      "signature": "numpy.empty_like(prototype, dtype=None, order='K', subok=True, shape=None, *, device=None)"
    },
    {
      "name": "numpy.eye",
      "category": "From shape or value",
      "description": "Return a 2-D array with ones on the diagonal and zeros elsewhere",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.eye.html",
      "doc": "\nReturn a 2-D array with ones on the diagonal and zeros elsewhere.\n\nParameters\n----------\nN : int\n    Number of rows in the output.\nM : int, optional\n    Number of columns in the output. If None, defaults to N.\nk : int, optional\n    Index of the diagonal: 0 (the default) refers to the main diagonal, \n    a positive value refers to an upper diagonal, and a negative value to a lower diagonal.\ndtype : data-type, optional\n    Data-type of the returned array.\norder : {'C', 'F'}, optional\n    Whether the output should be stored in row-major (C-style) or column-major (Fortran-style) order in memory.\n\nReturns\n-------\nI : ndarray of shape (N,M)\n    An array where all elements are equal to zero, except for the k-th diagonal, whose values are equal to one.\n\nExamples\n--------\n>>> np.eye(2, dtype=int)\narray([[1, 0],\n       [0, 1]])\n>>> np.eye(3, k=1)\narray([[0.,  1.,  0.],\n       [0.,  0.,  1.],\n       [0.,  0.,  0.]])\n",
      "code": "@set_array_function_like_doc\n@set_module('numpy')\ndef eye(N, M=None, k=0, dtype=float, order='C', *, device=None, like=None):\n    \"\"\"\n    Return a 2-D array with ones on the diagonal and zeros elsewhere.\n    \"\"\"\n    if like is not None:\n        return _eye_with_like(like, N, M=M, k=k, dtype=dtype, order=order,\n                             device=device)\n    if M is None:\n        M = N\n    m = zeros((N, M), dtype=dtype, order=order, device=device)\n    if k >= M:\n        return m\n    M = M if k >= 0 else M + k\n    N = N if k <= 0 else N - k\n    m[:min(N, M)-max(0, -k), max(0, -k):].flat[::M + 1] = 1\n    return m",
      "signature": "numpy.eye(N, M=None, k=0, dtype=<class 'float'>, order='C', *, device=None, like=None)"
    },
    {
      "name": "numpy.identity",
      "category": "From shape or value",
      "description": "Return the identity array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.identity.html",
      "doc": "\nReturn the identity array.\n\nThe identity array is a square array with ones on the main diagonal.\n\nParameters\n----------\nn : int\n    Number of rows (and columns) in n x n output.\ndtype : data-type, optional\n    Data-type of the output. Defaults to float.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\nout : ndarray\n    n x n array with its main diagonal set to one, and all other elements 0.\n\nExamples\n--------\n>>> np.identity(3)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n",
      "code": "@set_array_function_like_doc\n@set_module('numpy')\ndef identity(n, dtype=None, *, like=None):\n    \"\"\"\n    Return the identity array.\n\n    The identity array is a square array with ones on the main diagonal.\n    \"\"\"\n    if like is not None:\n        return _identity_with_like(like, n, dtype=dtype)\n\n    from numpy import eye\n    return eye(n, dtype=dtype, like=like)",
      "signature": "numpy.identity(n, dtype=None, *, like=None)"
    },
    {
      "name": "numpy.ones",
      "category": "From shape or value",
      "description": "Return a new array of given shape and type, filled with ones",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.ones.html",
      "doc": "\nReturn a new array of given shape and type, filled with ones.\n\nParameters\n----------\nshape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2.\ndtype : data-type, optional\n    The desired data-type for the array, e.g., numpy.int8. Default is numpy.float64.\norder : {'C', 'F'}, optional, default: 'C'\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.\n\nReturns\n-------\nout : ndarray\n    Array of ones with the given shape, dtype, and order.\n\nExamples\n--------\n>>> np.ones(5)\narray([1., 1., 1., 1., 1.])\n\n>>> np.ones((5,), dtype=int)\narray([1, 1, 1, 1, 1])\n\n>>> np.ones((2, 1))\narray([[1.],\n       [1.]])\n\n>>> s = (2,2)\n>>> np.ones(s)\narray([[1.,  1.],\n       [1.,  1.]])\n",
      "code": "@set_array_function_like_doc\n@set_module('numpy')\ndef ones(shape, dtype=None, order='C', *, device=None, like=None):\n    \"\"\"\n    Return a new array of given shape and type, filled with ones.\n    \"\"\"\n    if like is not None:\n        return _ones_with_like(like, shape, dtype=dtype, order=order,\n                              device=device)\n\n    a = empty(shape, dtype, order, device=device)\n    multiarray.copyto(a, 1, casting='unsafe')\n    return a",
      "signature": "numpy.ones(shape, dtype=None, order='C', *, device=None, like=None)"
    },
    {
      "name": "numpy.ones_like",
      "category": "From shape or value",
      "description": "Return an array of ones with the same shape and type as a given array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.ones_like.html",
      "doc": "\nReturn an array of ones with the same shape and type as a given array.\n\nParameters\n----------\na : array_like\n    The shape and data-type of a define these same attributes of the returned array.\ndtype : data-type, optional\n    Overrides the data type of the result.\norder : {'C', 'F', 'A', or 'K'}, optional\n    Overrides the memory layout of the result.\nsubok : bool, optional\n    If True, then the newly created array will use the sub-class type of a, otherwise it will be a base-class array.\nshape : int or sequence of ints, optional\n    Overrides the shape of the result.\n\nReturns\n-------\nout : ndarray\n    Array of ones with the same shape and type as a.\n\nExamples\n--------\n>>> x = np.arange(6)\n>>> x = x.reshape((2, 3))\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.ones_like(x)\narray([[1, 1, 1],\n       [1, 1, 1]])\n",
      "code": "@array_function_dispatch(_ones_like_dispatcher)\ndef ones_like(\n    a, dtype=None, order='K', subok=True, shape=None, *, device=None\n):\n    \"\"\"\n    Return an array of ones with the same shape and type as a given array.\n    \"\"\"\n    res = empty_like(\n        a, dtype=dtype, order=order, subok=subok, shape=shape, device=device\n    )\n    multiarray.copyto(res, 1, casting='unsafe')\n    return res",
      "signature": "numpy.ones_like(a, dtype=None, order='K', subok=True, shape=None, *, device=None)"
    },
    {
      "name": "numpy.zeros",
      "category": "From shape or value",
      "description": "Return a new array of given shape and type, filled with zeros",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.zeros.html",
      "doc": "\nReturn a new array of given shape and type, filled with zeros.\n\nParameters\n----------\nshape : int or tuple of ints\n    Shape of the new array, e.g., (2, 3) or 2.\ndtype : data-type, optional\n    The desired data-type for the array, e.g., numpy.int8. Default is numpy.float64.\norder : {'C', 'F'}, optional, default: 'C'\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.\n\nReturns\n-------\nout : ndarray\n    Array of zeros with the given shape, dtype, and order.\n\nExamples\n--------\n>>> np.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])\n\n>>> np.zeros((5,), dtype=int)\narray([0, 0, 0, 0, 0])\n\n>>> np.zeros((2, 1))\narray([[ 0.],\n       [ 0.]])\n",
      "code": "@set_array_function_like_doc\n@set_module('numpy')\ndef zeros(shape, dtype=float, order='C', *, device=None, like=None):\n    \"\"\"\n    Return a new array of given shape and type, filled with zeros.\n    \"\"\"\n    if like is not None:\n        return _zeros_with_like(like, shape, dtype=dtype, order=order,\n                               device=device)\n\n    a = empty(shape, dtype, order, device=device)\n    multiarray.copyto(a, 0, casting='unsafe')\n    return a",
      "signature": "numpy.zeros(shape, dtype=float, order='C', *, device=None, like=None)"
    },
    {
      "name": "numpy.zeros_like",
      "category": "From shape or value",
      "description": "Return an array of zeros with the same shape and type as a given array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.zeros_like.html",
      "doc": "\nReturn an array of zeros with the same shape and type as a given array.\n\nParameters\n----------\na : array_like\n    The shape and data-type of a define these same attributes of the returned array.\ndtype : data-type, optional\n    Overrides the data type of the result.\norder : {'C', 'F', 'A', or 'K'}, optional\n    Overrides the memory layout of the result.\nsubok : bool, optional\n    If True, then the newly created array will use the sub-class type of a, otherwise it will be a base-class array.\nshape : int or sequence of ints, optional\n    Overrides the shape of the result.\n\nReturns\n-------\nout : ndarray\n    Array of zeros with the same shape and type as a.\n\nExamples\n--------\n>>> x = np.arange(6)\n>>> x = x.reshape((2, 3))\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.zeros_like(x)\narray([[0, 0, 0],\n       [0, 0, 0]])\n",
      "code": "@array_function_dispatch(_zeros_like_dispatcher)\ndef zeros_like(\n    a, dtype=None, order='K', subok=True, shape=None, *, device=None\n):\n    \"\"\"\n    Return an array of zeros with the same shape and type as a given array.\n    \"\"\"\n    res = empty_like(\n        a, dtype=dtype, order=order, subok=subok, shape=shape, device=device\n    )\n    # needed instead of a 0 to get same result as zeros for string dtypes\n    z = zeros(1, dtype=res.dtype)\n    multiarray.copyto(res, z, casting='unsafe')\n    return res",
      "signature": "numpy.zeros_like(a, dtype=None, order='K', subok=True, shape=None, *, device=None)"
    },
    {
      "name": "numpy.full",
      "category": "From shape or value",
      "description": "Return a new array of given shape and type, filled with fill_value",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.full.html",
      "doc": "\nReturn a new array of given shape and type, filled with fill_value.\n\nParameters\n----------\nshape : int or sequence of ints\n    Shape of the new array, e.g., (2, 3) or 2.\nfill_value : scalar or array_like\n    Fill value.\ndtype : data-type, optional\n    The desired data-type for the array. The default, None, means infer from fill_value.\norder : {'C', 'F'}, optional, default: 'C'\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.\n\nReturns\n-------\nout : ndarray\n    Array of fill_value with the given shape, dtype, and order.\n\nExamples\n--------\n>>> np.full((2, 2), np.inf)\narray([[inf, inf],\n       [inf, inf]])\n>>> np.full((2, 2), 10)\narray([[10, 10],\n       [10, 10]])\n\n>>> np.full((2, 2), [1, 2])\narray([[1, 2],\n       [1, 2]])\n",
      "code": "@set_array_function_like_doc\n@set_module('numpy')\ndef full(shape, fill_value, dtype=None, order='C', *, device=None, like=None):\n    \"\"\"\n    Return a new array of given shape and type, filled with `fill_value`.\n    \"\"\"\n    if like is not None:\n        return _full_with_like(\n                like, shape, fill_value, dtype=dtype, order=order,\n                device=device)\n\n    if dtype is None:\n        fill_value = asarray(fill_value)\n        dtype = fill_value.dtype\n    a = empty(shape, dtype, order, device=device)\n    multiarray.copyto(a, fill_value, casting='unsafe')\n    return a",
      "signature": "numpy.full(shape, fill_value, dtype=None, order='C', *, device=None, like=None)"
    },
    {
      "name": "numpy.full_like",
      "category": "From shape or value",
      "description": "Return a full array with the same shape and type as a given array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.full_like.html",
      "doc": "\nReturn a full array with the same shape and type as a given array.\n\nParameters\n----------\na : array_like\n    The shape and data-type of a define these same attributes of the returned array.\nfill_value : array_like\n    Fill value.\ndtype : data-type, optional\n    Overrides the data type of the result.\norder : {'C', 'F', 'A', or 'K'}, optional\n    Overrides the memory layout of the result.\nsubok : bool, optional\n    If True, then the newly created array will use the sub-class type of a, otherwise it will be a base-class array.\nshape : int or sequence of ints, optional\n    Overrides the shape of the result.\n\nReturns\n-------\nout : ndarray\n    Array of fill_value with the same shape and type as a.\n\nExamples\n--------\n>>> x = np.arange(6, dtype=int)\n>>> np.full_like(x, 1)\narray([1, 1, 1, 1, 1, 1])\n>>> np.full_like(x, 0.1)\narray([0, 0, 0, 0, 0, 0])\n>>> np.full_like(x, 0.1, dtype=np.double)\narray([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n",
      "code": "@array_function_dispatch(_full_like_dispatcher)\ndef full_like(\n    a, fill_value, dtype=None, order='K', subok=True, shape=None,\n    *, device=None\n):\n    \"\"\"\n    Return a full array with the same shape and type as a given array.\n    \"\"\"\n    res = empty_like(\n        a, dtype=dtype, order=order, subok=subok, shape=shape, device=device\n    )\n    multiarray.copyto(res, fill_value, casting='unsafe')\n    return res",
      "signature": "numpy.full_like(a, fill_value, dtype=None, order='K', subok=True, shape=None, *, device=None)"
    }
  ],
  "From existing data": [
    {
      "name": "numpy.array",
      "category": "From existing data",
      "description": "Create an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.array.html",
      "doc": "\nCreate an array.\n\nParameters\n----------\nobject : array_like\n    An array, any object exposing the array interface, an object whose __array__ method returns an array, \n    or any (nested) sequence. If object is a scalar, a 0-dimensional array containing object is returned.\ndtype : data-type, optional\n    The desired data-type for the array. If not given, NumPy will try to use a default dtype that can \n    represent the values (by applying promotion rules when necessary.)\ncopy : bool, optional\n    If True (default), then the array data is copied. If None, a copy will only be made if __array__ \n    returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements.\norder : {'K', 'A', 'C', 'F'}, optional\n    Specify the memory layout of the array.\nsubok : bool, optional\n    If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be \n    a base-class array (default).\nndmin : int, optional\n    Specifies the minimum number of dimensions that the resulting array should have.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\nout : ndarray\n    An array object satisfying the specified requirements.\n\nExamples\n--------\n>>> np.array([1, 2, 3])\narray([1, 2, 3])\n\n>>> np.array([1, 2, 3.0])\narray([ 1.,  2.,  3.])\n\n>>> np.array([[1, 2], [3, 4]])\narray([[1, 2],\n       [3, 4]])\n\n>>> np.array([1, 2, 3], ndmin=2)\narray([[1, 2, 3]])\n\n>>> np.array([1, 2, 3], dtype=complex)\narray([ 1.+0.j,  2.+0.j,  3.+0.j])\n",
      "code": "# numpy.array is implemented in C as part of the multiarray module\n# Python signature:\n@array_function_dispatch(_array_dispatcher)\ndef array(object, dtype=None, *, copy=True, order='K', subok=False,\n          ndmin=0, like=None):\n    \"\"\"\n    Create an array.\n    \"\"\"\n    # Implementation is in C - multiarray.array\n    # This is the primary array creation function in NumPy\n    pass",
      "signature": "numpy.array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0, like=None)"
    },
    {
      "name": "numpy.asarray",
      "category": "From existing data",
      "description": "Convert the input to an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.asarray.html",
      "doc": "\nConvert the input to an array.\n\nParameters\n----------\na : array_like\n    Input data, in any form that can be converted to an array. This includes lists, lists of tuples, \n    tuples, tuples of tuples, tuples of lists and ndarrays.\ndtype : data-type, optional\n    By default, the data-type is inferred from the input data.\norder : {'C', 'F', 'A', 'K'}, optional\n    Memory layout.\ndevice : str, optional\n    Device on which to place the created array.\ncopy : bool, optional\n    If True, then the object is copied. If False, a copy will only be made if needed to satisfy dtype or order requirements.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\nout : ndarray\n    Array interpretation of a. No copy is performed if the input is already an ndarray with matching dtype and order.\n\nExamples\n--------\n>>> a = [1, 2]\n>>> np.asarray(a)\narray([1, 2])\n\n>>> a = np.array([1, 2])\n>>> np.asarray(a) is a\nTrue\n\n>>> a = np.array([1, 2], dtype=np.float32)\n>>> np.asarray(a, dtype=np.float32) is a\nTrue\n>>> np.asarray(a, dtype=np.float64) is a\nFalse\n",
      "code": "@array_function_dispatch(_asarray_dispatcher)\ndef asarray(a, dtype=None, order=None, *, device=None, copy=None, like=None):\n    \"\"\"\n    Convert the input to an array.\n    \"\"\"\n    if like is not None:\n        return _asarray_with_like(\n            a, dtype=dtype, order=order, device=device, copy=copy, like=like\n        )\n\n    return array(a, dtype, copy=False if copy is None else copy, order=order,\n                device=device)",
      "signature": "numpy.asarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)"
    },
    {
      "name": "numpy.asanyarray",
      "category": "From existing data",
      "description": "Convert the input to an ndarray, but pass ndarray subclasses through",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.asanyarray.html",
      "doc": "\nConvert the input to an ndarray, but pass ndarray subclasses through.\n\nParameters\n----------\na : array_like\n    Input data, in any form that can be converted to an array. This includes scalars, lists, \n    lists of tuples, tuples, tuples of tuples, tuples of lists, and ndarrays.\ndtype : data-type, optional\n    By default, the data-type is inferred from the input data.\norder : {'C', 'F', 'A', 'K'}, optional\n    Memory layout.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\nout : ndarray or an ndarray subclass\n    Array interpretation of a. If a is an ndarray or a subclass of ndarray, it is returned as-is and no copy is performed.\n\nExamples\n--------\n>>> a = [1, 2]\n>>> np.asanyarray(a)\narray([1, 2])\n\n>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)\n>>> np.asanyarray(a) is a\nTrue\n",
      "code": "@array_function_dispatch(_asanyarray_dispatcher)\ndef asanyarray(a, dtype=None, order=None, *, like=None):\n    \"\"\"\n    Convert the input to an ndarray, but pass ndarray subclasses through.\n    \"\"\"\n    if like is not None:\n        return _asanyarray_with_like(a, dtype=dtype, order=order, like=like)\n\n    return array(a, dtype, copy=False, order=order, subok=True)",
      "signature": "numpy.asanyarray(a, dtype=None, order=None, *, like=None)"
    },
    {
      "name": "numpy.ascontiguousarray",
      "category": "From existing data",
      "description": "Return a contiguous array (ndim >= 1) in memory (C order)",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.ascontiguousarray.html",
      "doc": "\nReturn a contiguous array (ndim >= 1) in memory (C order).\n\nParameters\n----------\na : array_like\n    Input array.\ndtype : str or dtype object, optional\n    Data-type of returned array.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\nout : ndarray\n    Contiguous array of same shape and content as a, with type dtype if specified.\n\nExamples\n--------\n>>> x = np.arange(6).reshape(2,3)\n>>> np.ascontiguousarray(x, dtype=np.float32)\narray([[0., 1., 2.],\n       [3., 4., 5.]], dtype=float32)\n>>> x.flags['C_CONTIGUOUS']\nTrue\n\nNote: This function returns at least a 1-dimensional array. Scalar inputs are converted to 1-dimensional arrays.\n",
      "code": "@array_function_dispatch(_ascontiguousarray_dispatcher)\ndef ascontiguousarray(a, dtype=None, *, like=None):\n    \"\"\"\n    Return a contiguous array (ndim >= 1) in memory (C order).\n    \"\"\"\n    if like is not None:\n        return _ascontiguousarray_with_like(a, dtype=dtype, like=like)\n\n    return array(a, dtype, copy=False, order='C', ndmin=1)",
      "signature": "numpy.ascontiguousarray(a, dtype=None, *, like=None)"
    },
    {
      "name": "numpy.asmatrix",
      "category": "From existing data",
      "description": "Interpret the input as a matrix",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.asmatrix.html",
      "doc": "\nInterpret the input as a matrix.\n\nParameters\n----------\ndata : array_like\n    Input data.\ndtype : data-type\n    Data-type of the output matrix.\n\nReturns\n-------\nmat : matrix\n    data interpreted as a matrix.\n\nExamples\n--------\n>>> x = np.array([[1, 2], [3, 4]])\n\n>>> m = np.asmatrix(x)\n\n>>> x[0,0] = 5\n\n>>> m\nmatrix([[5, 2],\n        [3, 4]])\n\nNotes\n-----\nUnlike matrix, asmatrix does not make a copy if the input is already a matrix or an ndarray. \nEquivalent to matrix(data, copy=False).\n",
      "code": "def asmatrix(data, dtype=None):\n    \"\"\"\n    Interpret the input as a matrix.\n\n    Unlike `matrix`, `asmatrix` does not make a copy if the input is already\n    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.\n    \"\"\"\n    return matrix(data, dtype=dtype, copy=False)",
      "signature": "numpy.asmatrix(data, dtype=None)"
    },
    {
      "name": "numpy.copy",
      "category": "From existing data",
      "description": "Return an array copy of the given object",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.copy.html",
      "doc": "\nReturn an array copy of the given object.\n\nParameters\n----------\na : array_like\n    Input data.\norder : {'C', 'F', 'A', 'K'}, optional\n    Controls the memory layout of the copy. 'C' means C-order, 'F' means Fortran-order, \n    'A' means 'F' if a is Fortran contiguous, 'C' otherwise. 'K' means match the layout \n    of a as closely as possible.\nsubok : bool, optional\n    If True, then sub-classes will be passed-through, otherwise the returned array will \n    be forced to be a base-class array (defaults to False).\n\nReturns\n-------\narr : ndarray\n    Array interpretation of a.\n\nExamples\n--------\nCreate an array x, with a reference y and a copy z:\n\n>>> x = np.array([1, 2, 3])\n>>> y = x\n>>> z = np.copy(x)\n\nNote that, when we modify x, y changes, but not z:\n\n>>> x[0] = 10\n>>> x[0] == y[0]\nTrue\n>>> x[0] == z[0]\nFalse\n\nNote that np.copy clears previously set WRITEABLE=False flag.\n",
      "code": "@array_function_dispatch(_copy_dispatcher)\ndef copy(a, order='K', subok=False):\n    \"\"\"\n    Return an array copy of the given object.\n    \"\"\"\n    return array(a, order=order, subok=subok, copy=True)",
      "signature": "numpy.copy(a, order='K', subok=False)"
    },
    {
      "name": "numpy.frombuffer",
      "category": "From existing data",
      "description": "Interpret a buffer as a 1-dimensional array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.frombuffer.html",
      "doc": "\nInterpret a buffer as a 1-dimensional array.\n\nParameters\n----------\nbuffer : buffer_like\n    An object that exposes the buffer interface.\ndtype : data-type, optional\n    Data-type of the returned array; default: float.\ncount : int, optional\n    Number of items to read. -1 means all data in the buffer.\noffset : int, optional\n    Start reading the buffer from this offset (in bytes); default: 0.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\nout : ndarray\n    1-dimensional array.\n\nExamples\n--------\n>>> s = b'hello world'\n>>> np.frombuffer(s, dtype='S1', count=5, offset=6)\narray([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')\n\n>>> np.frombuffer(b'\\x01\\x02', dtype=np.uint8)\narray([1, 2], dtype=uint8)\n>>> np.frombuffer(b'\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)\narray([1, 2, 3], dtype=uint8)\n\nNotes\n-----\nIf the buffer has data that is not in machine byte-order, this should be specified as part of the data-type.\n",
      "code": "@array_function_dispatch(_frombuffer_dispatcher)\ndef frombuffer(buffer, dtype=float, count=-1, offset=0, *, like=None):\n    \"\"\"\n    Interpret a buffer as a 1-dimensional array.\n    \"\"\"\n    if like is not None:\n        return _frombuffer_with_like(\n            buffer, dtype=dtype, count=count, offset=offset, like=like\n        )\n\n    return _core_frombuffer(buffer, dtype, count, offset)",
      "signature": "numpy.frombuffer(buffer, dtype=float, count=-1, offset=0, *, like=None)"
    },
    {
      "name": "numpy.from_dlpack",
      "category": "From existing data",
      "description": "Create a NumPy array from an object implementing the __dlpack__ protocol",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.from_dlpack.html",
      "doc": "\nCreate a NumPy array from an object implementing the __dlpack__ protocol.\n\nParameters\n----------\nx : object\n    A Python object that implements the __dlpack__ and __dlpack_device__ methods.\ndevice : device, optional\n    Device on which to place the created array. Must be \"cpu\" if specified.\ncopy : bool, optional\n    If True, the array is copied. If False, the array is not copied. \n    If None (default), the array is only copied if necessary.\n\nReturns\n-------\nout : ndarray\n    Array created from the input object.\n\nNotes\n-----\nThis function allows for interoperability with other libraries that support the DLPack protocol.\n",
      "code": "def from_dlpack(x, /, *, device=None, copy=None):\n    \"\"\"\n    Create a NumPy array from an object implementing the ``__dlpack__``\n    protocol. Generally, the returned NumPy array is a read-only view\n    of the input object. See [1]_ and [2]_ for more details.\n    \"\"\"\n    if hasattr(x, '__dlpack_device__') and hasattr(x, '__dlpack__'):\n        return _from_dlpack(x.__dlpack__(stream=None, \n                                       max_version=(1, 0),\n                                       dl_device=device,\n                                       copy=copy))\n    else:\n        raise TypeError(f\"The input must implement the DLPack protocol. \"\n                       f\"Got {type(x)}.\")",
      "signature": "numpy.from_dlpack(x, /, *, device=None, copy=None)"
    },
    {
      "name": "numpy.fromfile",
      "category": "From existing data",
      "description": "Construct an array from data in a text or binary file",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html",
      "doc": "\nConstruct an array from data in a text or binary file.\n\nParameters\n----------\nfile : file or str or Path\n    Open file object or filename.\ndtype : data-type\n    Data type of the returned array. For binary files, it is used to determine the size and byte-order \n    of the items in the file. Most builtin numeric types are supported and extension types may be supported.\ncount : int\n    Number of items to read. -1 means all items (i.e., the complete file).\nsep : str\n    Separator between items if file is a text file. Empty (\"\") separator means the file should be \n    treated as binary. Spaces (\" \") in the separator match zero or more whitespace characters.\noffset : int\n    The offset (in bytes) from the file's current position. Defaults to 0. Only permitted for binary files.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\narr : ndarray\n    Array of data from the file.\n\nNotes\n-----\nDo not rely on the combination of tofile and fromfile for data storage, as the binary files generated \nare not platform independent. In particular, no byte-order or data-type information is saved.\n",
      "code": "@array_function_dispatch(_fromfile_dispatcher)\ndef fromfile(file, dtype=float, count=-1, sep='', offset=0, *, like=None):\n    \"\"\"\n    Construct an array from data in a text or binary file.\n    \"\"\"\n    if like is not None:\n        return _fromfile_with_like(\n            file, dtype=dtype, count=count, sep=sep, offset=offset, like=like\n        )\n\n    if isinstance(file, os.PathLike):\n        file = os.fspath(file)\n    return _core_fromfile(file, dtype, count, sep, offset)",
      "signature": "numpy.fromfile(file, dtype=float, count=-1, sep='', offset=0, *, like=None)"
    },
    {
      "name": "numpy.fromfunction",
      "category": "From existing data",
      "description": "Construct an array by executing a function over each coordinate",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.fromfunction.html",
      "doc": "\nConstruct an array by executing a function over each coordinate.\n\nParameters\n----------\nfunction : callable\n    The function is called with N parameters, where N is the rank of shape. Each parameter represents \n    the coordinates of the array varying along a specific axis.\nshape : (N,) tuple of ints\n    Shape of the output array, which also determines the shape of the coordinate arrays passed to function.\ndtype : data-type, optional\n    Data-type of the coordinate arrays passed to function. By default, dtype is float.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n**kwargs : keyword arguments, optional\n    Any keyword arguments to pass to function.\n\nReturns\n-------\nfromfunction : ndarray\n    The result of the call to function is passed back directly. Therefore the shape of fromfunction \n    is completely determined by function.\n\nExamples\n--------\n>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]])\n\n>>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n",
      "code": "@set_module('numpy')\ndef fromfunction(function, shape, *, dtype=float, like=None, **kwargs):\n    \"\"\"\n    Construct an array by executing a function over each coordinate.\n\n    The resulting array therefore has a value ``fn(x, y, z)`` at\n    coordinate ``(x, y, z)``.\n    \"\"\"\n    if like is not None:\n        return _fromfunction_with_like(\n            function, shape, dtype=dtype, like=like, **kwargs\n        )\n\n    args = indices(shape, dtype=dtype)\n    return function(*args, **kwargs)",
      "signature": "numpy.fromfunction(function, shape, *, dtype=<class 'float'>, like=None, **kwargs)"
    },
    {
      "name": "numpy.fromiter",
      "category": "From existing data",
      "description": "Create a new 1-dimensional array from an iterable object",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.fromiter.html",
      "doc": "\nCreate a new 1-dimensional array from an iterable object.\n\nParameters\n----------\niter : iterable object\n    An iterable object providing data for the array.\ndtype : data-type\n    The data-type of the returned array.\ncount : int, optional\n    The number of items to read from iterable. The default is -1, which means all data is read.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\nout : ndarray\n    The output array.\n\nExamples\n--------\n>>> iterable = (x*x for x in range(5))\n>>> np.fromiter(iterable, float)\narray([  0.,   1.,   4.,   9.,  16.])\n\nTo read from a text file object:\n\n>>> from io import StringIO\n>>> f = StringIO(\"1 2 3 4\")\n>>> np.fromiter(f.read().split(), dtype=int)\narray([1, 2, 3, 4])\n",
      "code": "@array_function_dispatch(_fromiter_dispatcher)\ndef fromiter(iter, dtype, count=-1, *, like=None):\n    \"\"\"\n    Create a new 1-dimensional array from an iterable object.\n    \"\"\"\n    if like is not None:\n        return _fromiter_with_like(iter, dtype, count=count, like=like)\n\n    return _core_fromiter(iter, dtype, count)",
      "signature": "numpy.fromiter(iter, dtype, count=-1, *, like=None)"
    },
    {
      "name": "numpy.fromstring",
      "category": "From existing data",
      "description": "A new 1-D array initialized from text data in a string",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.fromstring.html",
      "doc": "\nA new 1-D array initialized from text data in a string.\n\nParameters\n----------\nstring : str\n    A string containing the data.\ndtype : data-type, optional\n    The data type of the array; default: float. For binary input data, the data must be in exactly \n    this format. Most builtin numeric types are supported and extension types may be supported.\ncount : int, optional\n    Read this number of dtype elements from the data. If this is negative (the default), the count \n    will be determined from the length of the data.\nsep : str, optional\n    The string separating numbers in the data; extra whitespace between elements is also ignored.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\narr : ndarray\n    The constructed array.\n\nExamples\n--------\n>>> np.fromstring('1 2', dtype=int, sep=' ')\narray([1, 2])\n>>> np.fromstring('1, 2', dtype=int, sep=',')\narray([1, 2])\n\nRaises\n------\nValueError\n    If the string is not the correct size to satisfy the requested dtype and count.\n\nNotes\n-----\nDeprecated since version 1.14.0: If the sep argument is not provided or is None, the function \nwill continue to work as it did before, but a FutureWarning will be emitted. Use frombuffer to \nwork with binary data, or loadtxt to work with text data.\n",
      "code": "@array_function_dispatch(_fromstring_dispatcher)\ndef fromstring(string, dtype=float, count=-1, *, sep, like=None):\n    \"\"\"\n    A new 1-D array initialized from text data in a string.\n    \"\"\"\n    if like is not None:\n        return _fromstring_with_like(\n            string, dtype=dtype, count=count, sep=sep, like=like\n        )\n\n    return _core_fromstring(string, dtype, count, sep)",
      "signature": "numpy.fromstring(string, dtype=float, count=-1, *, sep, like=None)"
    },
    {
      "name": "numpy.loadtxt",
      "category": "From existing data",
      "description": "Load data from a text file",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.loadtxt.html",
      "doc": "\nLoad data from a text file.\n\nParameters\n----------\nfname : file, str, pathlib.Path, list of str, generator\n    File, filename, list, or generator to read. If the filename extension is .gz or .bz2, \n    the file is first decompressed.\ndtype : data-type, optional\n    Data-type of the resulting array; default: float.\ncomments : str or sequence of str or None, optional\n    The characters or list of characters used to indicate the start of a comment. \n    None implies no comments.\ndelimiter : str, optional\n    The character used to separate the values. For backwards compatibility, byte strings \n    will be decoded as 'latin1'. The default is whitespace.\nconverters : dict or callable, optional\n    Converter functions to customize value parsing.\nskiprows : int, optional\n    Skip the first skiprows lines, including comments; default: 0.\nusecols : int or sequence, optional\n    Which columns to read, with 0 being the first.\nunpack : bool, optional\n    If True, the returned array is transposed, so that arguments may be unpacked using \n    x, y, z = loadtxt(...). Default is False.\nndmin : int, optional\n    The returned array will have at least ndmin dimensions. Otherwise mono-dimensional \n    axes will be squeezed.\nencoding : str, optional\n    Encoding used to decode the inputfile. The default is None.\nmax_rows : int, optional\n    Read max_rows rows of content after skiprows lines. The default is to read all the rows.\nquotechar : str, optional\n    Character used to denote the start and end of a quoted item.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\nout : ndarray\n    Data read from the text file.\n\nExamples\n--------\n>>> from io import StringIO\n>>> c = StringIO(\"0 1\\n2 3\")\n>>> np.loadtxt(c)\narray([[0., 1.],\n       [2., 3.]])\n\n>>> d = StringIO(\"M 21 72\\nF 35 58\")\n>>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n...                      'formats': ('S1', 'i4', 'f4')})\narray([(b'M', 21, 72.), (b'F', 35, 58.)],\n      dtype=[('gender', 'S1'), ('age', '<i4'), ('weight', '<f4')])\n",
      "code": "@set_module('numpy')\ndef loadtxt(fname, dtype=float, comments='#', delimiter=None,\n            converters=None, skiprows=0, usecols=None, unpack=False,\n            ndmin=0, encoding=None, max_rows=None, *, quotechar=None,\n            like=None):\n    \"\"\"\n    Load data from a text file.\n\n    Each row in the text file must have the same number of values.\n    \"\"\"\n    if like is not None:\n        return _loadtxt_with_like(\n            fname, dtype=dtype, comments=comments, delimiter=delimiter,\n            converters=converters, skiprows=skiprows, usecols=usecols,\n            unpack=unpack, ndmin=ndmin, encoding=encoding,\n            max_rows=max_rows, quotechar=quotechar, like=like\n        )\n\n    # Complex implementation delegated to _load_from_filelike\n    # and other internal functions\n    pass",
      "signature": "numpy.loadtxt(fname, dtype=<class 'float'>, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=None, max_rows=None, *, quotechar=None, like=None)"
    }
  ],
  "Numerical ranges": [
    {
      "name": "numpy.arange",
      "category": "Numerical ranges",
      "description": "Return evenly spaced values within a given interval",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.arange.html",
      "doc": "\nReturn evenly spaced values within a given interval.\n\nParameters\n----------\nstart : integer or real, optional\n    Start of interval. The interval includes this value. The default start value is 0.\nstop : integer or real\n    End of interval. The interval does not include this value, except in some cases where \n    step is not an integer and floating point round-off affects the length of out.\nstep : integer or real, optional\n    Spacing between values. For any output out, this is the distance between two adjacent \n    values, out[i+1] - out[i]. The default step size is 1.\ndtype : dtype, optional\n    The type of the output array. If dtype is not given, infer the data type from the \n    other input arguments.\ndevice : str, optional\n    Device on which to place the created array.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\narange : ndarray\n    Array of evenly spaced values.\n\nExamples\n--------\n>>> np.arange(3)\narray([0, 1, 2])\n>>> np.arange(3.0)\narray([ 0.,  1.,  2.])\n>>> np.arange(3,7)\narray([3, 4, 5, 6])\n>>> np.arange(3,7,2)\narray([3, 5])\n\nNotes\n-----\nWhen using a non-integer step, such as 0.1, it is often better to use numpy.linspace.\n",
      "code": "# numpy.arange is implemented in C as part of the multiarray module\n# Python signature:\n@array_function_dispatch(_arange_dispatcher)\ndef arange(start=None, stop=None, step=None, dtype=None, *, device=None, like=None):\n    \"\"\"\n    Return evenly spaced values within a given interval.\n    \"\"\"\n    # Implementation is in C - multiarray.arange\n    # Handles various input formats: arange(stop), arange(start, stop), arange(start, stop, step)\n    pass",
      "signature": "numpy.arange([start, ]stop, [step, ]dtype=None, *, device=None, like=None)"
    },
    {
      "name": "numpy.linspace",
      "category": "Numerical ranges",
      "description": "Return evenly spaced numbers over a specified interval",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.linspace.html",
      "doc": "\nReturn evenly spaced numbers over a specified interval.\n\nParameters\n----------\nstart : array_like\n    The starting value of the sequence.\nstop : array_like\n    The end value of the sequence, unless endpoint is set to False. In that case, the sequence \n    consists of all but the last of num + 1 evenly spaced samples, so that stop is excluded.\nnum : int, optional\n    Number of samples to generate. Default is 50. Must be non-negative.\nendpoint : bool, optional\n    If True, stop is the last sample. Otherwise, it is not included. Default is True.\nretstep : bool, optional\n    If True, return (samples, step), where step is the spacing between samples.\ndtype : dtype, optional\n    The type of the output array. If dtype is not given, the data type is inferred from \n    start and stop.\naxis : int, optional\n    The axis in the result to store the samples. Relevant only if start or stop are array-like.\ndevice : str, optional\n    Device on which to place the created array.\n\nReturns\n-------\nsamples : ndarray\n    There are num equally spaced samples in the closed interval [start, stop] or the \n    half-open interval [start, stop) (depending on whether endpoint is True or False).\nstep : float, optional\n    Only returned if retstep is True. Size of spacing between samples.\n\nExamples\n--------\n>>> np.linspace(2.0, 3.0, num=5)\narray([2.  , 2.25, 2.5 , 2.75, 3.  ])\n>>> np.linspace(2.0, 3.0, num=5, endpoint=False)\narray([2. ,  2.2,  2.4,  2.6,  2.8])\n>>> np.linspace(2.0, 3.0, num=5, retstep=True)\n(array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n",
      "code": "@array_function_dispatch(_linspace_dispatcher)\ndef linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,\n             axis=0, *, device=None):\n    \"\"\"\n    Return evenly spaced numbers over a specified interval.\n\n    Returns `num` evenly spaced samples, calculated over the\n    interval [`start`, `stop`].\n\n    The endpoint of the interval can optionally be excluded.\n    \"\"\"\n    num = operator.index(num)\n    if num < 0:\n        raise ValueError(\"Number of samples, %s, must be non-negative.\" % num)\n    div = (num - 1) if endpoint else num\n\n    # Convert float/complex array scalars to float/complex scalars\n    start = asanyarray(start) * 1.0\n    stop  = asanyarray(stop) * 1.0\n\n    dt = result_type(start, stop, float(num))\n    if dtype is None:\n        dtype = dt\n        integer_dtype = False\n    else:\n        integer_dtype = _nx.issubdtype(dtype, _nx.integer)\n\n    delta = stop - start\n\n    y = _nx.arange(0, num, dtype=dt, device=device).reshape((-1,) + (1,) * ndim(delta))\n\n    if div > 0:\n        step = delta / div\n        y = y * step\n    else:\n        step = NaN\n        # Special handling for endpoint=False and num=1\n        y = y * delta\n\n    y += start\n\n    if endpoint and num > 1:\n        y[-1, ...] = stop\n\n    if axis != 0:\n        y = _nx.moveaxis(y, 0, axis)\n\n    if integer_dtype:\n        _nx.floor(y, out=y)\n\n    y = asanyarray(y, dtype=dtype)\n\n    if retstep:\n        return y, step\n    else:\n        return y",
      "signature": "numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0, *, device=None)"
    },
    {
      "name": "numpy.logspace",
      "category": "Numerical ranges",
      "description": "Return numbers spaced evenly on a log scale",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.logspace.html",
      "doc": "\nReturn numbers spaced evenly on a log scale.\n\nParameters\n----------\nstart : array_like\n    base ** start is the starting value of the sequence.\nstop : array_like\n    base ** stop is the final value of the sequence, unless endpoint is False.\nnum : integer, optional\n    Number of samples to generate. Default is 50.\nendpoint : boolean, optional\n    If True, stop is the last sample. Otherwise, it is not included. Default is True.\nbase : array_like, optional\n    The base of the log space. The step size between the elements in ln(samples) / ln(base) \n    (or log_base(samples)) is uniform. Default is 10.0.\ndtype : dtype\n    The type of the output array. If dtype is not given, the data type is inferred from start and stop.\naxis : int, optional\n    The axis in the result to store the samples. Relevant only if start or stop are array-like.\n\nReturns\n-------\nsamples : ndarray\n    num samples, equally spaced on a log scale.\n\nExamples\n--------\n>>> np.logspace(2.0, 3.0, num=4)\narray([ 100.        ,  215.443469  ,  464.15888336, 1000.        ])\n>>> np.logspace(2.0, 3.0, num=4, endpoint=False)\narray([100.        ,  177.827941  ,  316.22776602,  562.34132519])\n>>> np.logspace(2.0, 3.0, num=4, base=2.0)\narray([4.        ,  5.0396842 ,  6.34960421,  8.        ])\n",
      "code": "@array_function_dispatch(_logspace_dispatcher)\ndef logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None,\n             axis=0):\n    \"\"\"\n    Return numbers spaced evenly on a log scale.\n\n    In linear space, the sequence starts at ``base ** start``\n    (`base` to the power of `start`) and ends with ``base ** stop``\n    (see `endpoint` below).\n    \"\"\"\n    y = linspace(start, stop, num=num, endpoint=endpoint, axis=axis)\n    if dtype is None:\n        return _nx.power(base, y)\n    return _nx.power(base, y).astype(dtype, copy=False)",
      "signature": "numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None, axis=0)"
    },
    {
      "name": "numpy.geomspace",
      "category": "Numerical ranges",
      "description": "Return numbers spaced evenly on a log scale (a geometric progression)",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.geomspace.html",
      "doc": "\nReturn numbers spaced evenly on a log scale (a geometric progression).\n\nParameters\n----------\nstart : array_like\n    The starting value of the sequence.\nstop : array_like\n    The final value of the sequence, unless endpoint is False. In that case, num + 1 values \n    are spaced over the interval in log-space, of which all but the last (a sequence of length num) are returned.\nnum : integer, optional\n    Number of samples to generate. Default is 50.\nendpoint : boolean, optional\n    If True, stop is the last sample. Otherwise, it is not included. Default is True.\ndtype : dtype\n    The type of the output array. If dtype is not given, the data type is inferred from start and stop.\naxis : int, optional\n    The axis in the result to store the samples. Relevant only if start or stop are array-like.\n\nReturns\n-------\nsamples : ndarray\n    num samples, equally spaced on a log scale.\n\nExamples\n--------\n>>> np.geomspace(1, 1000, num=4)\narray([    1.,    10.,   100.,  1000.])\n>>> np.geomspace(1, 1000, num=3, endpoint=False)\narray([   1.,   10.,  100.])\n>>> np.geomspace(1, 1000, num=4, endpoint=False)\narray([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])\n>>> np.geomspace(1, 256, num=9)\narray([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])\n\nNotes\n-----\nIf the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane.\n",
      "code": "@array_function_dispatch(_geomspace_dispatcher)\ndef geomspace(start, stop, num=50, endpoint=True, dtype=None, axis=0):\n    \"\"\"\n    Return numbers spaced evenly on a log scale (a geometric progression).\n\n    This is similar to `logspace`, but with endpoints specified directly.\n    Each output sample is a constant multiple of the previous.\n    \"\"\"\n    start = asanyarray(start)\n    stop = asanyarray(stop)\n    if _nx.any(start == 0) or _nx.any(stop == 0):\n        raise ValueError('Geometric sequence cannot include zero')\n\n    dt = result_type(start, stop, float(num), _nx.zeros((), dtype))\n    if dtype is None:\n        dtype = dt\n    else:\n        # complex to dtype('complex128') is not a downcast\n        dtype = _nx.dtype(dtype)  # Ensure dtype is a dtype object.\n\n    # Avoid negligible real or imaginary parts in output by rotating to\n    # positive real, calculating, then rotating back.\n    out_sign = _nx.sign(start)\n    if _nx.issubdtype(dt, _nx.complexfloating):\n        all_imag = (start.real == 0.) & (stop.real == 0.)\n        if _nx.any(all_imag):\n            start[all_imag] = start[all_imag].imag\n            stop[all_imag] = stop[all_imag].imag\n            out_sign[all_imag] = 1j * out_sign[all_imag]\n\n    log_start = _nx.log10(start)\n    log_stop = _nx.log10(stop)\n    result = logspace(log_start, log_stop, num=num,\n                      endpoint=endpoint, base=10.0, dtype=dtype, axis=axis)\n\n    # Make sure the endpoints match the start and stop arguments. This is\n    # necessary because np.exp(np.log(x)) is not necessarily equal to x.\n    if num > 0:\n        result[0] = start\n        if num > 1 and endpoint:\n            result[-1] = stop\n\n    result = out_sign * result\n\n    if axis != 0:\n        result = _nx.moveaxis(result, 0, axis)\n\n    return result.astype(dtype, copy=False)",
      "signature": "numpy.geomspace(start, stop, num=50, endpoint=True, dtype=None, axis=0)"
    },
    {
      "name": "numpy.meshgrid",
      "category": "Numerical ranges",
      "description": "Return a list of coordinate matrices from coordinate vectors",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html",
      "doc": "\nReturn a list of coordinate matrices from coordinate vectors.\n\nParameters\n----------\nx1, x2,..., xn : array_like\n    1-D arrays representing the coordinates of a grid.\nindexing : {'xy', 'ij'}, optional\n    Cartesian ('xy', default) or matrix ('ij') indexing of output.\nsparse : bool, optional\n    If True the shape of the returned coordinate array for dimension i is reduced from \n    (N1, ..., Ni, ... Nn) to (1, ..., Ni, ..., 1). Default is False.\ncopy : bool, optional\n    If False, a view into the original arrays are returned in order to conserve memory. \n    Default is True.\n\nReturns\n-------\nX1, X2,..., XN : list of ndarray\n    For vectors x1, x2,..., xn with lengths Ni=len(xi), returns (N1, N2, N3,..., Nn) shaped arrays \n    if indexing='ij' or (N2, N1, N3,..., Nn) shaped arrays if indexing='xy' with the elements of xi \n    repeated to fill the matrix along the first dimension for x1, the second for x2 and so on.\n\nExamples\n--------\n>>> nx, ny = (3, 2)\n>>> x = np.linspace(0, 1, nx)\n>>> y = np.linspace(0, 1, ny)\n>>> xv, yv = np.meshgrid(x, y)\n>>> xv\narray([[0. , 0.5, 1. ],\n       [0. , 0.5, 1. ]])\n>>> yv\narray([[0.,  0.,  0.],\n       [1.,  1.,  1.]])\n\nNotes\n-----\nIn the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for 'xy' \nindexing and (M, N) for 'ij' indexing.\n",
      "code": "@array_function_dispatch(_meshgrid_dispatcher)\ndef meshgrid(*xi, copy=True, sparse=False, indexing='xy'):\n    \"\"\"\n    Return a list of coordinate matrices from coordinate vectors.\n\n    Make N-D coordinate arrays for vectorized evaluations of\n    N-D scalar/vector fields over N-D grids, given\n    one-dimensional coordinate arrays x1, x2,..., xn.\n    \"\"\"\n    ndim = len(xi)\n\n    if indexing not in ['xy', 'ij']:\n        raise ValueError(\n            \"Valid values for `indexing` are 'xy' and 'ij'.\")\n\n    s0 = (1,) * ndim\n    output = [_nx.asanyarray(x).reshape(s0[:i] + (-1,) + s0[i + 1:])\n              for i, x in enumerate(xi)]\n\n    if indexing == 'xy' and ndim > 1:\n        # switch first and second axis\n        output[0].shape = (1, -1) + (1,) * (ndim - 2)\n        output[1].shape = (-1, 1) + (1,) * (ndim - 2)\n\n    if not sparse:\n        # Return the full N-D matrix (not only the 1-D vector)\n        output = _nx.broadcast_arrays(*output, subok=True)\n\n    if copy:\n        output = [x.copy() for x in output]\n\n    return output",
      "signature": "numpy.meshgrid(*xi, copy=True, sparse=False, indexing='xy')"
    },
    {
      "name": "numpy.mgrid",
      "category": "Numerical ranges",
      "description": "An instance which returns a dense multi-dimensional meshgrid",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.mgrid.html",
      "doc": "\nAn instance which returns a dense multi-dimensional \"meshgrid\".\n\nAn instance of numpy.lib.ndmgr.MGridClass which, when indexed, returns a dense multi-dimensional meshgrid.\n\nParameters\n----------\n[slice1, slice2, ..., sliceN] : slice objects or integers\n    If the input is a slice, the syntax start:stop:step is equivalent to np.arange(start, stop, step) \n    inside of the brackets. If the input is an integer, the syntax i is equivalent to np.arange(i)+1.\n\nReturns\n-------\nout : one ndarray or tuple of ndarrays\n    If only one slice is passed, returns an array. If multiple slices are passed, returns a tuple \n    of arrays with one array for each dimension.\n\nExamples\n--------\n>>> np.mgrid[0:5, 0:5]\narray([[[0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1],\n        [2, 2, 2, 2, 2],\n        [3, 3, 3, 3, 3],\n        [4, 4, 4, 4, 4]],\n       [[0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4]]])\n\n>>> np.mgrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])\n",
      "code": "# numpy.mgrid is an instance of MGridClass\n# Implementation in numpy/lib/ndmgr.py\nmgrid = MGridClass()\n\nclass MGridClass(nd_grid):\n    \"\"\"\n    An instance which returns a dense multi-dimensional \"meshgrid\".\n    \n    An instance of `numpy.lib.ndmgr.MGridClass` which, when indexed, returns a\n    dense multi-dimensional meshgrid.\n    \"\"\"\n    def __init__(self):\n        super().__init__(sparse=False)\n\n    def __getitem__(self, key):\n        # Complex implementation that handles slice notation\n        # Returns dense meshgrid arrays\n        pass",
      "signature": "numpy.mgrid = <numpy.lib.ndmgr.MGridClass object>"
    },
    {
      "name": "numpy.ogrid",
      "category": "Numerical ranges",
      "description": "An instance which returns an open multi-dimensional meshgrid",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.ogrid.html",
      "doc": "\nAn instance which returns an open multi-dimensional \"meshgrid\".\n\nAn instance of numpy.lib.ndmgr.OGridClass which, when indexed, returns an open multi-dimensional meshgrid.\n\nParameters\n----------\n[slice1, slice2, ..., sliceN] : slice objects or integers\n    If the input is a slice, the syntax start:stop:step is equivalent to np.arange(start, stop, step) \n    inside of the brackets. If the input is an integer, the syntax i is equivalent to np.arange(i)+1.\n\nReturns\n-------\nout : one ndarray or tuple of ndarrays\n    If only one slice is passed, returns an array. If multiple slices are passed, returns a tuple \n    of arrays with only one non-unit dimension each.\n\nExamples\n--------\n>>> from numpy import ogrid\n>>> ogrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])\n\n>>> ogrid[0:5, 0:5]\n[array([[0],\n        [1],\n        [2],\n        [3],\n        [4]]), \n array([[0, 1, 2, 3, 4]])]\n\nNotes\n-----\nThe multi-dimensional \"mesh\" is open, which means that only one dimension of each returned \nargument is greater than 1. The output of ogrid is an open mesh of arrays that can be used \nfor broadcasting.\n",
      "code": "# numpy.ogrid is an instance of OGridClass\n# Implementation in numpy/lib/ndmgr.py\nogrid = OGridClass()\n\nclass OGridClass(nd_grid):\n    \"\"\"\n    An instance which returns an open multi-dimensional \"meshgrid\".\n    \n    An instance of `numpy.lib.ndmgr.OGridClass` which, when indexed, returns an\n    open (i.e. not fleshed out) mesh-grid.\n    \"\"\"\n    def __init__(self):\n        super().__init__(sparse=True)\n\n    def __getitem__(self, key):\n        # Complex implementation that handles slice notation\n        # Returns sparse/open meshgrid arrays\n        pass",
      "signature": "numpy.ogrid = <numpy.lib.ndmgr.OGridClass object>"
    }
  ],
  "Building matrices": [
    {
      "name": "numpy.diag",
      "category": "Building matrices",
      "description": "Extract a diagonal or construct a diagonal array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.diag.html",
      "doc": "\nExtract a diagonal or construct a diagonal array.\n\nParameters\n----------\nv : array_like\n    If v is a 2-D array, return a copy of its k-th diagonal. If v is a 1-D array, \n    return a 2-D array with v on the k-th diagonal.\nk : int, optional\n    Diagonal in question. The default is 0. Use k>0 for diagonals above the main diagonal, \n    and k<0 for diagonals below the main diagonal.\n\nReturns\n-------\nout : ndarray\n    The extracted diagonal or constructed diagonal array.\n\nExamples\n--------\n>>> x = np.arange(9).reshape((3,3))\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n>>> np.diag(x)\narray([0, 4, 8])\n>>> np.diag(x, k=1)\narray([1, 5])\n>>> np.diag(x, k=-1)\narray([3, 7])\n\n>>> np.diag(np.diag(x))\narray([[0, 0, 0],\n       [0, 4, 0],\n       [0, 0, 8]])\n",
      "code": "@array_function_dispatch(_diag_dispatcher)\ndef diag(v, k=0):\n    \"\"\"\n    Extract a diagonal or construct a diagonal array.\n\n    See the more detailed documentation for ``numpy.diagonal`` if you use this\n    function to extract a diagonal and wish to write to the resulting array;\n    whether it returns a copy or a view depends on what version of numpy you\n    are using.\n    \"\"\"\n    v = asanyarray(v)\n    s = v.shape\n    if len(s) == 1:\n        n = s[0]+abs(k)\n        res = zeros((n, n), v.dtype)\n        if k >= 0:\n            i = k\n        else:\n            i = (-k) * n\n        res[:n-k].flat[i::n+1] = v\n        return res\n    elif len(s) == 2:\n        return diagonal(v, k)\n    else:\n        raise ValueError(\"Input must be 1- or 2-d.\")",
      "signature": "numpy.diag(v, k=0)"
    },
    {
      "name": "numpy.diagflat",
      "category": "Building matrices",
      "description": "Create a two-dimensional array with the flattened input as a diagonal",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.diagflat.html",
      "doc": "\nCreate a two-dimensional array with the flattened input as a diagonal.\n\nParameters\n----------\nv : array_like\n    Input data, which is flattened and set as the k-th diagonal of the output.\nk : int, optional\n    Diagonal to set; 0, the default, corresponds to the \"main\" diagonal, a positive \n    (negative) k giving the number of the diagonal above (below) the main.\n\nReturns\n-------\nout : ndarray\n    The 2-D output array.\n\nExamples\n--------\n>>> np.diagflat([[1,2], [3,4]])\narray([[1, 0, 0, 0],\n       [0, 2, 0, 0],\n       [0, 0, 3, 0],\n       [0, 0, 0, 4]])\n\n>>> np.diagflat([1,2], 1)\narray([[0, 1, 0],\n       [0, 0, 2],\n       [0, 0, 0]])\n",
      "code": "@array_function_dispatch(_diagflat_dispatcher)\ndef diagflat(v, k=0):\n    \"\"\"\n    Create a two-dimensional array with the flattened input as a diagonal.\n    \"\"\"\n    try:\n        wrap = v.__array_wrap__\n    except AttributeError:\n        wrap = None\n    v = asarray(v).ravel()\n    s = len(v)\n    n = s + abs(k)\n    res = zeros((n, n), v.dtype)\n    if (k >= 0):\n        i = arange(0, n-k, dtype=intp)\n        fi = i+k+i*n\n    else:\n        i = arange(0, n+k, dtype=intp)\n        fi = i+(i-k)*n\n    res.flat[fi] = v\n    if not wrap:\n        return res\n    return wrap(res)",
      "signature": "numpy.diagflat(v, k=0)"
    },
    {
      "name": "numpy.tri",
      "category": "Building matrices",
      "description": "An array with ones at and below the given diagonal and zeros elsewhere",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.tri.html",
      "doc": "\nAn array with ones at and below the given diagonal and zeros elsewhere.\n\nParameters\n----------\nN : int\n    Number of rows in the array.\nM : int, optional\n    Number of columns in the array. By default, M is taken equal to N.\nk : int, optional\n    The sub-diagonal at and below which the array is filled. k = 0 is the main diagonal, \n    while k < 0 is below it, and k > 0 is above. The default is 0.\ndtype : dtype, optional\n    Data type of the returned array. The default is float.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not NumPy arrays.\n\nReturns\n-------\ntri : ndarray of shape (N, M)\n    Array with its lower triangle filled with ones and zero elsewhere; in other words \n    T[i,j] == 1 for j <= i + k, 0 otherwise.\n\nExamples\n--------\n>>> np.tri(3, 5, 2, dtype=int)\narray([[1, 1, 1, 0, 0],\n       [1, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1]])\n\n>>> np.tri(3, 5, -1)\narray([[0.,  0.,  0.,  0.,  0.],\n       [1.,  0.,  0.,  0.,  0.],\n       [1.,  1.,  0.,  0.,  0.]])\n",
      "code": "@set_array_function_like_doc\n@set_module('numpy')\ndef tri(N, M=None, k=0, dtype=float, *, like=None):\n    \"\"\"\n    An array with ones at and below the given diagonal and zeros elsewhere.\n    \"\"\"\n    if like is not None:\n        return _tri_with_like(like, N, M=M, k=k, dtype=dtype)\n\n    if M is None:\n        M = N\n\n    m = greater_equal.outer(arange(N, dtype=_nx.intp),\n                            arange(-k, M-k, dtype=_nx.intp))\n\n    # Avoid making a copy if the requested type is already bool\n    m = m.astype(dtype, copy=False)\n\n    return m",
      "signature": "numpy.tri(N, M=None, k=0, dtype=<class 'float'>, *, like=None)"
    },
    {
      "name": "numpy.tril",
      "category": "Building matrices",
      "description": "Lower triangle of an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.tril.html",
      "doc": "\nLower triangle of an array.\n\nReturn a copy of an array with elements above the k-th diagonal zeroed. For arrays with \nndim exceeding 2, tril will apply to the final two axes.\n\nParameters\n----------\nm : array_like, shape (..., M, N)\n    Input array.\nk : int, optional\n    Diagonal above which to zero elements. k = 0 (the default) is the main diagonal, \n    k < 0 is below it and k > 0 is above.\n\nReturns\n-------\ntril : ndarray, shape (..., M, N)\n    Lower triangle of m, of same shape and data-type as m.\n\nExamples\n--------\n>>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 0,  0,  0],\n       [ 4,  0,  0],\n       [ 7,  8,  0],\n       [10, 11, 12]])\n\n>>> np.tril(np.arange(3*4*5).reshape(3, 4, 5))[:,:,::2]\narray([[[ 0,  0,  0],\n        [ 5,  0,  0],\n        [10, 11,  0],\n        [15, 16, 17]],\n       [[20,  0,  0],\n        [25, 26,  0],\n        [30, 31, 32],\n        [35, 36, 37]],\n       [[40,  0,  0],\n        [45, 46,  0],\n        [50, 51, 52],\n        [55, 56, 57]]])\n",
      "code": "@array_function_dispatch(_trilu_dispatcher)\ndef tril(m, k=0):\n    \"\"\"\n    Lower triangle of an array.\n\n    Return a copy of an array with elements above the `k`-th diagonal zeroed.\n    For arrays with ``ndim`` exceeding 2, `tril` will apply to the final two\n    axes.\n    \"\"\"\n    m = asanyarray(m)\n    mask = tri(*m.shape[-2:], k=k, dtype=bool)\n\n    return where(mask, m, zeros(1, m.dtype))",
      "signature": "numpy.tril(m, k=0)"
    },
    {
      "name": "numpy.triu",
      "category": "Building matrices",
      "description": "Upper triangle of an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.triu.html",
      "doc": "\nUpper triangle of an array.\n\nReturn a copy of an array with the elements below the k-th diagonal zeroed. For arrays \nwith ndim exceeding 2, triu will apply to the final two axes.\n\nParameters\n----------\nm : array_like, shape (..., M, N)\n    Input array.\nk : int, optional\n    Diagonal below which to zero elements. k = 0 (the default) is the main diagonal, \n    k < 0 is below it and k > 0 is above.\n\nReturns\n-------\ntriu : ndarray, shape (..., M, N)\n    Upper triangle of m, of same shape and data-type as m.\n\nExamples\n--------\n>>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 0,  8,  9],\n       [ 0,  0, 12]])\n\n>>> np.triu(np.arange(3*4*5).reshape(3, 4, 5))[:,:,::2]\narray([[[ 0,  2,  4],\n        [ 0,  7,  9],\n        [ 0,  0, 14],\n        [ 0,  0,  0]],\n       [[20, 22, 24],\n        [ 0, 27, 29],\n        [ 0,  0, 34],\n        [ 0,  0,  0]],\n       [[40, 42, 44],\n        [ 0, 47, 49],\n        [ 0,  0, 54],\n        [ 0,  0,  0]]])\n",
      "code": "@array_function_dispatch(_trilu_dispatcher)\ndef triu(m, k=0):\n    \"\"\"\n    Upper triangle of an array.\n\n    Return a copy of an array with the elements below the `k`-th diagonal\n    zeroed. For arrays with ``ndim`` exceeding 2, `triu` will apply to the\n    final two axes.\n    \"\"\"\n    m = asanyarray(m)\n    mask = tri(*m.shape[-2:], k=k-1, dtype=bool)\n\n    return where(mask, zeros(1, m.dtype), m)",
      "signature": "numpy.triu(m, k=0)"
    },
    {
      "name": "numpy.vander",
      "category": "Building matrices",
      "description": "Generate a Vandermonde matrix",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.vander.html",
      "doc": "\nGenerate a Vandermonde matrix.\n\nParameters\n----------\nx : array_like\n    1-D input array.\nN : int, optional\n    Number of columns in the output. If N is not specified, a square array is returned (N = len(x)).\nincreasing : bool, optional\n    Order of the powers of the columns. If True, the powers increase from left to right, \n    if False (the default) they are reversed.\n\nReturns\n-------\nout : ndarray\n    Vandermonde matrix. If increasing is False, the first column is x^(N-1), the second x^(N-2) \n    and so forth. If increasing is True, the columns are x^0, x^1, ..., x^(N-1).\n\nExamples\n--------\n>>> x = np.array([1, 2, 3, 5])\n>>> N = 3\n>>> np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n>>> np.column_stack([x**(N-1-i) for i in range(N)])\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n>>> x = np.array([1, 2, 3, 5])\n>>> np.vander(x)\narray([[  1,   1,   1,   1],\n       [  8,   4,   2,   1],\n       [ 27,   9,   3,   1],\n       [125,  25,   5,   1]])\n>>> np.vander(x, increasing=True)\narray([[  1,   1,   1,   1],\n       [  1,   2,   4,   8],\n       [  1,   3,   9,  27],\n       [  1,   5,  25, 125]])\n",
      "code": "@array_function_dispatch(_vander_dispatcher)\ndef vander(x, N=None, increasing=False):\n    \"\"\"\n    Generate a Vandermonde matrix.\n\n    The columns of the output matrix are powers of the input vector. The\n    order of the powers is determined by the `increasing` boolean argument.\n    Specifically, when `increasing` is False, the `i`-th output column is\n    the input vector raised element-wise to the power of ``N - i - 1``. Such\n    a matrix with a geometric progression in each row is named for Alexandre-\n    Theophile Vandermonde.\n    \"\"\"\n    x = asarray(x)\n    if x.ndim != 1:\n        raise ValueError(\"x must be a one-dimensional array or sequence.\")\n    if N is None:\n        N = len(x)\n\n    v = empty((len(x), N), dtype=promote_types(x.dtype, int))\n    tmp = v[:, ::-1] if not increasing else v\n\n    if N > 0:\n        tmp[:, 0] = 1\n    if N > 1:\n        tmp[:, 1:] = x[:, None]\n        multiply.accumulate(tmp[:, 1:], out=tmp[:, 1:], axis=1)\n\n    return v",
      "signature": "numpy.vander(x, N=None, increasing=False)"
    },
    {
      "name": "numpy.bmat",
      "category": "Building matrices",
      "description": "Build a matrix object from a string, nested sequence, or array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.bmat.html",
      "doc": "\nBuild a matrix object from a string, nested sequence, or array.\n\nParameters\n----------\nobj : str or array_like\n    Input data. If a string, variables in the current scope may be referenced by name.\nldict : dict, optional\n    A dictionary that replaces local operands in current frame. Ignored if obj is not a string or gdict is None.\ngdict : dict, optional\n    A dictionary that replaces global operands in current frame. Ignored if obj is not a string.\n\nReturns\n-------\nout : matrix\n    Returns a matrix object, which is a specialized 2-D array.\n\nExamples\n--------\n>>> A = np.asmatrix('1 1; 1 1')\n>>> B = np.asmatrix('2 2; 2 2')\n>>> C = np.asmatrix('3 4; 5 6')\n>>> D = np.asmatrix('7 8; 9 0')\n\nBuild a block matrix from nested lists:\n>>> np.bmat([[A, B], [C, D]])\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n\n>>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n\n>>> np.bmat('A,B; C,D')\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n\nSee Also\n--------\nnumpy.block : A generalization of this function for N-d arrays, that returns normal ndarrays.\n\nNotes\n-----\nAll the input arrays must have the same number of dimensions, but row and column sizes only need to be compatible. \n",
      "code": "@set_module('numpy')\ndef bmat(obj, ldict=None, gdict=None):\n    \"\"\"\n    Build a matrix object from a string, nested sequence, or array.\n    \"\"\"\n    if isinstance(obj, str):\n        if gdict is None:\n            # get previous frame\n            frame = sys._getframe().f_back\n            glob_dict = frame.f_globals\n            loc_dict = frame.f_locals\n        else:\n            glob_dict = gdict\n            loc_dict = ldict\n\n        return matrix(_from_string(obj, glob_dict, loc_dict))\n\n    if isinstance(obj, (tuple, list)):\n        # [[A,B],[C,D]]\n        arr_rows = []\n        for row in obj:\n            if isinstance(row, ndarray):  # not 2-d\n                return matrix(concatenate(obj, axis=-1))\n            else:\n                arr_rows.append(concatenate(row, axis=-1))\n        return matrix(concatenate(arr_rows, axis=0))\n\n    if isinstance(obj, ndarray):\n        return matrix(obj)\n\n    return matrix(obj)",
      "signature": "numpy.bmat(obj, ldict=None, gdict=None)"
    }
  ]
}