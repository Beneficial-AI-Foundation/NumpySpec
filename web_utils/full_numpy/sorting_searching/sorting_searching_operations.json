{
  "metadata": {
    "module": "numpy sorting, searching, and counting operations",
    "description": "NumPy operations for sorting arrays, searching for elements, and counting values",
    "source_locations": {
      "python": [
        "numpy/_core/fromnumeric.py",
        "numpy/_core/numeric.py"
      ],
      "c": [
        "numpy/_core/src/multiarray/item_selection.c",
        "numpy/_core/src/multiarray/methods.c",
        "numpy/_core/src/npysort/"
      ]
    },
    "sorting_algorithms": {
      "quicksort": "Introsort (introspective sort) - default algorithm",
      "mergesort": "Timsort - stable sort with better performance on partially sorted data",
      "heapsort": "Guaranteed O(n log n) worst case",
      "stable": "Chooses best stable sorting algorithm automatically"
    }
  },
  "functions": [
    {
      "name": "numpy.sort",
      "category": "Sorting",
      "description": "Return a sorted copy of an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.sort.html",
      "doc": "Return a sorted copy of an array.\n\nParameters\n----------\na : array_like\n    Array to be sorted.\naxis : int or None, optional\n    Axis along which to sort. If None, the array is flattened before\n    sorting. The default is -1, which sorts along the last axis.\nkind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n    Sorting algorithm. The default is 'quicksort'. Note that both 'stable'\n    and 'mergesort' use timsort under the covers and, in general, the actual\n    implementation will vary with datatype.\norder : str or list of str, optional\n    When `a` is an array with fields defined, this argument specifies\n    which fields to compare first, second, etc.\nstable : bool, optional\n    Sort stability. If ``True``, the returned array will maintain\n    the relative order of ``a`` values which compare as equal.\n\nReturns\n-------\nsorted_array : ndarray\n    Array of the same type and shape as `a`.",
      "code": "@array_function_dispatch(_sort_dispatcher)\ndef sort(a, axis=-1, kind=None, order=None, *, stable=None):\n    \"\"\"\n    Return a sorted copy of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n    axis : int or None, optional\n        Axis along which to sort. If None, the array is flattened before\n        sorting. The default is -1, which sorts along the last axis.\n    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'\n        and 'mergesort' use timsort under the covers and, in general, the actual\n        implementation will vary with datatype. The 'mergesort' option\n        is retained for backwards compatibility.\n\n        .. versionchanged:: 1.15.0\n           The 'stable' option was added.\n\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc. A single field can\n        be specified as a string, and not all fields need be specified,\n        but unspecified fields will still be used, in the order in which\n        they come up in the dtype, to break ties.\n    stable : bool, optional\n        Sort stability. If ``True``, the returned array will maintain\n        the relative order of ``a`` values which compare as equal.\n        If ``False`` or ``None``, this is not guaranteed. Internally,\n        this option selects ``kind='stable'``. Default: ``None``.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    sorted_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    ndarray.sort : Method to sort an array in-place.\n    argsort : Indirect sort.\n    lexsort : Indirect stable sort on multiple keys.\n    searchsorted : Find elements in a sorted array.\n    partition : Partial sort.\n\n    \"\"\"\n    if axis is None:\n        # flatten returns (1, N) for np.matrix, so always use the last axis\n        a = asanyarray(a).flatten()\n        axis = -1\n    else:\n        a = asanyarray(a).copy(order=\"K\")\n    a.sort(axis=axis, kind=kind, order=order, stable=stable)\n    return a"
    },
    {
      "name": "numpy.argsort",
      "category": "Sorting",
      "description": "Returns the indices that would sort an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.argsort.html",
      "doc": "Returns the indices that would sort an array.\n\nPerform an indirect sort along the given axis using the algorithm specified\nby the `kind` keyword. It returns an array of indices of the same shape as\n`a` that index data along the given axis in sorted order.\n\nParameters\n----------\na : array_like\n    Array to sort.\naxis : int or None, optional\n    Axis along which to sort. The default is -1 (the last axis). If None,\n    the flattened array is used.\nkind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n    Sorting algorithm. The default is 'quicksort'.\norder : str or list of str, optional\n    When `a` is an array with fields defined, this argument specifies\n    which fields to compare first, second, etc.\nstable : bool, optional\n    Sort stability. If ``True``, the returned array will maintain\n    the relative order of ``a`` values which compare as equal.\n\nReturns\n-------\nindex_array : ndarray, int\n    Array of indices that sort `a` along the specified `axis`.\n    If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.\n    More generally, ``take_along_axis(a, index_array, axis=axis)``\n    always yields the sorted `a`, irrespective of dimensionality.",
      "code": "@array_function_dispatch(_argsort_dispatcher)\ndef argsort(a, axis=-1, kind=None, order=None, *, stable=None):\n    \"\"\"\n    Returns the indices that would sort an array.\n\n    Perform an indirect sort along the given axis using the algorithm specified\n    by the `kind` keyword. It returns an array of indices of the same shape as\n    `a` that index data along the given axis in sorted order.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to sort.\n    axis : int or None, optional\n        Axis along which to sort. The default is -1 (the last axis). If None,\n        the flattened array is used.\n    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'\n        and 'mergesort' use timsort or radix sort under the covers and, in general,\n        the actual implementation will vary with data type. The 'mergesort' option\n        is retained for backwards compatibility.\n\n        .. versionchanged:: 1.15.0.\n           The 'stable' option was added.\n\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc. A single field can\n        be specified as a string, and not all fields need be specified,\n        but unspecified fields will still be used, in the order in which\n        they come up in the dtype, to break ties.\n    stable : bool, optional\n        Sort stability. If ``True``, the returned array will maintain\n        the relative order of ``a`` values which compare as equal.\n        If ``False`` or ``None``, this is not guaranteed. Internally,\n        this option selects ``kind='stable'``. Default: ``None``.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    index_array : ndarray, int\n        Array of indices that sort `a` along the specified `axis`.\n        If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.\n        More generally, ``take_along_axis(a, index_array, axis=axis)``\n        always yields the sorted `a`, irrespective of dimensionality.\n\n    See Also\n    --------\n    sort : Describes sorting algorithms used.\n    lexsort : Indirect stable sort with multiple keys.\n    ndarray.sort : Inplace sort.\n    argpartition : Indirect partial sort.\n    take_along_axis : Apply ``index_array`` from argsort\n                      to an array as if by calling sort.\n\n    \"\"\"\n    return _wrapfunc(a, 'argsort', axis=axis, kind=kind, order=order,\n                     stable=stable)"
    },
    {
      "name": "numpy.lexsort",
      "category": "Sorting",
      "description": "Perform an indirect stable sort using a sequence of keys",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.lexsort.html",
      "doc": "Perform an indirect stable sort using a sequence of keys.\n\nGiven multiple sorting keys, which can be interpreted as columns in a\nspreadsheet, lexsort returns an array of integer indices that describes\nthe sort order by multiple columns. The last key in the sequence is used\nfor the primary sort order, ties are broken by the second-to-last key,\nand so on.\n\nParameters\n----------\nkeys : (k, N) array or tuple containing k (N,)-shaped sequences\n    The `k` different \"columns\" to be sorted. The last column (or row if\n    `keys` is a 2D array) is the primary sort key.\naxis : int, optional\n    Axis to be indirectly sorted. By default, sort over the last axis.\n\nReturns\n-------\nindices : (N,) ndarray of ints\n    Array of indices that sort the keys along the specified axis.\n\nNote\n----\nThe Numpy lexsort function treats keys as column vectors and sorts by the last key\n(primary key) first. This can be counterintuitive coming from other languages.",
      "code": "# C implementation for performance\n# Perform an indirect stable sort using a sequence of keys\n#\n# This function is implemented in C as part of NumPy's core multiarray module.\n# The C implementation provides:\n# - Optimized memory access patterns\n# - Efficient array manipulation\n# - Low-level control over data layout\n# - Integration with NumPy's array object internals\n#\n# Source: C implementation in numpy/_core/src/multiarray/item_selection.c:\nPyArray_LexSort - performs lexicographic sorting by iteratively sorting by each key"
    },
    {
      "name": "numpy.partition",
      "category": "Sorting",
      "description": "Return a partitioned copy of an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.partition.html",
      "doc": "Return a partitioned copy of an array.\n\nCreates a copy of the array with its elements rearranged in such a way that\nthe value of the element in k-th position is in the position it would be in\na sorted array. All elements smaller than the k-th element are moved before\nthis element and all equal or greater are moved behind it. The ordering of\nthe elements in the two partitions is undefined.\n\nParameters\n----------\na : array_like\n    Array to be sorted.\nkth : int or sequence of ints\n    Element index to partition by. The k-th value of the element will be in\n    its final sorted position and all smaller elements will be moved before it\n    and all equal or greater elements behind it. The order of all elements in\n    the partitions is undefined. If provided with a sequence of k-th it will\n    partition all elements indexed by k-th of them into their sorted position\n    at once.\naxis : int or None, optional\n    Axis along which to sort. If None, the array is flattened before sorting.\n    The default is -1, which sorts along the last axis.\nkind : {'introselect'}, optional\n    Selection algorithm. Default is 'introselect'.\norder : str or list of str, optional\n    When `a` is an array with fields defined, this argument specifies which\n    fields to compare first, second, etc.\n\nReturns\n-------\npartitioned_array : ndarray\n    Array of the same type and shape as `a`.",
      "code": "@array_function_dispatch(_partition_dispatcher)\ndef partition(a, kth, axis=-1, kind='introselect', order=None):\n    \"\"\"\n    Return a partitioned copy of an array.\n\n    Creates a copy of the array with its elements rearranged in such a way that\n    the value of the element in k-th position is in the position it would be in\n    a sorted array. All elements smaller than the k-th element are moved before\n    this element and all equal or greater are moved behind it. The ordering of\n    the elements in the two partitions is undefined.\n\n    .. versionadded:: 1.8.0\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n    kth : int or sequence of ints\n        Element index to partition by. The k-th value of the element will be in\n        its final sorted position and all smaller elements will be moved before it\n        and all equal or greater elements behind it. The order of all elements in\n        the partitions is undefined. If provided with a sequence of k-th it will\n        partition all elements indexed by k-th of them into their sorted position\n        at once.\n    axis : int or None, optional\n        Axis along which to sort. If None, the array is flattened before sorting.\n        The default is -1, which sorts along the last axis.\n    kind : {'introselect'}, optional\n        Selection algorithm. Default is 'introselect'.\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument specifies which\n        fields to compare first, second, etc. A single field can be specified\n        as a string. Not all fields need be specified, but unspecified fields\n        will still be used, in the order in which they come up in the dtype,\n        to break ties.\n\n    Returns\n    -------\n    partitioned_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    ndarray.partition : Method to sort an array in-place.\n    argpartition : Indirect partition.\n    sort : Full sorting\n\n    \"\"\"\n    if axis is None:\n        # flatten returns (1, N) for np.matrix, so always use the last axis\n        a = asanyarray(a).flatten()\n        axis = -1\n    else:\n        a = asanyarray(a).copy(order=\"K\")\n    a.partition(kth, axis=axis, kind=kind, order=order)\n    return a"
    },
    {
      "name": "numpy.argpartition",
      "category": "Sorting",
      "description": "Perform an indirect partition along the given axis",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.argpartition.html",
      "doc": "Perform an indirect partition along the given axis using the algorithm\nspecified by the `kind` keyword. It returns an array of indices of the\nsame shape as `a` that index data along the given axis in partitioned\norder.\n\nParameters\n----------\na : array_like\n    Array to sort.\nkth : int or sequence of ints\n    Element index to partition by. The k-th element will be in its final\n    sorted position and all smaller elements will be moved before it and\n    all larger elements behind it. The order all elements in the partitions\n    is undefined. If provided with a sequence of k-th it will partition all\n    of them into their sorted position at once.\naxis : int or None, optional\n    Axis along which to sort. The default is -1 (the last axis). If None,\n    the flattened array is used.\nkind : {'introselect'}, optional\n    Selection algorithm. Default is 'introselect'\norder : str or list of str, optional\n    When `a` is an array with fields defined, this argument specifies which\n    fields to compare first, second, etc.\n\nReturns\n-------\nindex_array : ndarray, int\n    Array of indices that partition `a` along the specified axis.\n    If `a` is one-dimensional, ``a[index_array]`` yields a partitioned `a`.\n    More generally, ``take_along_axis(a, index_array, axis=axis)``\n    always yields the partitioned `a`, irrespective of dimensionality.",
      "code": "@array_function_dispatch(_argpartition_dispatcher)\ndef argpartition(a, kth, axis=-1, kind='introselect', order=None):\n    \"\"\"\n    Perform an indirect partition along the given axis using the\n    algorithm specified by the `kind` keyword. It returns an array of\n    indices of the same shape as `a` that index data along the given\n    axis in partitioned order.\n\n    .. versionadded:: 1.8.0\n\n    Parameters\n    ----------\n    a : array_like\n        Array to sort.\n    kth : int or sequence of ints\n        Element index to partition by. The k-th element will be in its\n        final sorted position and all smaller elements will be moved\n        before it and all larger elements behind it. The order all\n        elements in the partitions is undefined. If provided with a\n        sequence of k-th it will partition all of them into their sorted\n        position at once.\n    axis : int or None, optional\n        Axis along which to sort. The default is -1 (the last axis). If\n        None, the flattened array is used.\n    kind : {'introselect'}, optional\n        Selection algorithm. Default is 'introselect'\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument\n        specifies which fields to compare first, second, etc. A single\n        field can be specified as a string. Not all fields need be\n        specified, but unspecified fields will still be used, in the\n        order in which they come up in the dtype, to break ties.\n\n    Returns\n    -------\n    index_array : ndarray, int\n        Array of indices that partition `a` along the specified axis.\n        If `a` is one-dimensional, ``a[index_array]`` yields a\n        partitioned `a`. More generally,\n        ``take_along_axis(a, index_array, axis=axis)`` always yields\n        the partitioned `a`, irrespective of dimensionality.\n\n    See Also\n    --------\n    partition : Describes partition algorithms used.\n    ndarray.partition : Inplace partition.\n    argsort : Full indirect sort.\n    take_along_axis : Apply ``index_array`` from argpartition\n                      to an array as if by calling partition.\n\n    \"\"\"\n    return _wrapfunc(a, 'argpartition', kth, axis=axis, kind=kind,\n                     order=order)"
    },
    {
      "name": "numpy.searchsorted",
      "category": "Searching",
      "description": "Find indices where elements should be inserted to maintain order",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.searchsorted.html",
      "doc": "Find indices where elements should be inserted to maintain order.\n\nFind the indices into a sorted array `a` such that, if the corresponding\nelements in `v` were inserted before the indices, the order of `a` would\nbe preserved.\n\nAssuming that `a` is sorted:\n\n======  ============================\n`side`  returned index `i` satisfies\n======  ============================\nleft    ``a[i-1] < v <= a[i]``\nright   ``a[i-1] <= v < a[i]``\n======  ============================\n\nParameters\n----------\na : 1-D array_like\n    Input array. If `sorter` is None, then it must be sorted in\n    ascending order, otherwise `sorter` can be used to sort it.\nv : array_like\n    Values to insert into `a`.\nside : {'left', 'right'}, optional\n    If 'left', the index of the first suitable location found is given.\n    If 'right', return the last such index. If there is no suitable\n    index, return either 0 or N (where N is the length of `a`).\nsorter : 1-D array_like, optional\n    Optional array of integer indices that sort array a into ascending\n    order. They are typically the result of argsort.\n\nReturns\n-------\nindices : int or array of ints\n    Array of insertion points with the same shape as `v`,\n    or an integer if `v` is a scalar.",
      "code": "@array_function_dispatch(_searchsorted_dispatcher)\ndef searchsorted(a, v, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `a` such that, if the\n    corresponding elements in `v` were inserted before the indices, the\n    order of `a` would be preserved.\n\n    Assuming that `a` is sorted:\n\n    ======  ============================\n    `side`  returned index `i` satisfies\n    ======  ============================\n    left    ``a[i-1] < v <= a[i]``\n    right   ``a[i-1] <= v < a[i]``\n    ======  ============================\n\n    Parameters\n    ----------\n    a : 1-D array_like\n        Input array. If `sorter` is None, then it must be sorted in\n        ascending order, otherwise `sorter` can be used to sort it.\n    v : array_like\n        Values to insert into `a`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index. If there is no suitable\n        index, return either 0 or N (where N is the length of `a`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort array a into ascending\n        order. They are typically the result of argsort.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    indices : int or array of ints\n        Array of insertion points with the same shape as `v`,\n        or an integer if `v` is a scalar.\n\n    See Also\n    --------\n    sort : Return a sorted copy of an array.\n    histogram : Produce histogram from 1-D data.\n\n    Notes\n    -----\n    Binary search is used to find the required insertion points.\n\n    As of NumPy 1.4.0 `searchsorted` works with real/complex arrays containing\n    `nan` values. The enhanced sort order is documented in `sort`.\n\n    This function uses the same algorithm as the builtin python `bisect.bisect_left`\n    (``side='left'``) and `bisect.bisect_right` (``side='right'``) functions,\n    which is also vectorized in the `v` argument.\n\n    \"\"\"\n    return _wrapfunc(a, 'searchsorted', v, side=side, sorter=sorter)"
    },
    {
      "name": "numpy.argmax",
      "category": "Searching",
      "description": "Returns the indices of the maximum values along an axis",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.argmax.html",
      "doc": "Returns the indices of the maximum values along an axis.\n\nParameters\n----------\na : array_like\n    Input array.\naxis : int, optional\n    By default, the index is into the flattened array, otherwise\n    along the specified axis.\nout : array, optional\n    If provided, the result will be inserted into this array. It should\n    be of the appropriate shape and dtype.\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n\n    If the default value is passed, then `keepdims` will not be\n    passed through to the `argmax` method of sub-classes of\n    `ndarray`, however any non-default value will be. If the\n    sub-class' method does not implement `keepdims` any\n    exceptions will be raised.\n\nReturns\n-------\nindex_array : ndarray of ints\n    Array of indices into the array. It has the same shape as `a.shape`\n    with the dimension along `axis` removed. If `keepdims` is set to True,\n    then the size of `axis` will be 1 with the resulting array having same\n    shape as `a.shape`.",
      "code": "@array_function_dispatch(_argmax_dispatcher)\ndef argmax(a, axis=None, out=None, *, keepdims=np._NoValue):\n    \"\"\"\n    Returns the indices of the maximum values along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        By default, the index is into the flattened array, otherwise\n        along the specified axis.\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `argmax` method of sub-classes of\n        `ndarray`, however any non-default value will be. If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    Returns\n    -------\n    index_array : ndarray of ints\n        Array of indices into the array. It has the same shape as `a.shape`\n        with the dimension along `axis` removed. If `keepdims` is set to True,\n        then the size of `axis` will be 1 with the resulting array having same\n        shape as `a.shape`.\n\n    See Also\n    --------\n    ndarray.argmax, argmin\n    amax : The maximum value along a given axis.\n    unravel_index : Convert a flat index into an index tuple.\n    take_along_axis : Apply ``np.expand_dims(index_array, axis)``\n                      from argmax to an array as if by calling max.\n\n    Notes\n    -----\n    In case of multiple occurrences of the maximum values, the indices\n    corresponding to the first occurrence are returned.\n\n    \"\"\"\n    kwds = {'keepdims': keepdims} if keepdims is not np._NoValue else {}\n    return _wrapfunc(a, 'argmax', axis=axis, out=out, **kwds)"
    },
    {
      "name": "numpy.argmin",
      "category": "Searching",
      "description": "Returns the indices of the minimum values along an axis",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.argmin.html",
      "doc": "Returns the indices of the minimum values along an axis.\n\nParameters\n----------\na : array_like\n    Input array.\naxis : int, optional\n    By default, the index is into the flattened array, otherwise\n    along the specified axis.\nout : array, optional\n    If provided, the result will be inserted into this array. It should\n    be of the appropriate shape and dtype.\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n\n    If the default value is passed, then `keepdims` will not be\n    passed through to the `argmin` method of sub-classes of\n    `ndarray`, however any non-default value will be. If the\n    sub-class' method does not implement `keepdims` any\n    exceptions will be raised.\n\nReturns\n-------\nindex_array : ndarray of ints\n    Array of indices into the array. It has the same shape as `a.shape`\n    with the dimension along `axis` removed. If `keepdims` is set to True,\n    then the size of `axis` will be 1 with the resulting array having same\n    shape as `a.shape`.",
      "code": "@array_function_dispatch(_argmin_dispatcher)\ndef argmin(a, axis=None, out=None, *, keepdims=np._NoValue):\n    \"\"\"\n    Returns the indices of the minimum values along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        By default, the index is into the flattened array, otherwise\n        along the specified axis.\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `argmin` method of sub-classes of\n        `ndarray`, however any non-default value will be. If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    Returns\n    -------\n    index_array : ndarray of ints\n        Array of indices into the array. It has the same shape as `a.shape`\n        with the dimension along `axis` removed. If `keepdims` is set to True,\n        then the size of `axis` will be 1 with the resulting array having same\n        shape as `a.shape`.\n\n    See Also\n    --------\n    ndarray.argmin, argmax\n    amin : The minimum value along a given axis.\n    unravel_index : Convert a flat index into an index tuple.\n    take_along_axis : Apply ``np.expand_dims(index_array, axis)``\n                      from argmin to an array as if by calling min.\n\n    Notes\n    -----\n    In case of multiple occurrences of the minimum values, the indices\n    corresponding to the first occurrence are returned.\n\n    \"\"\"\n    kwds = {'keepdims': keepdims} if keepdims is not np._NoValue else {}\n    return _wrapfunc(a, 'argmin', axis=axis, out=out, **kwds)"
    },
    {
      "name": "numpy.nanargmax",
      "category": "Searching",
      "description": "Return the indices of the maximum values in the specified axis ignoring NaNs",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.nanargmax.html",
      "doc": "Return the indices of the maximum values in the specified axis ignoring\nNaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results\ncannot be trusted if a slice contains only NaNs and -Infs.\n\nParameters\n----------\na : array_like\n    Input data.\naxis : int, optional\n    Axis along which to operate. By default flattened input is used.\nout : array, optional\n    If provided, the result will be inserted into this array. It should\n    be of the appropriate shape and dtype.\n\n    .. versionadded:: 1.22.0\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array.\n\n    .. versionadded:: 1.22.0\n\nReturns\n-------\nindex_array : ndarray\n    An array of indices or a single index value.",
      "code": "@array_function_dispatch(_nanargmax_dispatcher)\ndef nanargmax(a, axis=None, out=None, *, keepdims=np._NoValue):\n    \"\"\"\n    Return the indices of the maximum values in the specified axis ignoring\n    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the\n    results cannot be trusted if a slice contains only NaNs and -Infs.\n\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate. By default flattened input is used.\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n\n        .. versionadded:: 1.22.0\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the array.\n\n        .. versionadded:: 1.22.0\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmax, nanargmin\n\n    \"\"\"\n    a, mask = _replace_nan(a, -np.inf)\n    if mask is not None:\n        mask = np.all(mask, axis=axis)\n        if np.any(mask):\n            raise ValueError(\"All-NaN slice encountered\")\n    return argmax(a, axis=axis, out=out, keepdims=keepdims)"
    },
    {
      "name": "numpy.nanargmin",
      "category": "Searching",
      "description": "Return the indices of the minimum values in the specified axis ignoring NaNs",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.nanargmin.html",
      "doc": "Return the indices of the minimum values in the specified axis ignoring\nNaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results\ncannot be trusted if a slice contains only NaNs and Infs.\n\nParameters\n----------\na : array_like\n    Input data.\naxis : int, optional\n    Axis along which to operate. By default flattened input is used.\nout : array, optional\n    If provided, the result will be inserted into this array. It should\n    be of the appropriate shape and dtype.\n\n    .. versionadded:: 1.22.0\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array.\n\n    .. versionadded:: 1.22.0\n\nReturns\n-------\nindex_array : ndarray\n    An array of indices or a single index value.",
      "code": "@array_function_dispatch(_nanargmin_dispatcher)\ndef nanargmin(a, axis=None, out=None, *, keepdims=np._NoValue):\n    \"\"\"\n    Return the indices of the minimum values in the specified axis ignoring\n    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results\n    cannot be trusted if a slice contains only NaNs and Infs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate. By default flattened input is used.\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n\n        .. versionadded:: 1.22.0\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the array.\n\n        .. versionadded:: 1.22.0\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmin, nanargmax\n\n    \"\"\"\n    a, mask = _replace_nan(a, np.inf)\n    if mask is not None:\n        mask = np.all(mask, axis=axis)\n        if np.any(mask):\n            raise ValueError(\"All-NaN slice encountered\")\n    return argmin(a, axis=axis, out=out, keepdims=keepdims)"
    },
    {
      "name": "numpy.where",
      "category": "Searching",
      "description": "Return elements chosen from x or y depending on condition",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.where.html",
      "doc": "Return elements chosen from `x` or `y` depending on `condition`.\n\nNote\n----\nWhen only `condition` is provided, this function is a shorthand for\n``np.asarray(condition).nonzero()``. Using `nonzero` directly should be\npreferred, as it behaves correctly for subclasses. The rest of this\ndocumentation covers only the case where all three arguments are\nprovided.\n\nParameters\n----------\ncondition : array_like, bool\n    Where True, yield `x`, otherwise yield `y`.\nx, y : array_like\n    Values from which to choose. `x`, `y` and `condition` need to be\n    broadcastable to some shape.\n\nReturns\n-------\nout : ndarray\n    An array with elements from `x` where `condition` is True, and elements\n    from `y` elsewhere.\n\nSee Also\n--------\nchoose\nnonzero : The function that is called when x and y are omitted",
      "code": "@array_function_dispatch(_where_dispatcher)\ndef where(condition, x=None, y=None):\n    \"\"\"\n    Return elements chosen from `x` or `y` depending on `condition`.\n\n    Note\n    ----\n    When only `condition` is provided, this function is a shorthand for\n    ``np.asarray(condition).nonzero()``. Using `nonzero` directly should be\n    preferred, as it behaves correctly for subclasses. The rest of this\n    documentation covers only the case where all three arguments are\n    provided.\n\n    Parameters\n    ----------\n    condition : array_like, bool\n        Where True, yield `x`, otherwise yield `y`.\n    x, y : array_like\n        Values from which to choose. `x`, `y` and `condition` need to be\n        broadcastable to some shape.\n\n    Returns\n    -------\n    out : ndarray\n        An array with elements from `x` where `condition` is True, and elements\n        from `y` elsewhere.\n\n    See Also\n    --------\n    choose\n    nonzero : The function that is called when x and y are omitted\n\n    Notes\n    -----\n    If all the arrays are 1-D, `where` is equivalent to::\n\n        [xv if c else yv\n         for c, xv, yv in zip(condition, x, y)]\n\n    \"\"\"\n    if x is None and y is None:\n        return nonzero(condition)\n    elif x is None or y is None:\n        raise ValueError(\"either both or neither of x and y should be given\")\n    return _where(condition, x, y)"
    },
    {
      "name": "numpy.argwhere",
      "category": "Searching",
      "description": "Find the indices of array elements that are non-zero, grouped by element",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.argwhere.html",
      "doc": "Find the indices of array elements that are non-zero, grouped by element.\n\nParameters\n----------\na : array_like\n    Input data.\n\nReturns\n-------\nindex_array : (N, a.ndim) ndarray\n    Indices of elements that are non-zero. Indices are grouped by element.\n    This array will have shape ``(N, a.ndim)`` where ``N`` is the number of\n    non-zero items.\n\nSee Also\n--------\nwhere, nonzero\n\nNotes\n-----\n``np.argwhere(a)`` is almost the same as ``np.transpose(np.nonzero(a))``,\nbut produces a result of the correct shape for a 0D array.\n\nThe output of ``argwhere`` is not suitable for indexing arrays.\nFor this purpose use ``nonzero(a)`` instead.",
      "code": "@array_function_dispatch(_argwhere_dispatcher)\ndef argwhere(a):\n    \"\"\"\n    Find the indices of array elements that are non-zero, grouped by element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    index_array : (N, a.ndim) ndarray\n        Indices of elements that are non-zero. Indices are grouped by element.\n        This array will have shape ``(N, a.ndim)`` where ``N`` is the number of\n        non-zero items.\n\n    See Also\n    --------\n    where, nonzero\n\n    Notes\n    -----\n    ``np.argwhere(a)`` is almost the same as ``np.transpose(np.nonzero(a))``,\n    but produces a result of the correct shape for a 0D array.\n\n    The output of ``argwhere`` is not suitable for indexing arrays.\n    For this purpose use ``nonzero(a)`` instead.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argwhere(x>1)\n    array([[0, 2],\n           [1, 0],\n           [1, 1],\n           [1, 2]])\n\n    \"\"\"\n    # nonzero does not behave well on 0d, so promote to 1d\n    if np.ndim(a) == 0:\n        a = shape_base.atleast_1d(a)\n        # then remove the added dimension\n        return argwhere(a)[:,:0]\n    return transpose(nonzero(a))"
    },
    {
      "name": "numpy.nonzero",
      "category": "Searching",
      "description": "Return the indices of the elements that are non-zero",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.nonzero.html",
      "doc": "Return the indices of the elements that are non-zero.\n\nReturns a tuple of arrays, one for each dimension of `a`,\ncontaining the indices of the non-zero elements in that\ndimension. The values in `a` are always tested and returned in\nrow-major, C-style order.\n\nTo group the indices by element, rather than dimension, use `argwhere`,\nwhich returns a row for each non-zero element.\n\nParameters\n----------\na : array_like\n    Input array.\n\nReturns\n-------\ntuple_of_arrays : tuple\n    Indices of elements that are non-zero.\n\nSee Also\n--------\nflatnonzero : Return indices that are non-zero in the flattened version of the input array.\nndarray.nonzero : Equivalent ndarray method.\ncount_nonzero : Counts the number of non-zero elements in the input array.\n\nNotes\n-----\nWhile the nonzero values can be obtained with ``a[nonzero(a)]``, it is\nrecommended to use ``x[x.astype(bool)]`` or ``x[x != 0]`` instead, which\nwill correctly handle 0-d arrays.",
      "code": "@array_function_dispatch(_nonzero_dispatcher)\ndef nonzero(a):\n    \"\"\"\n    Return the indices of the elements that are non-zero.\n\n    Returns a tuple of arrays, one for each dimension of `a`,\n    containing the indices of the non-zero elements in that\n    dimension. The values in `a` are always tested and returned in\n    row-major, C-style order.\n\n    To group the indices by element, rather than dimension, use `argwhere`,\n    which returns a row for each non-zero element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n\n    Returns\n    -------\n    tuple_of_arrays : tuple\n        Indices of elements that are non-zero.\n\n    See Also\n    --------\n    flatnonzero : Return indices that are non-zero in the flattened version of the input array.\n    ndarray.nonzero : Equivalent ndarray method.\n    count_nonzero : Counts the number of non-zero elements in the input array.\n\n    Notes\n    -----\n    While the nonzero values can be obtained with ``a[nonzero(a)]``, it is\n    recommended to use ``x[x.astype(bool)]`` or ``x[x != 0]`` instead, which\n    will correctly handle 0-d arrays.\n\n    \"\"\"\n    return _wrapfunc(a, 'nonzero')"
    },
    {
      "name": "numpy.flatnonzero",
      "category": "Searching",
      "description": "Return indices that are non-zero in the flattened version of a",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.flatnonzero.html",
      "doc": "Return indices that are non-zero in the flattened version of a.\n\nThis is equivalent to ``np.nonzero(np.ravel(a))[0]``.\n\nParameters\n----------\na : array_like\n    Input data.\n\nReturns\n-------\nres : ndarray\n    Output array, containing the indices of the elements of ``a.ravel()``\n    that are non-zero.\n\nSee Also\n--------\nnonzero : Return the indices of the non-zero elements of the input array.\nravel : Return a 1-D array containing the elements of the input array.",
      "code": "@array_function_dispatch(_flatnonzero_dispatcher)\ndef flatnonzero(a):\n    \"\"\"\n    Return indices that are non-zero in the flattened version of a.\n\n    This is equivalent to ``np.nonzero(np.ravel(a))[0]``.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, containing the indices of the elements of ``a.ravel()``\n        that are non-zero.\n\n    See Also\n    --------\n    nonzero : Return the indices of the non-zero elements of the input array.\n    ravel : Return a 1-D array containing the elements of the input array.\n\n    Examples\n    --------\n    >>> x = np.arange(-2, 3)\n    >>> x\n    array([-2, -1,  0,  1,  2])\n    >>> np.flatnonzero(x)\n    array([0, 1, 3, 4])\n\n    Use the indices of the non-zero elements as an index array to extract\n    these elements:\n\n    >>> x.ravel()[np.flatnonzero(x)]\n    array([-2, -1,  1,  2])\n\n    \"\"\"\n    return np.nonzero(np.ravel(a))[0]"
    },
    {
      "name": "numpy.extract",
      "category": "Searching",
      "description": "Return the elements of an array that satisfy some condition",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.extract.html",
      "doc": "Return the elements of an array that satisfy some condition.\n\nThis is equivalent to ``np.compress(ravel(condition), ravel(arr))``. If\n`condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.\n\nNote that `place` does the exact opposite of `extract`.\n\nParameters\n----------\ncondition : array_like\n    An array whose nonzero or True entries indicate the elements of `arr`\n    to extract.\narr : array_like\n    Input array of the same size as `condition`.\n\nReturns\n-------\nextract : ndarray\n    Rank 1 array of values from `arr` where `condition` is True.\n\nSee Also\n--------\ntake, put, copyto, compress, place",
      "code": "@array_function_dispatch(_extract_dispatcher)\ndef extract(condition, arr):\n    \"\"\"\n    Return the elements of an array that satisfy some condition.\n\n    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``. If\n    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.\n\n    Note that `place` does the exact opposite of `extract`.\n\n    Parameters\n    ----------\n    condition : array_like\n        An array whose nonzero or True entries indicate the elements of `arr`\n        to extract.\n    arr : array_like\n        Input array of the same size as `condition`.\n\n    Returns\n    -------\n    extract : ndarray\n        Rank 1 array of values from `arr` where `condition` is True.\n\n    See Also\n    --------\n    take, put, copyto, compress, place\n\n    Examples\n    --------\n    >>> arr = np.arange(12).reshape((3, 4))\n    >>> arr\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11]])\n    >>> condition = np.mod(arr, 3)==0\n    >>> condition\n    array([[ True, False, False,  True],\n           [False, False,  True, False],\n           [False,  True, False, False]])\n    >>> np.extract(condition, arr)\n    array([0, 3, 6, 9])\n\n    If `condition` is boolean:\n\n    >>> arr[condition]\n    array([0, 3, 6, 9])\n\n    \"\"\"\n    return _nx.take(ravel(arr), nonzero(ravel(condition))[0])"
    },
    {
      "name": "numpy.count_nonzero",
      "category": "Counting",
      "description": "Counts the number of non-zero values in the array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.count_nonzero.html",
      "doc": "Counts the number of non-zero values in the array ``a``.\n\nThe word \"non-zero\" is in reference to the Python 2.x\nbuilt-in method ``__nonzero__()`` (renamed ``__bool__()``\nin Python 3.x) of Python objects that tests an object's\n\"truthfulness\". For example, any number is considered\ntruthful if it is nonzero, whereas any string is considered\ntruthful if it is not the empty string. Thus, this function\n(recursively) counts how many elements in ``a`` (and in\nsub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``\nmethod evaluated to ``True``.\n\nParameters\n----------\na : array_like\n    The array for which to count non-zeros.\naxis : None or int or tuple of ints, optional\n    Axis or tuple of axes along which to count non-zeros.\n    Default is None, meaning that non-zeros will be counted\n    along a flattened version of ``a``.\n\n    .. versionadded:: 1.12.0\n\nkeepdims : bool, optional\n    If this is set to True, the axes that are counted are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n\n    .. versionadded:: 1.19.0\n\nReturns\n-------\ncount : int or array of int\n    Number of non-zero values in the array along a given axis.\n    Otherwise, the total number of non-zero values in the array\n    is returned.",
      "code": "@array_function_dispatch(_count_nonzero_dispatcher)\ndef count_nonzero(a, axis=None, *, keepdims=False):\n    \"\"\"\n    Counts the number of non-zero values in the array ``a``.\n\n    The word \"non-zero\" is in reference to the Python 2.x\n    built-in method ``__nonzero__()`` (renamed ``__bool__()``\n    in Python 3.x) of Python objects that tests an object's\n    \"truthfulness\". For example, any number is considered\n    truthful if it is nonzero, whereas any string is considered\n    truthful if it is not the empty string. Thus, this function\n    (recursively) counts how many elements in ``a`` (and in\n    sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``\n    method evaluated to ``True``.\n\n    Parameters\n    ----------\n    a : array_like\n        The array for which to count non-zeros.\n    axis : None or int or tuple of ints, optional\n        Axis or tuple of axes along which to count non-zeros.\n        Default is None, meaning that non-zeros will be counted\n        along a flattened version of ``a``.\n\n        .. versionadded:: 1.12.0\n\n    keepdims : bool, optional\n        If this is set to True, the axes that are counted are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        .. versionadded:: 1.19.0\n\n    Returns\n    -------\n    count : int or array of int\n        Number of non-zero values in the array along a given axis.\n        Otherwise, the total number of non-zero values in the array\n        is returned.\n\n    See Also\n    --------\n    nonzero : Return the coordinates of all the non-zero values.\n\n    \"\"\"\n    if axis is None and not keepdims:\n        return multiarray.count_nonzero(a)\n\n    a = asanyarray(a)\n\n    # TODO: this works around .astype(bool) not working properly (gh-9847)\n    if np.issubdtype(a.dtype, np.character):\n        a_bool = a != a.dtype.type()\n    else:\n        a_bool = a.astype(np.bool, copy=False)\n\n    return a_bool.sum(axis=axis, dtype=np.intp, keepdims=keepdims)"
    },
    {
      "name": "numpy.unique",
      "category": "Counting",
      "description": "Find the unique elements of an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.unique.html",
      "doc": "Find the unique elements of an array.\n\nReturns the sorted unique elements of an array. There are three optional\noutputs in addition to the unique elements:\n\n* the indices of the first occurrences of the unique values in the\n  original array\n* the indices to reconstruct the original array from the unique array\n* the number of times each unique value comes up in the original array\n\nParameters\n----------\nar : array_like\n    Input array. Unless `axis` is specified, this will be flattened if it\n    is not already 1-D.\nreturn_index : bool, optional\n    If True, also return the indices of `ar` (along the specified axis,\n    if provided, or in the flattened array) that result in the unique array.\nreturn_inverse : bool, optional\n    If True, also return the indices of the unique array (for the specified\n    axis, if provided) that can be used to reconstruct `ar`.\nreturn_counts : bool, optional\n    If True, also return the number of times each unique value appears\n    in `ar`.\naxis : int or None, optional\n    The axis to operate on. If None, `ar` will be flattened. If an integer,\n    the subarrays indexed by the given axis will be flattened and treated\n    as the elements of a 1-D array with the dimension of the given axis,\n    see the notes for more details. Object arrays or structured arrays\n    that contain objects are not supported if the `axis` kwarg is used. The\n    default is None.\n\n    .. versionadded:: 1.13.0\n\nequal_nan : bool, optional\n    If True, collapses multiple NaN values in the return array into one.\n\n    .. versionadded:: 1.24\n\nReturns\n-------\nunique : ndarray\n    The sorted unique values.\nunique_indices : ndarray, optional\n    The indices of the first occurrences of the unique values in the\n    original array. Only provided if `return_index` is True.\nunique_inverse : ndarray, optional\n    The indices to reconstruct the original array from the\n    unique array. Only provided if `return_inverse` is True.\nunique_counts : ndarray, optional\n    The number of times each of the unique values comes up in the\n    original array. Only provided if `return_counts` is True.\n\n    .. versionadded:: 1.9.0",
      "code": "@array_function_dispatch(_unique_dispatcher)\ndef unique(ar, return_index=False, return_inverse=False,\n           return_counts=False, axis=None, *, equal_nan=True):\n    \"\"\"\n    Find the unique elements of an array.\n\n    Returns the sorted unique elements of an array. There are three optional\n    outputs in addition to the unique elements:\n\n    * the indices of the first occurrences of the unique values in the\n      original array\n    * the indices to reconstruct the original array from the unique array\n    * the number of times each unique value comes up in the original array\n\n    Parameters\n    ----------\n    ar : array_like\n        Input array. Unless `axis` is specified, this will be flattened if it\n        is not already 1-D.\n    return_index : bool, optional\n        If True, also return the indices of `ar` (along the specified axis,\n        if provided, or in the flattened array) that result in the unique array.\n    return_inverse : bool, optional\n        If True, also return the indices of the unique array (for the specified\n        axis, if provided) that can be used to reconstruct `ar`.\n    return_counts : bool, optional\n        If True, also return the number of times each unique value appears\n        in `ar`.\n    axis : int or None, optional\n        The axis to operate on. If None, `ar` will be flattened. If an integer,\n        the subarrays indexed by the given axis will be flattened and treated\n        as the elements of a 1-D array with the dimension of the given axis,\n        see the notes for more details. Object arrays or structured arrays\n        that contain objects are not supported if the `axis` kwarg is used. The\n        default is None.\n\n        .. versionadded:: 1.13.0\n\n    equal_nan : bool, optional\n        If True, collapses multiple NaN values in the return array into one.\n\n        .. versionadded:: 1.24\n\n    sorted : bool, optional\n        If True, the unique elements are returned in sorted order. If False,\n        the unique elements are returned in the order of first occurrence.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    unique : ndarray\n        The sorted unique values.\n    unique_indices : ndarray, optional\n        The indices of the first occurrences of the unique values in the\n        original array. Only provided if `return_index` is True.\n    unique_inverse : ndarray, optional\n        The indices to reconstruct the original array from the\n        unique array. Only provided if `return_inverse` is True.\n    unique_counts : ndarray, optional\n        The number of times each of the unique values comes up in the\n        original array. Only provided if `return_counts` is True.\n\n        .. versionadded:: 1.9.0\n\n    See Also\n    --------\n    Module with a number of other functions for performing set operations\n    on arrays.\n    unique_all : Equivalent function with all optional outputs.\n    unique_counts : Equivalent function returning indices and counts.\n    unique_inverse : Equivalent function returning indices and inverse.\n    unique_values : Equivalent function returning only unique values.\n\n    Notes\n    -----\n    When an axis is specified the subarrays indexed by the axis are sorted.\n    This is done by making the specified axis the first dimension of the array\n    (move the axis to the first dimension to keep the order of the other axes)\n    and then flattening the subarrays in C order. The flattened subarrays are\n    then viewed as a structured type with each element given a label, with the\n    effect that we end up with a 1-D array of structured types that can be\n    treated in the same way as any other 1-D array. The result is that the\n    flattened subarrays are sorted in lexicographic order starting with the\n    first element.\n\n    .. versionchanged: 1.21\n        If nan values are in the input array, a single nan is put\n        to the end of the sorted unique values.\n\n        Also for complex arrays all NaN values are considered equivalent\n        (no matter whether the NaN is in the real or imaginary part).\n        As the representant for the returned array the smallest one in the\n        lexicographical order is chosen - see np.sort for how the lexicographical\n        order is defined for complex arrays.\n\n    \"\"\"\n    ar = np.asanyarray(ar)\n    if axis is None:\n        ret = _unique1d(ar, return_index, return_inverse, return_counts,\n                        equal_nan=equal_nan, sorted=sorted)\n        return _unpack_tuple(ret)\n\n    # axis was specified and not None\n    try:\n        ar = np.moveaxis(ar, axis, 0)\n    except AxisError:\n        # this removes the \"axis1\" or \"axis2\" prefix from the error message\n        raise AxisError(axis, ar.ndim) from None\n\n    # Must reshape to a contiguous 2D array for this to work...\n    orig_shape, orig_dtype = ar.shape, ar.dtype\n    ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))\n    ar = np.ascontiguousarray(ar)\n    dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]\n\n    # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured\n    # data type with `m` fields where each field has the data type of `ar`.\n    # In the following, we create the array `consolidated`, which has\n    # shape `(n,)` with data type `dtype`.\n    try:\n        if ar.shape[1] > 0:\n            consolidated = ar.view(dtype)\n        else:\n            # If ar.shape[1] == 0, then dtype is np.dtype([]), which is\n            # a data type with itemsize 0, and the call `ar.view(dtype)`\n            # fails in this case.  Instead, we create an empty array\n            # with shape `(ar.shape[0],)` and data type `dtype`.\n            consolidated = np.empty(ar.shape[0], dtype=dtype)\n    except TypeError as e:\n        # There's no good way to do this for object arrays, etc...\n        msg = 'The axis argument to unique is not supported for dtype {dt}'\n        raise TypeError(msg.format(dt=ar.dtype)) from e\n\n    def reshape_uniq(uniq):\n        n = len(uniq)\n        uniq = uniq.view(orig_dtype)\n        uniq = uniq.reshape(n, *orig_shape[1:])\n        uniq = np.moveaxis(uniq, 0, axis)\n        return uniq\n\n    output = _unique1d(consolidated, return_index,\n                       return_inverse, return_counts,\n                       equal_nan=equal_nan, sorted=sorted)\n    output = (reshape_uniq(output[0]),) + output[1:]\n    return _unpack_tuple(output)"
    },
    {
      "name": "numpy.bincount",
      "category": "Counting",
      "description": "Count number of occurrences of each value in array of non-negative ints",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.bincount.html",
      "doc": "Count number of occurrences of each value in array of non-negative ints.\n\nThe number of bins (of size 1) is one larger than the largest value in\n`x`. If `minlength` is specified, there will be at least this number\nof bins in the output array (though it will be longer if necessary,\ndepending on the contents of `x`).\nEach bin gives the number of occurrences of its index value in `x`.\nIf `weights` is specified the input array is weighted by it, i.e. if a\nvalue ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead\nof ``out[n] += 1``.\n\nParameters\n----------\nx : array_like, 1 dimension, nonnegative ints\n    Input array.\nweights : array_like, optional\n    Weights, array of the same shape as `x`.\nminlength : int, optional\n    A minimum number of bins for the output array.\n\n    .. versionadded:: 1.6.0\n\nReturns\n-------\nout : ndarray of ints\n    The result of binning the input array.\n    The length of `out` is equal to ``np.amax(x)+1``.\n\nRaises\n------\nValueError\n    If the input is not 1-dimensional, or contains elements with negative\n    values, or if `minlength` is negative.\nTypeError\n    If the type of the input is float or complex.",
      "code": "@array_function_dispatch(_bincount_dispatcher)\ndef bincount(x, /, weights=None, minlength=0):\n    \"\"\"\n    Count number of occurrences of each value in array of non-negative ints.\n\n    The number of bins (of size 1) is one larger than the largest value in\n    `x`. If `minlength` is specified, there will be at least this number\n    of bins in the output array (though it will be longer if necessary,\n    depending on the contents of `x`).\n    Each bin gives the number of occurrences of its index value in `x`.\n    If `weights` is specified the input array is weighted by it, i.e. if a\n    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead\n    of ``out[n] += 1``.\n\n    Parameters\n    ----------\n    x : array_like, 1 dimension, nonnegative ints\n        Input array.\n    weights : array_like, optional\n        Weights, array of the same shape as `x`.\n    minlength : int, optional\n        A minimum number of bins for the output array.\n\n        .. versionadded:: 1.6.0\n\n    Returns\n    -------\n    out : ndarray of ints\n        The result of binning the input array.\n        The length of `out` is equal to ``np.amax(x)+1``.\n\n    Raises\n    ------\n    ValueError\n        If the input is not 1-dimensional, or contains elements with negative\n        values, or if `minlength` is negative.\n    TypeError\n        If the type of the input is float or complex.\n\n    See Also\n    --------\n    histogram, digitize, unique\n\n    Examples\n    --------\n    >>> np.bincount(np.arange(5))\n    array([1, 1, 1, 1, 1])\n    >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\n    array([1, 3, 1, 1, 0, 0, 0, 1])\n\n    >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])\n    >>> np.bincount(x).size == np.amax(x)+1\n    True\n\n    The input array needs to be of integer dtype, otherwise a\n    TypeError is raised:\n\n    >>> np.bincount(np.arange(5, dtype=float))\n    Traceback (most recent call last):\n      ...\n    TypeError: Cannot cast array data from dtype('float64') to dtype('int64')\n    according to the rule 'safe'\n\n    A possible use of ``bincount`` is to perform sums over\n    variable-size chunks of an array, using the ``weights`` keyword.\n\n    >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights\n    >>> x = np.array([0, 1, 1, 2, 2, 2])\n    >>> np.bincount(x,  weights=w)\n    array([ 0.3,  0.7,  1.1])\n\n    \"\"\"\n    return _multiarray_umath.bincount(x, weights, minlength)"
    },
    {
      "name": "numpy.msort",
      "category": "Sorting",
      "description": "Return a copy of an array sorted along the first axis",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.msort.html",
      "doc": "Return a copy of an array sorted along the first axis.\n\n.. deprecated:: 1.24.0\n    msort is deprecated, use ``np.sort(a, axis=0)`` instead.\n\nParameters\n----------\na : array_like\n    Array to be sorted.\n\nReturns\n-------\nsorted_array : ndarray\n    Array of the same type and shape as `a`.\n\nSee Also\n--------\nsort\n\nNotes\n-----\n``np.msort(a)`` is equivalent to ``np.sort(a, axis=0)``.",
      "code": "@array_function_dispatch(_msort_dispatcher)\ndef msort(a):\n    \"\"\"\n    Return a copy of an array sorted along the first axis.\n\n    .. deprecated:: 1.24.0\n        msort is deprecated, use ``np.sort(a, axis=0)`` instead.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n\n    Returns\n    -------\n    sorted_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    sort\n\n    Notes\n    -----\n    ``np.msort(a)`` is equivalent to ``np.sort(a, axis=0)``.\n\n    \"\"\"\n    # 2020-11-19, NumPy 1.20.0\n    warnings.warn(\n        \"`msort` is deprecated, use `np.sort(a, axis=0)` instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    b = array(a, subok=True, copy=True)\n    b.sort(0)\n    return b"
    }
  ]
}