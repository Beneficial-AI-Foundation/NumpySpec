{
  "metadata": {
    "description": "NumPy I/O operations for reading and writing arrays to files and strings",
    "modules": [
      "numpy.lib._npyio_impl",
      "numpy._core.numeric",
      "numpy._core.arrayprint",
      "numpy._core.memmap"
    ],
    "notes": [
      "Many I/O functions have C implementations for performance",
      "fromfile, tofile, and fromstring are implemented in C in numpy/core/src/multiarray/ctors.c",
      "Text I/O functions support various formats and delimiters",
      "Binary I/O functions use platform-dependent formats"
    ]
  },
  "functions": [
    {
      "name": "numpy.fromfile",
      "category": "Binary file I/O",
      "description": "Construct an array from data in a text or binary file",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html",
      "doc": "Construct an array from data in a text or binary file. A highly efficient way of reading binary data with a known data-type, as well as parsing simply formatted text files. Data written using the tofile method can be read using this function.",
      "code": "C implementation in numpy/core/src/multiarray/ctors.c (PyArray_FromFile)"
    },
    {
      "name": "numpy.load",
      "category": "Binary file I/O",
      "description": "Load arrays or pickled objects from .npy, .npz or pickled files",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.load.html",
      "doc": "",
      "code": "@set_module('numpy')\ndef load(file, mmap_mode=None, allow_pickle=False, fix_imports=True,\n         encoding='ASCII', *, max_header_size=_MAX_HEADER_SIZE):\n    \"\"\"\n    Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.\n\n    .. warning:: Loading files that contain object arrays uses the ``pickle``\n                 module, which is not secure against erroneous or maliciously\n                 constructed data. Consider passing ``allow_pickle=False`` to\n                 load data that is known not to contain object arrays for the\n                 safer handling of untrusted sources.\n\n    Parameters\n    ----------\n    file : file-like object, string, or pathlib.Path\n        The file to read. File-like objects must support the\n        ``seek()`` and ``read()`` methods and must always\n        be opened in binary mode.  Pickled files require that the\n        file-like object support the ``readline()`` method as well.\n    mmap_mode : {None, 'r+', 'r', 'w+', 'c'}, optional\n        If not None, then memory-map the file, using the given mode (see\n        `numpy.memmap` for a detailed description of the modes).  A\n        memory-mapped array is kept on disk. However, it can be accessed\n        and sliced like any ndarray.  Memory mapping is especially useful\n        for accessing small fragments of large files without reading the\n        entire file into memory.\n    allow_pickle : bool, optional\n        Allow loading pickled object arrays stored in npy files. Reasons for\n        disallowing pickles include security, as loading pickled data can\n        execute arbitrary code. If pickles are disallowed, loading object\n        arrays will fail. Default: False\n    fix_imports : bool, optional\n        Only useful when loading Python 2 generated pickled files,\n        which includes npy/npz files containing object arrays. If `fix_imports`\n        is True, pickle will try to map the old Python 2 names to the new names\n        used in Python 3.\n    encoding : str, optional\n        What encoding to use when reading Python 2 strings. Only useful when\n        loading Python 2 generated pickled files, which includes\n        npy/npz files containing object arrays. Values other than 'latin1',\n        'ASCII', and 'bytes' are not allowed, as they can corrupt numerical\n        data. Default: 'ASCII'\n    max_header_size : int, optional\n        Maximum allowed size of the header.  Large headers may not be safe\n        to load securely and thus require explicitly passing a larger value.\n        See :py:func:`ast.literal_eval()` for details.\n        This option is ignored when `allow_pickle` is passed.  In that case\n        the file is by definition trusted and the limit is unnecessary.\n\n    Returns\n    -------\n    result : array, tuple, dict, etc.\n        Data stored in the file. For ``.npz`` files, the returned instance\n        of NpzFile class must be closed to avoid leaking file descriptors.\n\n    Raises\n    ------\n    OSError\n        If the input file does not exist or cannot be read.\n    UnpicklingError\n        If ``allow_pickle=True``, but the file cannot be loaded as a pickle.\n    ValueError\n        The file contains an object array, but ``allow_pickle=False`` given.\n    EOFError\n        When calling ``np.load`` multiple times on the same file handle,\n        if all data has already been read\n\n    See Also\n    --------\n    save, savez, savez_compressed, loadtxt\n    memmap : Create a memory-map to an array stored in a file on disk.\n    lib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.\n\n    Notes\n    -----\n    - If the file contains pickle data, then whatever object is stored\n      in the pickle is returned.\n    - If the file is a ``.npy`` file, then a single array is returned.\n    - If the file is a ``.npz`` file, then a dictionary-like object is\n      returned, containing ``{filename: array}`` key-value pairs, one for\n      each file in the archive.\n    - If the file is a ``.npz`` file, the returned value supports the\n      context manager protocol in a similar fashion to the open function::\n\n        with load('foo.npz') as data:\n            a = data['a']\n\n      The underlying file descriptor is closed when exiting the 'with'\n      block.\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    Store data to disk, and load it again:\n\n    >>> np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))\n    >>> np.load('/tmp/123.npy')\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    Store compressed data to disk, and load it again:\n\n    >>> a=np.array([[1, 2, 3], [4, 5, 6]])\n    >>> b=np.array([1, 2])\n    >>> np.savez('/tmp/123.npz', a=a, b=b)\n    >>> data = np.load('/tmp/123.npz')\n    >>> data['a']\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> data['b']\n    array([1, 2])\n    >>> data.close()\n\n    Mem-map the stored array, and then access the second row\n    directly from disk:\n\n    >>> X = np.load('/tmp/123.npy', mmap_mode='r')\n    >>> X[1, :]\n    memmap([4, 5, 6])"
    },
    {
      "name": "numpy.ndarray.tofile",
      "category": "Binary file I/O",
      "description": "Write array to a file as text or binary",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.ndarray.tofile.html",
      "doc": "Write array to a file as text or binary (default). Data is always written in 'C' order, independent of the order of a. The data produced by this method can be recovered using the function fromfile().",
      "code": "C implementation in numpy/core/src/multiarray/methods.c (array_tofile)"
    },
    {
      "name": "numpy.save",
      "category": "Binary file I/O",
      "description": "Save an array to a binary file in NumPy .npy format",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.save.html",
      "doc": "Save an array to a binary file in NumPy ``.npy`` format.\n\n    Parameters\n    ----------\n    file : file, str, or pathlib.Path\n        File or filename to which the data is saved. If file is a file-object,\n        then the filename is unchanged.  If file is a string or Path,\n        a ``.npy`` extension will be appended to the filename if it does not\n        already have one.\n    arr : array_like\n        Array data to be saved.\n    allow_pickle : bool, optional\n        Allow saving object arrays ...",
      "code": "@array_function_dispatch(_save_dispatcher)\ndef save(file, arr, allow_pickle=True, fix_imports=np._NoValue):\n    \"\"\"\n    Save an array to a binary file in NumPy ``.npy`` format.\n\n    Parameters\n    ----------\n    file : file, str, or pathlib.Path\n        File or filename to which the data is saved. If file is a file-object,\n        then the filename is unchanged.  If file is a string or Path,\n        a ``.npy`` extension will be appended to the filename if it does not\n        already have one.\n    arr : array_like\n        Array data to be saved.\n    allow_pickle : bool, optional\n        Allow saving object arrays using Python pickles. Reasons for\n        disallowing pickles include security (loading pickled data can execute\n        arbitrary code) and portability (pickled objects may not be loadable\n        on different Python installations, for example if the stored objects\n        require libraries that are not available, and not all pickled data is\n        compatible between different versions of Python).\n        Default: True\n    fix_imports : bool, optional\n        The `fix_imports` flag is deprecated and has no effect.\n\n        .. deprecated:: 2.1\n            This flag is ignored since NumPy 1.17 and was only needed to\n            support loading in Python 2 some files written in Python 3.\n\n    See Also\n    --------\n    savez : Save several arrays into a ``.npz`` archive\n    savetxt, load\n\n    Notes\n    -----\n    For a description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.\n\n    Any data saved to the file is appended to the end of the file.\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n\n    >>> x = np.arange(10)\n    >>> np.save(outfile, x)\n\n    >>> _ = outfile.seek(0) # Only needed to simulate closing & reopening file\n    >>> np.load(outfile)\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n    >>> with open('test.npy', 'wb') as f:\n    ...     np.save(f, np.array([1, 2]))\n    ...     np.save(f, np.array([1, 3]))\n    >>> with open('test.npy', 'rb') as f:\n    ...     a = np.load(f)\n    ...     b = np.load(f)\n    >>> print(a, b)\n    # [1 2] [1 3]\n    \"\"\"\n    if fix_imports is not np._NoValue:\n        # Deprecated 2024-05-16, NumPy 2.1\n        warnings.warn(\n            \"The 'fix_imports' flag is deprecated and has no effect. \"\n            \"(Deprecated in NumPy 2.1)\",\n            DeprecationWarning, stacklevel=2)\n    if hasattr(file, 'write'):\n        file_ctx = contextlib.nullcontext(file)\n    else:\n        file = os.fspath(file)\n        if not file.endswith('.npy'):\n            file = file + '.npy'\n        file_ctx = open(file, \"wb\")\n\n    with file_ctx as fid:\n        arr = np.asanyarray(arr)\n        format.write_array(fid, arr, allow_pickle=allow_pickle,\n                           pickle_kwargs={'fix_imports': fix_imports})"
    },
    {
      "name": "numpy.savez",
      "category": "Binary file I/O",
      "description": "Save several arrays into a single file in uncompressed .npz format",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.savez.html",
      "doc": "Save several arrays into a single file in uncompressed ``.npz`` format.\n\n    Provide arrays as keyword arguments to store them under the\n    corresponding name in the output file: ``savez(fn, x=x, y=y)``.\n\n    If arrays are specified as positional arguments, i.e., ``savez(fn,\n    x, y)``, their names will be `arr_0`, `arr_1`, etc.\n\n    Parameters\n    ----------\n    file : file, str, or pathlib.Path\n        Either the filename (string) or an open file (file-like object)\n        where the data wil...",
      "code": "@array_function_dispatch(_savez_dispatcher)\ndef savez(file, *args, allow_pickle=True, **kwds):\n    \"\"\"Save several arrays into a single file in uncompressed ``.npz`` format.\n\n    Provide arrays as keyword arguments to store them under the\n    corresponding name in the output file: ``savez(fn, x=x, y=y)``.\n\n    If arrays are specified as positional arguments, i.e., ``savez(fn,\n    x, y)``, their names will be `arr_0`, `arr_1`, etc.\n\n    Parameters\n    ----------\n    file : file, str, or pathlib.Path\n        Either the filename (string) or an open file (file-like object)\n        where the data will be saved. If file is a string or a Path, the\n        ``.npz`` extension will be appended to the filename if it is not\n        already there.\n    args : Arguments, optional\n        Arrays to save to the file. Please use keyword arguments (see\n        `kwds` below) to assign names to arrays.  Arrays specified as\n        args will be named \"arr_0\", \"arr_1\", and so on.\n    allow_pickle : bool, optional\n        Allow saving object arrays using Python pickles. Reasons for\n        disallowing pickles include security (loading pickled data can execute\n        arbitrary code) and portability (pickled objects may not be loadable\n        on different Python installations, for example if the stored objects\n        require libraries that are not available, and not all pickled data is\n        compatible between different versions of Python).\n        Default: True\n    kwds : Keyword arguments, optional\n        Arrays to save to the file. Each array will be saved to the\n        output file with its corresponding keyword name.\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    save : Save a single array to a binary file in NumPy format.\n    savetxt : Save an array to a file as plain text.\n    savez_compressed : Save several arrays into a compressed ``.npz`` archive\n\n    Notes\n    -----\n    The ``.npz`` file format is a zipped archive of files named after the\n    variables they contain.  The archive is not compressed and each file\n    in the archive contains one variable in ``.npy`` format. For a\n    description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.\n\n    When opening the saved ``.npz`` file with `load` a `~lib.npyio.NpzFile`\n    object is returned. This is a dictionary-like object which can be queried\n    for its list of arrays (with the ``.files`` attribute), and for the arrays\n    themselves.\n\n    Keys passed in `kwds` are used as filenames inside the ZIP archive.\n    Therefore, keys should be valid filenames; e.g., avoid keys that begin with\n    ``/`` or contain ``.``.\n\n    When naming variables with keyword arguments, it is not possible to name a\n    variable ``file``, as this would cause the ``file`` argument to be defined\n    twice in the call to ``savez``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n    >>> x = np.arange(10)\n    >>> y = np.sin(x)\n\n    Using `savez` with \\\\*args, the arrays are saved with default names.\n\n    >>> np.savez(outfile, x, y)\n    >>> _ = outfile.seek(0) # Only needed to simulate closing & reopening file\n    >>> npzfile = np.load(outfile)\n    >>> npzfile.files\n    ['arr_0', 'arr_1']\n    >>> npzfile['arr_0']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    Using `savez` with \\\\**kwds, the arrays are saved with the keyword names.\n\n    >>> outfile = TemporaryFile()\n    >>> np.savez(outfile, x=x, y=y)\n    >>> _ = outfile.seek(0)\n    >>> npzfile = np.load(outfile)\n    >>> sorted(npzfile.files)\n    ['x', 'y']\n    >>> npzfile['x']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    \"\"\"\n    _savez(file, args, kwds, False, allow_pickle=allow_pickle)"
    },
    {
      "name": "numpy.savez_compressed",
      "category": "Binary file I/O",
      "description": "Save several arrays into a single file in compressed .npz format",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.savez_compressed.html",
      "doc": "Save several arrays into a single file in compressed ``.npz`` format.\n\n    Provide arrays as keyword arguments to store them under the\n    corresponding name in the output file: ``savez_compressed(fn, x=x, y=y)``.\n\n    If arrays are specified as positional arguments, i.e.,\n    ``savez_compressed(fn, x, y)``, their names will be `arr_0`, `arr_1`, etc.\n\n    Parameters\n    ----------\n    file : file, str, or pathlib.Path\n        Either the filename (string) or an open file (file-like object)\n      ...",
      "code": "@array_function_dispatch(_savez_compressed_dispatcher)\ndef savez_compressed(file, *args, allow_pickle=True, **kwds):\n    \"\"\"\n    Save several arrays into a single file in compressed ``.npz`` format.\n\n    Provide arrays as keyword arguments to store them under the\n    corresponding name in the output file: ``savez_compressed(fn, x=x, y=y)``.\n\n    If arrays are specified as positional arguments, i.e.,\n    ``savez_compressed(fn, x, y)``, their names will be `arr_0`, `arr_1`, etc.\n\n    Parameters\n    ----------\n    file : file, str, or pathlib.Path\n        Either the filename (string) or an open file (file-like object)\n        where the data will be saved. If file is a string or a Path, the\n        ``.npz`` extension will be appended to the filename if it is not\n        already there.\n    args : Arguments, optional\n        Arrays to save to the file. Please use keyword arguments (see\n        `kwds` below) to assign names to arrays.  Arrays specified as\n        args will be named \"arr_0\", \"arr_1\", and so on.\n    allow_pickle : bool, optional\n        Allow saving object arrays using Python pickles. Reasons for\n        disallowing pickles include security (loading pickled data can execute\n        arbitrary code) and portability (pickled objects may not be loadable\n        on different Python installations, for example if the stored objects\n        require libraries that are not available, and not all pickled data is\n        compatible between different versions of Python).\n        Default: True\n    kwds : Keyword arguments, optional\n        Arrays to save to the file. Each array will be saved to the\n        output file with its corresponding keyword name.\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    numpy.save : Save a single array to a binary file in NumPy format.\n    numpy.savetxt : Save an array to a file as plain text.\n    numpy.savez : Save several arrays into an uncompressed ``.npz`` file format\n    numpy.load : Load the files created by savez_compressed.\n\n    Notes\n    -----\n    The ``.npz`` file format is a zipped archive of files named after the\n    variables they contain.  The archive is compressed with\n    ``zipfile.ZIP_DEFLATED`` and each file in the archive contains one variable\n    in ``.npy`` format. For a description of the ``.npy`` format, see\n    :py:mod:`numpy.lib.format`.\n\n\n    When opening the saved ``.npz`` file with `load` a `~lib.npyio.NpzFile`\n    object is returned. This is a dictionary-like object which can be queried\n    for its list of arrays (with the ``.files`` attribute), and for the arrays\n    themselves.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> test_array = np.random.rand(3, 2)\n    >>> test_vector = np.random.rand(4)\n    >>> np.savez_compressed('/tmp/123', a=test_array, b=test_vector)\n    >>> loaded = np.load('/tmp/123.npz')\n    >>> print(np.array_equal(test_array, loaded['a']))\n    True\n    >>> print(np.array_equal(test_vector, loaded['b']))\n    True\n\n    \"\"\"\n    _savez(file, args, kwds, True, allow_pickle=allow_pickle)"
    },
    {
      "name": "numpy.base_repr",
      "category": "Data exchange",
      "description": "Return a string representation of a number in the given base system",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.base_repr.html",
      "doc": "Return a string representation of a number in the given base system.\n\n    Parameters\n    ----------\n    number : int\n        The value to convert. Positive and negative values are handled.\n    base : int, optional\n        Convert `number` to the `base` number system. The valid range is 2-36,\n        the default value is 2.\n    padding : int, optional\n        Number of zeros padded on the left. Default is 0 (no padding).\n\n    Returns\n    -------\n    out : str\n        String representation of `num...",
      "code": "@set_module('numpy')\ndef base_repr(number, base=2, padding=0):\n    \"\"\"\n    Return a string representation of a number in the given base system.\n\n    Parameters\n    ----------\n    number : int\n        The value to convert. Positive and negative values are handled.\n    base : int, optional\n        Convert `number` to the `base` number system. The valid range is 2-36,\n        the default value is 2.\n    padding : int, optional\n        Number of zeros padded on the left. Default is 0 (no padding).\n\n    Returns\n    -------\n    out : str\n        String representation of `number` in `base` system.\n\n    See Also\n    --------\n    binary_repr : Faster version of `base_repr` for base 2.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.base_repr(5)\n    '101'\n    >>> np.base_repr(6, 5)\n    '11'\n    >>> np.base_repr(7, base=5, padding=3)\n    '00012'\n\n    >>> np.base_repr(10, base=16)\n    'A'\n    >>> np.base_repr(32, base=16)\n    '20'\n\n    \"\"\"\n    digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    if base > len(digits):\n        raise ValueError(\"Bases greater than 36 not handled in base_repr.\")\n    elif base < 2:\n        raise ValueError(\"Bases less than 2 not handled in base_repr.\")\n\n    num = abs(int(number))\n    res = []\n    while num:\n        res.append(digits[num % base])\n        num //= base\n    if padding:\n        res.append('0' * padding)\n    if number < 0:\n        res.append('-')\n    return ''.join(reversed(res or '0'))"
    },
    {
      "name": "numpy.binary_repr",
      "category": "Data exchange",
      "description": "Return the binary representation of the input number as a string",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.binary_repr.html",
      "doc": "",
      "code": "@set_module('numpy')\ndef binary_repr(num, width=None):\n    \"\"\"\n    Return the binary representation of the input number as a string.\n\n    For negative numbers, if width is not given, a minus sign is added to the\n    front. If width is given, the two's complement of the number is\n    returned, with respect to that width.\n\n    In a two's-complement system negative numbers are represented by the two's\n    complement of the absolute value. This is the most common method of\n    representing signed integers on computers [1]_. A N-bit two's-complement\n    system can represent every integer in the range\n    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\n    Parameters\n    ----------\n    num : int\n        Only an integer decimal number can be used.\n    width : int, optional\n        The length of the returned string if `num` is positive, or the length\n        of the two's complement if `num` is negative, provided that `width` is\n        at least a sufficient number of bits for `num` to be represented in\n        the designated form. If the `width` value is insufficient, an error is\n        raised.\n\n    Returns\n    -------\n    bin : str\n        Binary representation of `num` or two's complement of `num`.\n\n    See Also\n    --------\n    base_repr: Return a string representation of a number in the given base\n               system.\n    bin: Python's built-in binary representation generator of an integer.\n\n    Notes\n    -----\n    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x\n    faster.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Two's complement\",\n        https://en.wikipedia.org/wiki/Two's_complement"
    },
    {
      "name": "numpy.memmap",
      "category": "Memory mapping",
      "description": "Create a memory-map to an array stored in a binary file on disk",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.memmap.html",
      "doc": "Create a memory-map to an array stored in a *binary* file on disk.\n\n    Memory-mapped files are used for accessing small segments of large files\n    on disk, without reading the entire file into memory.  NumPy's\n    memmap's are array-like objects.  This differs from Python's ``mmap``\n    module, which uses file-like objects.\n\n    This subclass of ndarray has some unpleasant interactions with\n    some operations, because it doesn't quite fit properly as a subclass.\n    An alternative to using th...",
      "code": "class memmap(ndarray):\n    \"\"\"Create a memory-map to an array stored in a *binary* file on disk.\n\n    Memory-mapped files are used for accessing small segments of large files\n    on disk, without reading the entire file into memory.  NumPy's\n    memmap's are array-like objects.  This differs from Python's ``mmap``\n    module, which uses file-like objects.\n\n    This subclass of ndarray has some unpleasant interactions with\n    some operations, because it doesn't quite fit properly as a subclass.\n    An alternative to using this subclass is to create the ``mmap``\n    object yourself, then create an ndarray with ndarray.__new__ directly,\n    passing the object created in its 'buffer=' parameter.\n\n    This class may at some point be turned into a factory function\n    which returns a view into an mmap buffer.\n\n    Flush the memmap instance to write the changes to the file. Currently there\n    is no API to close the underlying ``mmap``. It is tricky to ensure the\n    resource is actually closed, since it may be shared between different\n    memmap instances.\n\n\n    Parameters\n    ----------\n    filename : str, file-like object, or pathlib.Path instance\n        The file name or file object to be used as the array data buffer.\n    dtype : data-type, optional\n        The data-type used to interpret the file contents.\n        Default is `uint8`.\n    mode : {'r+', 'r', 'w+', 'c'}, optional\n        The file is opened in this mode:\n\n        +------+-------------------------------------------------------------+\n        | 'r'  | Open existing file for reading only.                        |\n        +------+-------------------------------------------------------------+\n        | 'r+' | Open existing file for reading and writing.                 |\n        +------+-------------------------------------------------------------+\n        | 'w+' | Create or overwrite existing file for reading and writing.  |\n        |      | If ``mode == 'w+'`` then `shape` must also be specified.    |\n        +------+-------------------------------------------------------------+\n        | 'c'  | Copy-on-write: assignments affect data in memory, but       |\n        |      | changes are not saved to disk.  The file on disk is         |\n        |      | read-only.                                                  |\n        +------+-------------------------------------------------------------+\n\n        Default is 'r+'.\n    offset : int, optional\n        In the file, array data starts at this offset. Since `offset` is\n        measured in bytes, it should normally be a multiple of the byte-size\n        of `dtype`. When ``mode != 'r'``, even positive offsets beyond end of\n        file are valid; The file will be extended to accommodate the\n        additional data. By default, ``memmap`` will start at the beginning of\n        the file, even if ``filename`` is a file pointer ``fp`` and\n        ``fp.tell() != 0``.\n    shape : int or sequence of ints, optional\n        The desired shape of the array. If ``mode == 'r'`` and the number\n        of remaining bytes after `offset` is not a multiple of the byte-size\n        of `dtype`, you must specify `shape`. By default, the returned array\n        will be 1-D with the number of elements determined by file size\n        and data-type.\n\n        .. versionchanged:: 2.0\n         The shape parameter can now be any integer sequence type, previously\n         types were limited to tuple and int.\n\n    order : {'C', 'F'}, optional\n        Specify the order of the ndarray memory layout:\n        :term:`row-major`, C-style or :term:`column-major`,\n        Fortran-style.  This only has an effect if the shape is\n        greater than 1-D.  The default order is 'C'.\n\n    Attributes\n    ----------\n    filename : str or pathlib.Path instance\n        Path to the mapped file.\n    offset : int\n        Offset position in the file.\n    mode : str\n        File mode.\n\n    Methods\n    -------\n    flush\n        Flush any changes in memory to file on disk.\n        When you delete a memmap object, flush is called first to write\n        changes to disk.\n\n\n    See also\n    --------\n    lib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.\n\n    Notes\n    -----\n    The memmap object can be used anywhere an ndarray is accepted.\n    Given a memmap ``fp``, ``isinstance(fp, numpy.ndarray)`` returns\n    ``True``.\n\n    Memory-mapped files cannot be larger than 2GB on 32-bit systems.\n\n    When a memmap causes a file to be created or extended beyond its\n    current size in the filesystem, the contents of the new part are\n    unspecified. On systems with POSIX filesystem semantics, the extended\n    part will be filled with zero bytes.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> data = np.arange(12, dtype='float32')\n    >>> data.resize((3,4))\n\n    This example uses a temporary file so that doctest doesn't write\n    files to your directory. You would use a 'normal' filename.\n\n    >>> from tempfile import mkdtemp\n    >>> import os.path as path\n    >>> filename = path.join(mkdtemp(), 'newfile.dat')\n\n    Create a memmap with dtype and shape that matches our data:\n\n    >>> fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))\n    >>> fp\n    memmap([[0., 0., 0., 0.],\n            [0., 0., 0., 0.],\n            [0., 0., 0., 0.]], dtype=float32)\n\n    Write data to memmap array:\n\n    >>> fp[:] = data[:]\n    >>> fp\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    >>> fp.filename == path.abspath(filename)\n    True\n\n    Flushes memory changes to disk in order to read them back\n\n    >>> fp.flush()\n\n    Load the memmap and verify data was stored:\n\n    >>> newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n    >>> newfp\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    Read-only memmap:\n\n    >>> fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n    >>> fpr.flags.writeable\n    False\n\n    Copy-on-write memmap:\n\n    >>> fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))\n    >>> fpc.flags.writeable\n    True\n\n    It's possible to assign to copy-on-write array, but values are only\n    written into the memory copy of the array, and not written to disk:\n\n    >>> fpc\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n    >>> fpc[0,:] = 0\n    >>> fpc\n    memmap([[  0.,   0.,   0.,   0.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    File on disk is unchanged:\n\n    >>> fpr\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    Offset into a memmap:\n\n    >>> fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)\n    >>> fpo\n    memmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)\n\n    \"\"\"\n\n    __array_priority__ = -100.0\n\n    def __new__(subtype, filename, dtype=uint8, mode='r+', offset=0,\n                shape=None, order='C'):\n        # Import here to minimize 'import numpy' overhead\n        import mmap\n        import os.path\n        try:\n            mode = mode_equivalents[mode]\n        except KeyError as e:\n            if mode not in valid_filemodes:\n                all_modes = valid_filemodes + list(mode_equivalents.keys())\n                raise ValueError(\n                    f\"mode must be one of {all_modes!r} (got {mode!r})\"\n                ) from None\n\n        if mode == 'w+' and shape is None:\n            raise ValueError(\"shape must be given if mode == 'w+'\")\n\n        if hasattr(filename, 'read'):\n            f_ctx = nullcontext(filename)\n        else:\n            f_ctx = open(\n                os.fspath(filename),\n                ('r' if mode == 'c' else mode) + 'b'\n            )\n\n        with f_ctx as fid:\n            fid.seek(0, 2)\n            flen = fid.tell()\n            descr = dtypedescr(dtype)\n            _dbytes = descr.itemsize\n\n            if shape is None:\n                bytes = flen - offset\n                if bytes % _dbytes:\n                    raise ValueError(\"Size of available data is not a \"\n                            \"multiple of the data-type size.\")\n                size = bytes // _dbytes\n                shape = (size,)\n            else:\n                if not isinstance(shape, (tuple, list)):\n                    try:\n                        shape = [operator.index(shape)]\n                    except TypeError:\n                        pass\n                shape = tuple(shape)\n                size = np.intp(1)  # avoid overflows\n                for k in shape:\n                    size *= k\n\n            bytes = int(offset + size * _dbytes)\n\n            if mode in ('w+', 'r+'):\n                # gh-27723\n                # if bytes == 0, we write out 1 byte to allow empty memmap.\n                bytes = max(bytes, 1)\n                if flen < bytes:\n                    fid.seek(bytes - 1, 0)\n                    fid.write(b'\\0')\n                    fid.flush()\n\n            if mode == 'c':\n                acc = mmap.ACCESS_COPY\n            elif mode == 'r':\n                acc = mmap.ACCESS_READ\n            else:\n                acc = mmap.ACCESS_WRITE\n\n            start = offset - offset % mmap.ALLOCATIONGRANULARITY\n            bytes -= start\n            # bytes == 0 is problematic as in mmap length=0 maps the full file.\n            # See PR gh-27723 for a more detailed explanation.\n            if bytes == 0 and start > 0:\n                bytes += mmap.ALLOCATIONGRANULARITY\n                start -= mmap.ALLOCATIONGRANULARITY\n            array_offset = offset - start\n            mm = mmap.mmap(fid.fileno(), bytes, access=acc, offset=start)\n\n            self = ndarray.__new__(subtype, shape, dtype=descr, buffer=mm,\n                                   offset=array_offset, order=order)\n            self._mmap = mm\n            self.offset = offset\n            self.mode = mode\n\n            if isinstance(filename, os.PathLike):\n                # special case - if we were constructed with a pathlib.path,\n                # then filename is a path object, not a string\n                self.filename = filename.resolve()\n            elif hasattr(fid, \"name\") and isinstance(fid.name, str):\n                # py3 returns int for TemporaryFile().name\n                self.filename = os.path.abspath(fid.name)\n            # same as memmap copies (e.g. memmap + 1)\n            else:\n                self.filename = None\n\n        return self\n\n    def __array_finalize__(self, obj):\n        if hasattr(obj, '_mmap') and np.may_share_memory(self, obj):\n            self._mmap = obj._mmap\n            self.filename = obj.filename\n            self.offset = obj.offset\n            self.mode = obj.mode\n        else:\n            self._mmap = None\n            self.filename = None\n            self.offset = None\n            self.mode = None\n\n    def flush(self):\n        \"\"\"\n        Write any changes in the array to the file on disk.\n\n        For further information, see `memmap`.\n\n        Parameters\n        ----------\n        None\n\n        See Also\n        --------\n        memmap\n\n        \"\"\"\n        if self.base is not None and hasattr(self.base, 'flush'):\n            self.base.flush()\n\n    def __array_wrap__(self, arr, context=None, return_scalar=False):\n        arr = super().__array_wrap__(arr, context)\n\n        # Return a memmap if a memmap was given as the output of the\n        # ufunc. Leave the arr class unchanged if self is not a memmap\n        # to keep original memmap subclasses behavior\n        if self is arr or type(self) is not memmap:\n            return arr\n\n        # Return scalar instead of 0d memmap, e.g. for np.sum with\n        # axis=None (note that subclasses will not reach here)\n        if return_scalar:\n            return arr[()]\n\n        # Return ndarray otherwise\n        return arr.view(np.ndarray)\n\n    def __getitem__(self, index):\n        res = super().__getitem__(index)\n        if type(res) is memmap and res._mmap is None:\n            return res.view(type=ndarray)\n        return res"
    },
    {
      "name": "numpy.fromstring",
      "category": "String I/O",
      "description": "A new 1-D array initialized from text data in a string",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.fromstring.html",
      "doc": "A new 1-D array initialized from text data in a string. Deprecated since version 1.14: Passing sep='', the default, is deprecated since it will trigger the deprecated binary mode of this function. This mode interprets string as binary bytes, rather than ASCII text with decimal numbers.",
      "code": "C implementation in numpy/core/src/multiarray/ctors.c (PyArray_FromString)"
    },
    {
      "name": "numpy.array2string",
      "category": "String formatting",
      "description": "Return a string representation of an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.array2string.html",
      "doc": "",
      "code": "@array_function_dispatch(_array2string_dispatcher, module='numpy')\ndef array2string(a, max_line_width=None, precision=None,\n                 suppress_small=None, separator=' ', prefix=\"\",\n                 style=np._NoValue, formatter=None, threshold=None,\n                 edgeitems=None, sign=None, floatmode=None, suffix=\"\",\n                 *, legacy=None):\n    \"\"\"\n    Return a string representation of an array.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.\n        Defaults to ``numpy.get_printoptions()['linewidth']``.\n    precision : int or None, optional\n        Floating point precision.\n        Defaults to ``numpy.get_printoptions()['precision']``.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n        Defaults to ``numpy.get_printoptions()['suppress']``.\n    separator : str, optional\n        Inserted between elements.\n    prefix : str, optional\n    suffix : str, optional\n        The length of the prefix and suffix strings are used to respectively\n        align and wrap the output. An array is typically printed as::\n\n          prefix + array2string(a) + suffix\n\n        The output is left-padded by the length of the prefix string, and\n        wrapping is forced at the column ``max_line_width - len(suffix)``.\n        It should be noted that the content of prefix and suffix strings are\n        not included in the output.\n    style : _NoValue, optional\n        Has no effect, do not use.\n\n        .. deprecated:: 1.14.0\n    formatter : dict of callables, optional\n        If not None, the keys should indicate the type(s) that the respective\n        formatting function applies to.  Callables should return a string.\n        Types that are not specified (by their corresponding keys) are handled\n        by the default formatters.  Individual types for which a formatter\n        can be set are:\n\n        - 'bool'\n        - 'int'\n        - 'timedelta' : a `numpy.timedelta64`\n        - 'datetime' : a `numpy.datetime64`\n        - 'float'\n        - 'longfloat' : 128-bit floats\n        - 'complexfloat'\n        - 'longcomplexfloat' : composed of two 128-bit floats\n        - 'void' : type `numpy.void`\n        - 'numpystr' : types `numpy.bytes_` and `numpy.str_`\n\n        Other keys that can be used to set a group of types at once are:\n\n        - 'all' : sets all types\n        - 'int_kind' : sets 'int'\n        - 'float_kind' : sets 'float' and 'longfloat'\n        - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'\n        - 'str_kind' : sets 'numpystr'\n    threshold : int, optional\n        Total number of array elements which trigger summarization\n        rather than full repr.\n        Defaults to ``numpy.get_printoptions()['threshold']``.\n    edgeitems : int, optional\n        Number of array items in summary at beginning and end of\n        each dimension.\n        Defaults to ``numpy.get_printoptions()['edgeitems']``.\n    sign : string, either '-', '+', or ' ', optional\n        Controls printing of the sign of floating-point types. If '+', always\n        print the sign of positive values. If ' ', always prints a space\n        (whitespace character) in the sign position of positive values.  If\n        '-', omit the sign character of positive values.\n        Defaults to ``numpy.get_printoptions()['sign']``.\n\n        .. versionchanged:: 2.0\n             The sign parameter can now be an integer type, previously\n             types were floating-point types.\n\n    floatmode : str, optional\n        Controls the interpretation of the `precision` option for\n        floating-point types.\n        Defaults to ``numpy.get_printoptions()['floatmode']``.\n        Can take the following values:\n\n        - 'fixed': Always print exactly `precision` fractional digits,\n          even if this would print more or fewer digits than\n          necessary to specify the value uniquely.\n        - 'unique': Print the minimum number of fractional digits necessary\n          to represent each value uniquely. Different elements may\n          have a different number of digits.  The value of the\n          `precision` option is ignored.\n        - 'maxprec': Print at most `precision` fractional digits, but if\n          an element can be uniquely represented with fewer digits\n          only print it with that many.\n        - 'maxprec_equal': Print at most `precision` fractional digits,\n          but if every element in the array can be uniquely\n          represented with an equal number of fewer digits, use that\n          many digits for all elements.\n    legacy : string or `False`, optional\n        If set to the string ``'1.13'`` enables 1.13 legacy printing mode. This\n        approximates numpy 1.13 print output by including a space in the sign\n        position of floats and different behavior for 0d arrays. If set to\n        `False`, disables legacy mode. Unrecognized strings will be ignored\n        with a warning for forward compatibility.\n\n    Returns\n    -------\n    array_str : str\n        String representation of the array.\n\n    Raises\n    ------\n    TypeError\n        if a callable in `formatter` does not return a string.\n\n    See Also\n    --------\n    array_str, array_repr, set_printoptions, get_printoptions\n\n    Notes\n    -----\n    If a formatter is specified for a certain type, the `precision` keyword is\n    ignored for that type.\n\n    This is a very flexible function; `array_repr` and `array_str` are using\n    `array2string` internally so keywords with the same name should work\n    identically in all three functions.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.array([1e-16,1,2,3])\n    >>> np.array2string(x, precision=2, separator=',',\n    ...                       suppress_small=True)\n    '[0.,1.,2.,3.]'\n\n    >>> x  = np.arange(3.)\n    >>> np.array2string(x, formatter={'float_kind':lambda x: \"%.2f\" % x})\n    '[0.00 1.00 2.00]'\n\n    >>> x  = np.arange(3)\n    >>> np.array2string(x, formatter={'int':lambda x: hex(x)})\n    '[0x0 0x1 0x2]'"
    },
    {
      "name": "numpy.array_repr",
      "category": "String formatting",
      "description": "Return the string representation of an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.array_repr.html",
      "doc": "Return the string representation of an array.\n\n    Parameters\n    ----------\n    arr : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.\n        Defaults to ``numpy.get_printoptions()['linewidth']``.\n    precision : int, optional\n        Floating point precision.\n        Defaults to ``numpy.get_printoptions()['precision']``.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; d...",
      "code": "@array_function_dispatch(_array_repr_dispatcher, module='numpy')\ndef array_repr(arr, max_line_width=None, precision=None, suppress_small=None):\n    \"\"\"\n    Return the string representation of an array.\n\n    Parameters\n    ----------\n    arr : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.\n        Defaults to ``numpy.get_printoptions()['linewidth']``.\n    precision : int, optional\n        Floating point precision.\n        Defaults to ``numpy.get_printoptions()['precision']``.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n        Defaults to ``numpy.get_printoptions()['suppress']``.\n\n    Returns\n    -------\n    string : str\n      The string representation of an array.\n\n    See Also\n    --------\n    array_str, array2string, set_printoptions\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.array_repr(np.array([1,2]))\n    'array([1, 2])'\n    >>> np.array_repr(np.ma.array([0.]))\n    'MaskedArray([0.])'\n    >>> np.array_repr(np.array([], np.int32))\n    'array([], dtype=int32)'\n\n    >>> x = np.array([1e-6, 4e-7, 2, 3])\n    >>> np.array_repr(x, precision=6, suppress_small=True)\n    'array([0.000001,  0.      ,  2.      ,  3.      ])'\n\n    \"\"\"\n    return _array_repr_implementation(\n        arr, max_line_width, precision, suppress_small)"
    },
    {
      "name": "numpy.array_str",
      "category": "String formatting",
      "description": "Return a string representation of the data in an array",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.array_str.html",
      "doc": "Return a string representation of the data in an array.\n\n    The data in the array is returned as a single string.  This function is\n    similar to `array_repr`, the difference being that `array_repr` also\n    returns information on the kind of array and its data type.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.\n        Defaults to ``numpy.get_printoptions()['linewidth']``...",
      "code": "@array_function_dispatch(_array_str_dispatcher, module='numpy')\ndef array_str(a, max_line_width=None, precision=None, suppress_small=None):\n    \"\"\"\n    Return a string representation of the data in an array.\n\n    The data in the array is returned as a single string.  This function is\n    similar to `array_repr`, the difference being that `array_repr` also\n    returns information on the kind of array and its data type.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.\n        Defaults to ``numpy.get_printoptions()['linewidth']``.\n    precision : int, optional\n        Floating point precision.\n        Defaults to ``numpy.get_printoptions()['precision']``.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n        Defaults to ``numpy.get_printoptions()['suppress']``.\n\n    See Also\n    --------\n    array2string, array_repr, set_printoptions\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.array_str(np.arange(3))\n    '[0 1 2]'\n\n    \"\"\"\n    return _array_str_implementation(\n        a, max_line_width, precision, suppress_small)"
    },
    {
      "name": "numpy.get_printoptions",
      "category": "String formatting",
      "description": "Return the current print options",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.get_printoptions.html",
      "doc": "Return the current print options.\n\n    Returns\n    -------\n    print_opts : dict\n        Dictionary of current print options with keys\n\n        - precision : int\n        - threshold : int\n        - edgeitems : int\n        - linewidth : int\n        - suppress : bool\n        - nanstr : str\n        - infstr : str\n        - sign : str\n        - formatter : dict of callables\n        - floatmode : str\n        - legacy : str or False\n\n        For a full description of these options, see `set_printoptio...",
      "code": "@set_module('numpy')\ndef get_printoptions():\n    \"\"\"\n    Return the current print options.\n\n    Returns\n    -------\n    print_opts : dict\n        Dictionary of current print options with keys\n\n        - precision : int\n        - threshold : int\n        - edgeitems : int\n        - linewidth : int\n        - suppress : bool\n        - nanstr : str\n        - infstr : str\n        - sign : str\n        - formatter : dict of callables\n        - floatmode : str\n        - legacy : str or False\n\n        For a full description of these options, see `set_printoptions`.\n\n    See Also\n    --------\n    set_printoptions, printoptions\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    >>> np.get_printoptions()\n    {'edgeitems': 3, 'threshold': 1000, ..., 'override_repr': None}\n\n    >>> np.get_printoptions()['linewidth']\n    75\n    >>> np.set_printoptions(linewidth=100)\n    >>> np.get_printoptions()['linewidth']\n    100\n\n    \"\"\"\n    opts = format_options.get().copy()\n    opts['legacy'] = {\n        113: '1.13', 121: '1.21', 125: '1.25', 201: '2.1',\n        202: '2.2', sys.maxsize: False,\n    }[opts['legacy']]\n    return opts"
    },
    {
      "name": "numpy.printoptions",
      "category": "String formatting",
      "description": "Context manager for setting print options",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.printoptions.html",
      "doc": "Context manager for setting print options.\n\n    Set print options for the scope of the `with` block, and restore the old\n    options at the end. See `set_printoptions` for the full description of\n    available options.\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    >>> from numpy.testing import assert_equal\n    >>> with np.printoptions(precision=2):\n    ...     np.array([2.0]) / 3\n    array([0.67])\n\n    The `as`-clause of the `with`-statement gives the current print options:\n\n    >>>...",
      "code": "@set_module('numpy')\n@contextlib.contextmanager\ndef printoptions(*args, **kwargs):\n    \"\"\"Context manager for setting print options.\n\n    Set print options for the scope of the `with` block, and restore the old\n    options at the end. See `set_printoptions` for the full description of\n    available options.\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    >>> from numpy.testing import assert_equal\n    >>> with np.printoptions(precision=2):\n    ...     np.array([2.0]) / 3\n    array([0.67])\n\n    The `as`-clause of the `with`-statement gives the current print options:\n\n    >>> with np.printoptions(precision=2) as opts:\n    ...      assert_equal(opts, np.get_printoptions())\n\n    See Also\n    --------\n    set_printoptions, get_printoptions\n\n    \"\"\"\n    token = _set_printoptions(*args, **kwargs)\n\n    try:\n        yield get_printoptions()\n    finally:\n        format_options.reset(token)"
    },
    {
      "name": "numpy.set_printoptions",
      "category": "String formatting",
      "description": "Set printing options",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.set_printoptions.html",
      "doc": "",
      "code": "@set_module('numpy')\ndef set_printoptions(precision=None, threshold=None, edgeitems=None,\n                     linewidth=None, suppress=None, nanstr=None,\n                     infstr=None, formatter=None, sign=None, floatmode=None,\n                     *, legacy=None, override_repr=None):\n    \"\"\"\n    Set printing options.\n\n    These options determine the way floating point numbers, arrays and\n    other NumPy objects are displayed.\n\n    Parameters\n    ----------\n    precision : int or None, optional\n        Number of digits of precision for floating point output (default 8).\n        May be None if `floatmode` is not `fixed`, to print as many digits as\n        necessary to uniquely specify the value.\n    threshold : int, optional\n        Total number of array elements which trigger summarization\n        rather than full repr (default 1000).\n        To always use the full repr without summarization, pass `sys.maxsize`.\n    edgeitems : int, optional\n        Number of array items in summary at beginning and end of\n        each dimension (default 3).\n    linewidth : int, optional\n        The number of characters per line for the purpose of inserting\n        line breaks (default 75).\n    suppress : bool, optional\n        If True, always print floating point numbers using fixed point\n        notation, in which case numbers equal to zero in the current precision\n        will print as zero.  If False, then scientific notation is used when\n        absolute value of the smallest number is < 1e-4 or the ratio of the\n        maximum absolute value to the minimum is > 1e3. The default is False.\n    nanstr : str, optional\n        String representation of floating point not-a-number (default nan).\n    infstr : str, optional\n        String representation of floating point infinity (default inf).\n    sign : string, either '-', '+', or ' ', optional\n        Controls printing of the sign of floating-point types. If '+', always\n        print the sign of positive values. If ' ', always prints a space\n        (whitespace character) in the sign position of positive values.  If\n        '-', omit the sign character of positive values. (default '-')\n\n        .. versionchanged:: 2.0\n             The sign parameter can now be an integer type, previously\n             types were floating-point types.\n\n    formatter : dict of callables, optional\n        If not None, the keys should indicate the type(s) that the respective\n        formatting function applies to.  Callables should return a string.\n        Types that are not specified (by their corresponding keys) are handled\n        by the default formatters.  Individual types for which a formatter\n        can be set are:\n\n        - 'bool'\n        - 'int'\n        - 'timedelta' : a `numpy.timedelta64`\n        - 'datetime' : a `numpy.datetime64`\n        - 'float'\n        - 'longfloat' : 128-bit floats\n        - 'complexfloat'\n        - 'longcomplexfloat' : composed of two 128-bit floats\n        - 'numpystr' : types `numpy.bytes_` and `numpy.str_`\n        - 'object' : `np.object_` arrays\n\n        Other keys that can be used to set a group of types at once are:\n\n        - 'all' : sets all types\n        - 'int_kind' : sets 'int'\n        - 'float_kind' : sets 'float' and 'longfloat'\n        - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'\n        - 'str_kind' : sets 'numpystr'\n    floatmode : str, optional\n        Controls the interpretation of the `precision` option for\n        floating-point types. Can take the following values\n        (default maxprec_equal):\n\n        * 'fixed': Always print exactly `precision` fractional digits,\n                even if this would print more or fewer digits than\n                necessary to specify the value uniquely.\n        * 'unique': Print the minimum number of fractional digits necessary\n                to represent each value uniquely. Different elements may\n                have a different number of digits. The value of the\n                `precision` option is ignored.\n        * 'maxprec': Print at most `precision` fractional digits, but if\n                an element can be uniquely represented with fewer digits\n                only print it with that many.\n        * 'maxprec_equal': Print at most `precision` fractional digits,\n                but if every element in the array can be uniquely\n                represented with an equal number of fewer digits, use that\n                many digits for all elements.\n    legacy : string or `False`, optional\n        If set to the string ``'1.13'`` enables 1.13 legacy printing mode. This\n        approximates numpy 1.13 print output by including a space in the sign\n        position of floats and different behavior for 0d arrays. This also\n        enables 1.21 legacy printing mode (described below).\n\n        If set to the string ``'1.21'`` enables 1.21 legacy printing mode. This\n        approximates numpy 1.21 print output of complex structured dtypes\n        by not inserting spaces after commas that separate fields and after\n        colons.\n\n        If set to ``'1.25'`` approximates printing of 1.25 which mainly means\n        that numeric scalars are printed without their type information, e.g.\n        as ``3.0`` rather than ``np.float64(3.0)``.\n\n        If set to ``'2.1'``, shape information is not given when arrays are\n        summarized (i.e., multiple elements replaced with ``...``).\n\n        If set to ``'2.2'``, the transition to use scientific notation for\n        printing ``np.float16`` and ``np.float32`` types may happen later or\n        not at all for larger values.\n\n        If set to `False`, disables legacy mode.\n\n        Unrecognized strings will be ignored with a warning for forward\n        compatibility.\n\n        .. versionchanged:: 1.22.0\n        .. versionchanged:: 2.2\n\n    override_repr: callable, optional\n        If set a passed function will be used for generating arrays' repr.\n        Other options will be ignored.\n\n    See Also\n    --------\n    get_printoptions, printoptions, array2string\n\n    Notes\n    -----\n    `formatter` is always reset with a call to `set_printoptions`.\n\n    Use `printoptions` as a context manager to set the values temporarily.\n\n    Examples\n    --------\n    Floating point precision can be set:\n\n    >>> import numpy as np\n    >>> np.set_printoptions(precision=4)\n    >>> np.array([1.123456789])\n    [1.1235]\n\n    Long arrays can be summarised:\n\n    >>> np.set_printoptions(threshold=5)\n    >>> np.arange(10)\n    array([0, 1, 2, ..., 7, 8, 9], shape=(10,))\n\n    Small results can be suppressed:\n\n    >>> eps = np.finfo(float).eps\n    >>> x = np.arange(4.)\n    >>> x**2 - (x + eps)**2\n    array([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])\n    >>> np.set_printoptions(suppress=True)\n    >>> x**2 - (x + eps)**2\n    array([-0., -0.,  0.,  0.])\n\n    A custom formatter can be used to display array elements as desired:\n\n    >>> np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})\n    >>> x = np.arange(3)\n    >>> x\n    array([int: 0, int: -1, int: -2])\n    >>> np.set_printoptions()  # formatter gets reset\n    >>> x\n    array([0, 1, 2])\n\n    To put back the default options, you can use:\n\n    >>> np.set_printoptions(edgeitems=3, infstr='inf',\n    ... linewidth=75, nanstr='nan', precision=8,\n    ... suppress=False, threshold=1000, formatter=None)\n\n    Also to temporarily override options, use `printoptions`\n    as a context manager:\n\n    >>> with np.printoptions(precision=2, suppress=True, threshold=5):\n    ...     np.linspace(0, 10, 10)\n    array([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ], shape=(10,))"
    },
    {
      "name": "numpy.fromregex",
      "category": "Text file I/O",
      "description": "Construct an array from a text file using regular expression parsing",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.fromregex.html",
      "doc": "Construct an array from a text file, using regular expression parsing.\n\n    The returned array is always a structured array, and is constructed from\n    all matches of the regular expression in the file. Groups in the regular\n    expression are converted to fields of the structured array.\n\n    Parameters\n    ----------\n    file : file, str, or pathlib.Path\n        Filename or file object to read.\n\n        .. versionchanged:: 1.22.0\n            Now accepts `os.PathLike` implementations.\n\n    rege...",
      "code": "@set_module('numpy')\ndef fromregex(file, regexp, dtype, encoding=None):\n    r\"\"\"\n    Construct an array from a text file, using regular expression parsing.\n\n    The returned array is always a structured array, and is constructed from\n    all matches of the regular expression in the file. Groups in the regular\n    expression are converted to fields of the structured array.\n\n    Parameters\n    ----------\n    file : file, str, or pathlib.Path\n        Filename or file object to read.\n\n        .. versionchanged:: 1.22.0\n            Now accepts `os.PathLike` implementations.\n\n    regexp : str or regexp\n        Regular expression used to parse the file.\n        Groups in the regular expression correspond to fields in the dtype.\n    dtype : dtype or list of dtypes\n        Dtype for the structured array; must be a structured datatype.\n    encoding : str, optional\n        Encoding used to decode the inputfile. Does not apply to input streams.\n\n    Returns\n    -------\n    output : ndarray\n        The output array, containing the part of the content of `file` that\n        was matched by `regexp`. `output` is always a structured array.\n\n    Raises\n    ------\n    TypeError\n        When `dtype` is not a valid dtype for a structured array.\n\n    See Also\n    --------\n    fromstring, loadtxt\n\n    Notes\n    -----\n    Dtypes for structured arrays can be specified in several forms, but all\n    forms specify at least the data type and field name. For details see\n    `basics.rec`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from io import StringIO\n    >>> text = StringIO(\"1312 foo\\n1534  bar\\n444   qux\")\n\n    >>> regexp = r\"(\\d+)\\s+(...)\"  # match [digits, whitespace, anything]\n    >>> output = np.fromregex(text, regexp,\n    ...                       [('num', np.int64), ('key', 'S3')])\n    >>> output\n    array([(1312, b'foo'), (1534, b'bar'), ( 444, b'qux')],\n          dtype=[('num', '<i8'), ('key', 'S3')])\n    >>> output['num']\n    array([1312, 1534,  444])\n\n    \"\"\"\n    own_fh = False\n    if not hasattr(file, \"read\"):\n        file = os.fspath(file)\n        file = np.lib._datasource.open(file, 'rt', encoding=encoding)\n        own_fh = True\n\n    try:\n        if not isinstance(dtype, np.dtype):\n            dtype = np.dtype(dtype)\n        if dtype.names is None:\n            raise TypeError('dtype must be a structured datatype.')\n\n        content = file.read()\n        if isinstance(content, bytes) and isinstance(regexp, str):\n            regexp = asbytes(regexp)\n\n        if not hasattr(regexp, 'match'):\n            regexp = re.compile(regexp)\n        seq = regexp.findall(content)\n        if seq and not isinstance(seq[0], tuple):\n            # Only one group is in the regexp.\n            # Create the new array as a single data-type and then\n            #   re-interpret as a single-field structured array.\n            newdtype = np.dtype(dtype[dtype.names[0]])\n            output = np.array(seq, dtype=newdtype)\n            output = output.view(dtype)\n        else:\n            output = np.array(seq, dtype=dtype)\n\n        return output\n    finally:\n        if own_fh:\n            file.close()"
    },
    {
      "name": "numpy.genfromtxt",
      "category": "Text file I/O",
      "description": "Load data from a text file, with missing values handled as specified",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.genfromtxt.html",
      "doc": "",
      "code": "@finalize_array_function_like\n@set_module('numpy')\ndef genfromtxt(fname, dtype=float, comments='#', delimiter=None,\n               skip_header=0, skip_footer=0, converters=None,\n               missing_values=None, filling_values=None, usecols=None,\n               names=None, excludelist=None,\n               deletechars=''.join(sorted(NameValidator.defaultdeletechars)),  # noqa: B008\n               replace_space='_', autostrip=False, case_sensitive=True,\n               defaultfmt=\"f%i\", unpack=None, usemask=False, loose=True,\n               invalid_raise=True, max_rows=None, encoding=None,\n               *, ndmin=0, like=None):\n    \"\"\"\n    Load data from a text file, with missing values handled as specified.\n\n    Each line past the first `skip_header` lines is split at the `delimiter`\n    character, and characters following the `comments` character are discarded.\n\n    Parameters\n    ----------\n    fname : file, str, pathlib.Path, list of str, generator\n        File, filename, list, or generator to read.  If the filename\n        extension is ``.gz`` or ``.bz2``, the file is first decompressed. Note\n        that generators must return bytes or strings. The strings\n        in a list or produced by a generator are treated as lines.\n    dtype : dtype, optional\n        Data type of the resulting array.\n        If None, the dtypes will be determined by the contents of each\n        column, individually.\n    comments : str, optional\n        The character used to indicate the start of a comment.\n        All the characters occurring on a line after a comment are discarded.\n    delimiter : str, int, or sequence, optional\n        The string used to separate values.  By default, any consecutive\n        whitespaces act as delimiter.  An integer or sequence of integers\n        can also be provided as width(s) of each field.\n    skiprows : int, optional\n        `skiprows` was removed in numpy 1.10. Please use `skip_header` instead.\n    skip_header : int, optional\n        The number of lines to skip at the beginning of the file.\n    skip_footer : int, optional\n        The number of lines to skip at the end of the file.\n    converters : variable, optional\n        The set of functions that convert the data of a column to a value.\n        The converters can also be used to provide a default value\n        for missing data: ``converters = {3: lambda s: float(s or 0)}``.\n    missing : variable, optional\n        `missing` was removed in numpy 1.10. Please use `missing_values`\n        instead.\n    missing_values : variable, optional\n        The set of strings corresponding to missing data.\n    filling_values : variable, optional\n        The set of values to be used as default when the data are missing.\n    usecols : sequence, optional\n        Which columns to read, with 0 being the first.  For example,\n        ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.\n    names : {None, True, str, sequence}, optional\n        If `names` is True, the field names are read from the first line after\n        the first `skip_header` lines. This line can optionally be preceded\n        by a comment delimiter. Any content before the comment delimiter is\n        discarded. If `names` is a sequence or a single-string of\n        comma-separated names, the names will be used to define the field\n        names in a structured dtype. If `names` is None, the names of the\n        dtype fields will be used, if any.\n    excludelist : sequence, optional\n        A list of names to exclude. This list is appended to the default list\n        ['return','file','print']. Excluded names are appended with an\n        underscore: for example, `file` would become `file_`.\n    deletechars : str, optional\n        A string combining invalid characters that must be deleted from the\n        names.\n    defaultfmt : str, optional\n        A format used to define default field names, such as \"f%i\" or \"f_%02i\".\n    autostrip : bool, optional\n        Whether to automatically strip white spaces from the variables.\n    replace_space : char, optional\n        Character(s) used in replacement of white spaces in the variable\n        names. By default, use a '_'.\n    case_sensitive : {True, False, 'upper', 'lower'}, optional\n        If True, field names are case sensitive.\n        If False or 'upper', field names are converted to upper case.\n        If 'lower', field names are converted to lower case.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = genfromtxt(...)``.  When used with a\n        structured data-type, arrays are returned for each field.\n        Default is False.\n    usemask : bool, optional\n        If True, return a masked array.\n        If False, return a regular array.\n    loose : bool, optional\n        If True, do not raise errors for invalid values.\n    invalid_raise : bool, optional\n        If True, an exception is raised if an inconsistency is detected in the\n        number of columns.\n        If False, a warning is emitted and the offending lines are skipped.\n    max_rows : int,  optional\n        The maximum number of rows to read. Must not be used with skip_footer\n        at the same time.  If given, the value must be at least 1. Default is\n        to read the entire file.\n    encoding : str, optional\n        Encoding used to decode the inputfile. Does not apply when `fname`\n        is a file object. The special value 'bytes' enables backward\n        compatibility workarounds that ensure that you receive byte arrays\n        when possible and passes latin1 encoded strings to converters.\n        Override this value to receive unicode arrays and pass strings\n        as input to converters.  If set to None the system default is used.\n        The default value is 'bytes'.\n\n        .. versionchanged:: 2.0\n            Before NumPy 2, the default was ``'bytes'`` for Python 2\n            compatibility. The default is now ``None``.\n\n    ndmin : int, optional\n        Same parameter as `loadtxt`\n\n        .. versionadded:: 1.23.0\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file. If `usemask` is True, this is a\n        masked array.\n\n    See Also\n    --------\n    numpy.loadtxt : equivalent function when no data is missing.\n\n    Notes\n    -----\n    * When spaces are used as delimiters, or when no delimiter has been given\n      as input, there should not be any missing data between two fields.\n    * When variables are named (either by a flexible dtype or with a `names`\n      sequence), there must not be any header in the file (else a ValueError\n      exception is raised).\n    * Individual values are not stripped of spaces by default.\n      When using a custom converter, make sure the function does remove spaces.\n    * Custom converters may receive unexpected values due to dtype\n      discovery.\n\n    References\n    ----------\n    .. [1] NumPy User Guide, section `I/O with NumPy\n           <https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html>`_.\n\n    Examples\n    --------\n    >>> from io import StringIO\n    >>> import numpy as np\n\n    Comma delimited file with mixed dtype\n\n    >>> s = StringIO(\"1,1.3,abcde\")\n    >>> data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),\n    ... ('mystring','S5')], delimiter=\",\")\n    >>> data\n    array((1, 1.3, b'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])\n\n    Using dtype = None\n\n    >>> _ = s.seek(0) # needed for StringIO example only\n    >>> data = np.genfromtxt(s, dtype=None,\n    ... names = ['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '<U5')])\n\n    Specifying dtype and names\n\n    >>> _ = s.seek(0)\n    >>> data = np.genfromtxt(s, dtype=\"i8,f8,S5\",\n    ... names=['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, b'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])\n\n    An example with fixed-width columns\n\n    >>> s = StringIO(\"11.3abcde\")\n    >>> data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],\n    ...     delimiter=[1,3,5])\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('intvar', '<i8'), ('fltvar', '<f8'), ('strvar', '<U5')])\n\n    An example to show comments\n\n    >>> f = StringIO('''\n    ... text,# of chars\n    ... hello world,11\n    ... numpy,5''')\n    >>> np.genfromtxt(f, dtype='S12,S12', delimiter=',')\n    array([(b'text', b''), (b'hello world', b'11'), (b'numpy', b'5')],\n      dtype=[('f0', 'S12'), ('f1', 'S12')])"
    },
    {
      "name": "numpy.loadtxt",
      "category": "Text file I/O",
      "description": "Load data from a text file",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.loadtxt.html",
      "doc": "Load data from a text file.\n\n    Parameters\n    ----------\n    fname : file, str, pathlib.Path, list of str, generator\n        File, filename, list, or generator to read.  If the filename\n        extension is ``.gz`` or ``.bz2``, the file is first decompressed. Note\n        that generators must return bytes or strings. The strings\n        in a list or produced by a generator are treated as lines.\n    dtype : data-type, optional\n        Data-type of the resulting array; default: float.  If this i...",
      "code": "@finalize_array_function_like\n@set_module('numpy')\ndef loadtxt(fname, dtype=float, comments='#', delimiter=None,\n            converters=None, skiprows=0, usecols=None, unpack=False,\n            ndmin=0, encoding=None, max_rows=None, *, quotechar=None,\n            like=None):\n    r\"\"\"\n    Load data from a text file.\n\n    Parameters\n    ----------\n    fname : file, str, pathlib.Path, list of str, generator\n        File, filename, list, or generator to read.  If the filename\n        extension is ``.gz`` or ``.bz2``, the file is first decompressed. Note\n        that generators must return bytes or strings. The strings\n        in a list or produced by a generator are treated as lines.\n    dtype : data-type, optional\n        Data-type of the resulting array; default: float.  If this is a\n        structured data-type, the resulting array will be 1-dimensional, and\n        each row will be interpreted as an element of the array.  In this\n        case, the number of columns used must match the number of fields in\n        the data-type.\n    comments : str or sequence of str or None, optional\n        The characters or list of characters used to indicate the start of a\n        comment. None implies no comments. For backwards compatibility, byte\n        strings will be decoded as 'latin1'. The default is '#'.\n    delimiter : str, optional\n        The character used to separate the values. For backwards compatibility,\n        byte strings will be decoded as 'latin1'. The default is whitespace.\n\n        .. versionchanged:: 1.23.0\n           Only single character delimiters are supported. Newline characters\n           cannot be used as the delimiter.\n\n    converters : dict or callable, optional\n        Converter functions to customize value parsing. If `converters` is\n        callable, the function is applied to all columns, else it must be a\n        dict that maps column number to a parser function.\n        See examples for further details.\n        Default: None.\n\n        .. versionchanged:: 1.23.0\n           The ability to pass a single callable to be applied to all columns\n           was added.\n\n    skiprows : int, optional\n        Skip the first `skiprows` lines, including comments; default: 0.\n    usecols : int or sequence, optional\n        Which columns to read, with 0 being the first. For example,\n        ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.\n        The default, None, results in all columns being read.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``.  When used with a\n        structured data-type, arrays are returned for each field.\n        Default is False.\n    ndmin : int, optional\n        The returned array will have at least `ndmin` dimensions.\n        Otherwise mono-dimensional axes will be squeezed.\n        Legal values: 0 (default), 1 or 2.\n    encoding : str, optional\n        Encoding used to decode the inputfile. Does not apply to input streams.\n        The special value 'bytes' enables backward compatibility workarounds\n        that ensures you receive byte arrays as results if possible and passes\n        'latin1' encoded strings to converters. Override this value to receive\n        unicode arrays and pass strings as input to converters.  If set to None\n        the system default is used. The default value is None.\n\n        .. versionchanged:: 2.0\n            Before NumPy 2, the default was ``'bytes'`` for Python 2\n            compatibility. The default is now ``None``.\n\n    max_rows : int, optional\n        Read `max_rows` rows of content after `skiprows` lines. The default is\n        to read all the rows. Note that empty rows containing no data such as\n        empty lines and comment lines are not counted towards `max_rows`,\n        while such lines are counted in `skiprows`.\n\n        .. versionchanged:: 1.23.0\n            Lines containing no data, including comment lines (e.g., lines\n            starting with '#' or as specified via `comments`) are not counted\n            towards `max_rows`.\n    quotechar : unicode character or None, optional\n        The character used to denote the start and end of a quoted item.\n        Occurrences of the delimiter or comment characters are ignored within\n        a quoted item. The default value is ``quotechar=None``, which means\n        quoting support is disabled.\n\n        If two consecutive instances of `quotechar` are found within a quoted\n        field, the first is treated as an escape character. See examples.\n\n        .. versionadded:: 1.23.0\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file.\n\n    See Also\n    --------\n    load, fromstring, fromregex\n    genfromtxt : Load data with missing values handled as specified.\n    scipy.io.loadmat : reads MATLAB data files\n\n    Notes\n    -----\n    This function aims to be a fast reader for simply formatted files.  The\n    `genfromtxt` function provides more sophisticated handling of, e.g.,\n    lines with missing values.\n\n    Each row in the input text file must have the same number of values to be\n    able to read all values. If all rows do not have same number of values, a\n    subset of up to n columns (where n is the least number of values present\n    in all rows) can be read by specifying the columns via `usecols`.\n\n    The strings produced by the Python float.hex method can be used as\n    input for floats.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from io import StringIO   # StringIO behaves like a file object\n    >>> c = StringIO(\"0 1\\n2 3\")\n    >>> np.loadtxt(c)\n    array([[0., 1.],\n           [2., 3.]])\n\n    >>> d = StringIO(\"M 21 72\\nF 35 58\")\n    >>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n    ...                      'formats': ('S1', 'i4', 'f4')})\n    array([(b'M', 21, 72.), (b'F', 35, 58.)],\n          dtype=[('gender', 'S1'), ('age', '<i4'), ('weight', '<f4')])\n\n    >>> c = StringIO(\"1,0,2\\n3,0,4\")\n    >>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)\n    >>> x\n    array([1., 3.])\n    >>> y\n    array([2., 4.])\n\n    The `converters` argument is used to specify functions to preprocess the\n    text prior to parsing. `converters` can be a dictionary that maps\n    preprocessing functions to each column:\n\n    >>> s = StringIO(\"1.618, 2.296\\n3.141, 4.669\\n\")\n    >>> conv = {\n    ...     0: lambda x: np.floor(float(x)),  # conversion fn for column 0\n    ...     1: lambda x: np.ceil(float(x)),  # conversion fn for column 1\n    ... }\n    >>> np.loadtxt(s, delimiter=\",\", converters=conv)\n    array([[1., 3.],\n           [3., 5.]])\n\n    `converters` can be a callable instead of a dictionary, in which case it\n    is applied to all columns:\n\n    >>> s = StringIO(\"0xDE 0xAD\\n0xC0 0xDE\")\n    >>> import functools\n    >>> conv = functools.partial(int, base=16)\n    >>> np.loadtxt(s, converters=conv)\n    array([[222., 173.],\n           [192., 222.]])\n\n    This example shows how `converters` can be used to convert a field\n    with a trailing minus sign into a negative number.\n\n    >>> s = StringIO(\"10.01 31.25-\\n19.22 64.31\\n17.57- 63.94\")\n    >>> def conv(fld):\n    ...     return -float(fld[:-1]) if fld.endswith(\"-\") else float(fld)\n    ...\n    >>> np.loadtxt(s, converters=conv)\n    array([[ 10.01, -31.25],\n           [ 19.22,  64.31],\n           [-17.57,  63.94]])\n\n    Using a callable as the converter can be particularly useful for handling\n    values with different formatting, e.g. floats with underscores:\n\n    >>> s = StringIO(\"1 2.7 100_000\")\n    >>> np.loadtxt(s, converters=float)\n    array([1.e+00, 2.7e+00, 1.e+05])\n\n    This idea can be extended to automatically handle values specified in\n    many different formats, such as hex values:\n\n    >>> def conv(val):\n    ...     try:\n    ...         return float(val)\n    ...     except ValueError:\n    ...         return float.fromhex(val)\n    >>> s = StringIO(\"1, 2.5, 3_000, 0b4, 0x1.4000000000000p+2\")\n    >>> np.loadtxt(s, delimiter=\",\", converters=conv)\n    array([1.0e+00, 2.5e+00, 3.0e+03, 1.8e+02, 5.0e+00])\n\n    Or a format where the ``-`` sign comes after the number:\n\n    >>> s = StringIO(\"10.01 31.25-\\n19.22 64.31\\n17.57- 63.94\")\n    >>> conv = lambda x: -float(x[:-1]) if x.endswith(\"-\") else float(x)\n    >>> np.loadtxt(s, converters=conv)\n    array([[ 10.01, -31.25],\n           [ 19.22,  64.31],\n           [-17.57,  63.94]])\n\n    Support for quoted fields is enabled with the `quotechar` parameter.\n    Comment and delimiter characters are ignored when they appear within a\n    quoted item delineated by `quotechar`:\n\n    >>> s = StringIO('\"alpha, #42\", 10.0\\n\"beta, #64\", 2.0\\n')\n    >>> dtype = np.dtype([(\"label\", \"U12\"), (\"value\", float)])\n    >>> np.loadtxt(s, dtype=dtype, delimiter=\",\", quotechar='\"')\n    array([('alpha, #42', 10.), ('beta, #64',  2.)],\n          dtype=[('label', '<U12'), ('value', '<f8')])\n\n    Quoted fields can be separated by multiple whitespace characters:\n\n    >>> s = StringIO('\"alpha, #42\"       10.0\\n\"beta, #64\" 2.0\\n')\n    >>> dtype = np.dtype([(\"label\", \"U12\"), (\"value\", float)])\n    >>> np.loadtxt(s, dtype=dtype, delimiter=None, quotechar='\"')\n    array([('alpha, #42', 10.), ('beta, #64',  2.)],\n          dtype=[('label', '<U12'), ('value', '<f8')])\n\n    Two consecutive quote characters within a quoted field are treated as a\n    single escaped character:\n\n    >>> s = StringIO('\"Hello, my name is \"\"Monty\"\"!\"')\n    >>> np.loadtxt(s, dtype=\"U\", delimiter=\",\", quotechar='\"')\n    array('Hello, my name is \"Monty\"!', dtype='<U26')\n\n    Read subset of columns when all rows do not contain equal number of values:\n\n    >>> d = StringIO(\"1 2\\n2 4\\n3 9 12\\n4 16 20\")\n    >>> np.loadtxt(d, usecols=(0, 1))\n    array([[ 1.,  2.],\n           [ 2.,  4.],\n           [ 3.,  9.],\n           [ 4., 16.]])\n\n    \"\"\"\n\n    if like is not None:\n        return _loadtxt_with_like(\n            like, fname, dtype=dtype, comments=comments, delimiter=delimiter,\n            converters=converters, skiprows=skiprows, usecols=usecols,\n            unpack=unpack, ndmin=ndmin, encoding=encoding,\n            max_rows=max_rows\n        )\n\n    if isinstance(delimiter, bytes):\n        delimiter.decode(\"latin1\")\n\n    if dtype is None:\n        dtype = np.float64\n\n    comment = comments\n    # Control character type conversions for Py3 convenience\n    if comment is not None:\n        if isinstance(comment, (str, bytes)):\n            comment = [comment]\n        comment = [\n            x.decode('latin1') if isinstance(x, bytes) else x for x in comment]\n    if isinstance(delimiter, bytes):\n        delimiter = delimiter.decode('latin1')\n\n    arr = _read(fname, dtype=dtype, comment=comment, delimiter=delimiter,\n                converters=converters, skiplines=skiprows, usecols=usecols,\n                unpack=unpack, ndmin=ndmin, encoding=encoding,\n                max_rows=max_rows, quote=quotechar)\n\n    return arr\n\n\n_loadtxt_with_like = array_function_dispatch()(loadtxt)\n\n\ndef _savetxt_dispatcher(fname, X, fmt=None, delimiter=None, newline=None,\n                        header=None, footer=None, comments=None,\n                        encoding=None):\n    return (X,)\n\n\n@array_function_dispatch(_savetxt_dispatcher)\ndef savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\\n', header='',\n            footer='', comments='# ', encoding=None):\n    \"\"\"\n    Save an array to a text file.\n\n    Parameters\n    ----------\n    fname : filename, file handle or pathlib.Path\n        If the filename ends in ``.gz``, the file is automatically saved in\n        compressed gzip format.  `loadtxt` understands gzipped files\n        transparently.\n    X : 1D or 2D array_like\n        Data to be saved to a text file.\n    fmt : str or sequence of strs, optional\n        A single format (%10.5f), a sequence of formats, or a\n        multi-format string, e.g. 'Iteration %d -- %10.5f', in which\n        case `delimiter` is ignored. For complex `X`, the legal options\n        for `fmt` are:\n\n        * a single specifier, ``fmt='%.4e'``, resulting in numbers formatted\n          like ``' (%s+%sj)' % (fmt, fmt)``\n        * a full string specifying every real and imaginary part, e.g.\n          ``' %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej'`` for 3 columns\n        * a list of specifiers, one per column - in this case, the real\n          and imaginary part must have separate specifiers,\n          e.g. ``['%.3e + %.3ej', '(%.15e%+.15ej)']`` for 2 columns\n    delimiter : str, optional\n        String or character separating columns.\n    newline : str, optional\n        String or character separating lines.\n    header : str, optional\n        String that will be written at the beginning of the file.\n    footer : str, optional\n        String that will be written at the end of the file.\n    comments : str, optional\n        String that will be prepended to the ``header`` and ``footer`` strings,\n        to mark them as comments. Default: '# ',  as expected by e.g.\n        ``numpy.loadtxt``.\n    encoding : {None, str}, optional\n        Encoding used to encode the outputfile. Does not apply to output\n        streams. If the encoding is something other than 'bytes' or 'latin1'\n        you will not be able to load the file in NumPy versions < 1.14. Default\n        is 'latin1'.\n\n    See Also\n    --------\n    save : Save an array to a binary file in NumPy ``.npy`` format\n    savez : Save several arrays into an uncompressed ``.npz`` archive\n    savez_compressed : Save several arrays into a compressed ``.npz`` archive\n\n    Notes\n    -----\n    Further explanation of the `fmt` parameter\n    (``%[flag]width[.precision]specifier``):\n\n    flags:\n        ``-`` : left justify\n\n        ``+`` : Forces to precede result with + or -.\n\n        ``0`` : Left pad the number with zeros instead of space (see width).\n\n    width:\n        Minimum number of characters to be printed. The value is not truncated\n        if it has more characters.\n\n    precision:\n        - For integer specifiers (eg. ``d,i,o,x``), the minimum number of\n          digits.\n        - For ``e, E`` and ``f`` specifiers, the number of digits to print\n          after the decimal point.\n        - For ``g`` and ``G``, the maximum number of significant digits.\n        - For ``s``, the maximum number of characters.\n\n    specifiers:\n        ``c`` : character\n\n        ``d`` or ``i`` : signed decimal integer\n\n        ``e`` or ``E`` : scientific notation with ``e`` or ``E``.\n\n        ``f`` : decimal floating point\n\n        ``g,G`` : use the shorter of ``e,E`` or ``f``\n\n        ``o`` : signed octal\n\n        ``s`` : string of characters\n\n        ``u`` : unsigned decimal integer\n\n        ``x,X`` : unsigned hexadecimal integer\n\n    This explanation of ``fmt`` is not complete, for an exhaustive\n    specification see [1]_.\n\n    References\n    ----------\n    .. [1] `Format Specification Mini-Language\n           <https://docs.python.org/library/string.html#format-specification-mini-language>`_,\n           Python Documentation.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = y = z = np.arange(0.0,5.0,1.0)\n    >>> np.savetxt('test.out', x, delimiter=',')   # X is an array\n    >>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n    >>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\n\n    \"\"\"\n\n    class WriteWrap:\n        \"\"\"Convert to bytes on bytestream inputs.\n\n        \"\"\"\n        def __init__(self, fh, encoding):\n            self.fh = fh\n            self.encoding = encoding\n            self.do_write = self.first_write\n\n        def close(self):\n            self.fh.close()\n\n        def write(self, v):\n            self.do_write(v)\n\n        def write_bytes(self, v):\n            if isinstance(v, bytes):\n                self.fh.write(v)\n            else:\n                self.fh.write(v.encode(self.encoding))\n\n        def write_normal(self, v):\n            self.fh.write(asunicode(v))\n\n        def first_write(self, v):\n            try:\n                self.write_normal(v)\n                self.write = self.write_normal\n            except TypeError:\n                # input is probably a bytestream\n                self.write_bytes(v)\n                self.write = self.write_bytes\n\n    own_fh = False\n    if isinstance(fname, os.PathLike):\n        fname = os.fspath(fname)\n    if _is_string_like(fname):"
    },
    {
      "name": "numpy.savetxt",
      "category": "Text file I/O",
      "description": "Save an array to a text file",
      "url": "https://numpy.org/doc/stable/reference/generated/numpy.savetxt.html",
      "doc": "",
      "code": "@array_function_dispatch(_savetxt_dispatcher)\ndef savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\\n', header='',\n            footer='', comments='# ', encoding=None):\n    \"\"\"\n    Save an array to a text file.\n\n    Parameters\n    ----------\n    fname : filename, file handle or pathlib.Path\n        If the filename ends in ``.gz``, the file is automatically saved in\n        compressed gzip format.  `loadtxt` understands gzipped files\n        transparently.\n    X : 1D or 2D array_like\n        Data to be saved to a text file.\n    fmt : str or sequence of strs, optional\n        A single format (%10.5f), a sequence of formats, or a\n        multi-format string, e.g. 'Iteration %d -- %10.5f', in which\n        case `delimiter` is ignored. For complex `X`, the legal options\n        for `fmt` are:\n\n        * a single specifier, ``fmt='%.4e'``, resulting in numbers formatted\n          like ``' (%s+%sj)' % (fmt, fmt)``\n        * a full string specifying every real and imaginary part, e.g.\n          ``' %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej'`` for 3 columns\n        * a list of specifiers, one per column - in this case, the real\n          and imaginary part must have separate specifiers,\n          e.g. ``['%.3e + %.3ej', '(%.15e%+.15ej)']`` for 2 columns\n    delimiter : str, optional\n        String or character separating columns.\n    newline : str, optional\n        String or character separating lines.\n    header : str, optional\n        String that will be written at the beginning of the file.\n    footer : str, optional\n        String that will be written at the end of the file.\n    comments : str, optional\n        String that will be prepended to the ``header`` and ``footer`` strings,\n        to mark them as comments. Default: '# ',  as expected by e.g.\n        ``numpy.loadtxt``.\n    encoding : {None, str}, optional\n        Encoding used to encode the outputfile. Does not apply to output\n        streams. If the encoding is something other than 'bytes' or 'latin1'\n        you will not be able to load the file in NumPy versions < 1.14. Default\n        is 'latin1'.\n\n    See Also\n    --------\n    save : Save an array to a binary file in NumPy ``.npy`` format\n    savez : Save several arrays into an uncompressed ``.npz`` archive\n    savez_compressed : Save several arrays into a compressed ``.npz`` archive\n\n    Notes\n    -----\n    Further explanation of the `fmt` parameter\n    (``%[flag]width[.precision]specifier``):\n\n    flags:\n        ``-`` : left justify\n\n        ``+`` : Forces to precede result with + or -.\n\n        ``0`` : Left pad the number with zeros instead of space (see width).\n\n    width:\n        Minimum number of characters to be printed. The value is not truncated\n        if it has more characters.\n\n    precision:\n        - For integer specifiers (eg. ``d,i,o,x``), the minimum number of\n          digits.\n        - For ``e, E`` and ``f`` specifiers, the number of digits to print\n          after the decimal point.\n        - For ``g`` and ``G``, the maximum number of significant digits.\n        - For ``s``, the maximum number of characters.\n\n    specifiers:\n        ``c`` : character\n\n        ``d`` or ``i`` : signed decimal integer\n\n        ``e`` or ``E`` : scientific notation with ``e`` or ``E``.\n\n        ``f`` : decimal floating point\n\n        ``g,G`` : use the shorter of ``e,E`` or ``f``\n\n        ``o`` : signed octal\n\n        ``s`` : string of characters\n\n        ``u`` : unsigned decimal integer\n\n        ``x,X`` : unsigned hexadecimal integer\n\n    This explanation of ``fmt`` is not complete, for an exhaustive\n    specification see [1]_.\n\n    References\n    ----------\n    .. [1] `Format Specification Mini-Language\n           <https://docs.python.org/library/string.html#format-specification-mini-language>`_,\n           Python Documentation.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = y = z = np.arange(0.0,5.0,1.0)\n    >>> np.savetxt('test.out', x, delimiter=',')   # X is an array\n    >>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n    >>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation"
    }
  ]
}