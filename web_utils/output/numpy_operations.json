{
  "add": {
    "doc": "Add arguments element-wise.\n\nParameters:\n- x1, x2: array_like - The arrays to be added. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n- out: ndarray, None, or tuple of ndarray and None, optional - A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned.\n- where: array_like, optional - This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value.\n- **kwargs - For other keyword-only arguments, see the ufunc docs.\n\nReturns:\n- add: ndarray or scalar - The sum of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars.\n\nNotes:\nEquivalent to x1 + x2 in terms of array broadcasting.\n\nThe + operator can be used as a shorthand for np.add on ndarrays.",
    "code": "numpy.add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature]) = <ufunc 'add'>"
  },
  "subtract": {
    "doc": "Subtract arguments, element-wise.\n\nParameters:\n- x1, x2: array_like - The arrays to be subtracted from each other. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n- out: ndarray, None, or tuple of ndarray and None, optional - A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned.\n- where: array_like, optional - This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value.\n- **kwargs - For other keyword-only arguments, see the ufunc docs.\n\nReturns:\n- y: ndarray - The difference of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars.\n\nNotes:\nEquivalent to x1 - x2 in terms of array broadcasting.\n\nThe - operator can be used as a shorthand for np.subtract on ndarrays.",
    "code": "numpy.subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature]) = <ufunc 'subtract'>"
  },
  "multiply": {
    "doc": "Multiply arguments element-wise.\n\nParameters:\n- x1, x2: array_like - Input arrays to be multiplied. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n- out: ndarray, None, or tuple of ndarray and None, optional - A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned.\n- where: array_like, optional - This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value.\n- **kwargs - For other keyword-only arguments, see the ufunc docs.\n\nReturns:\n- y: ndarray - The product of x1 and x2, element-wise. This is a scalar if both x1 and x2 are scalars.\n\nNotes:\nEquivalent to x1 * x2 in terms of array broadcasting.\n\nThe * operator can be used as a shorthand for np.multiply on ndarrays.",
    "code": "numpy.multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature]) = <ufunc 'multiply'>"
  },
  "divide": {
    "doc": "Divide arguments element-wise.\n\nParameters:\n- x1: array_like - Dividend array.\n- x2: array_like - Divisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n- out: ndarray, None, or tuple of ndarray and None, optional - A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned.\n- where: array_like, optional - This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value.\n- **kwargs - For other keyword-only arguments, see the ufunc docs.\n\nReturns:\n- y: ndarray or scalar - The quotient x1/x2, element-wise. This is a scalar if both x1 and x2 are scalars.\n\nSee also:\n- seterr: Set whether to raise or warn on overflow, underflow and division by zero.\n\nNotes:\nEquivalent to x1 / x2 in terms of array-broadcasting.\n\nThe true_divide(x1, x2) function is an alias for divide(x1, x2).\n\nThe / operator can be used as a shorthand for np.divide on ndarrays.",
    "code": "numpy.divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature]) = <ufunc 'divide'>"
  },
  "transpose": {
    "doc": "Returns an array with axes transposed.\n\nFor a 1-D array, this returns an unchanged view of the original array, as a transposed vector is simply the same vector. To convert a 1-D array into a 2-D column vector, an additional dimension must be added, e.g., np.atleast_2d(a).T achieves this, as does a[:, np.newaxis]. For a 2-D array, this is the standard matrix transpose. For an n-D array, if axes are given, their order indicates how the axes are permuted. If axes are not provided, then transpose(a).shape == a.shape[::-1].\n\nParameters:\n- a: array_like - Input array.\n- axes: tuple or list of ints, optional - If specified, it must be a tuple or list which contains a permutation of [0, 1, â€¦, N-1] where N is the number of axes of a. Negative indices can also be used to specify axes. The i-th axis of the returned array will correspond to the axis numbered axes[i] of the input. If not specified, defaults to range(a.ndim)[::-1], which reverses the order of the axes.\n\nReturns:\n- p: ndarray - a with its axes permuted. A view is returned whenever possible.\n\nSee also:\n- ndarray.transpose: Equivalent method.\n- moveaxis: Move axes of an array to new positions.\n- argsort: Return the indices that would sort an array.\n\nNotes:\nUse transpose(a, argsort(axes)) to invert the transposition of tensors when using the axes keyword argument.",
    "code": "numpy.transpose(a, axes=None)"
  },
  "reshape": {
    "doc": "Gives a new shape to an array without changing its data.\n\nParameters:\n- a: array_like - Array to be reshaped.\n- shape: int or tuple of ints - The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.\n- order: {'C', 'F', 'A'}, optional - Read the elements of a using this index order, and place the elements into the reshaped array using this index order. 'C' means to read / write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. 'F' means to read / write the elements using Fortran-like index order, with the first index changing fastest, and the last index changing slowest. 'A' means to read / write the elements in Fortran-like index order if a is Fortran contiguous in memory, C-like order otherwise.\n- newshape: int or tuple of ints - Deprecated since version 2.1: Replaced by shape argument. Retained for backward compatibility.\n- copy: bool, optional - If True, then the array data is copied. If None, a copy will only be made if it's required by order. For False it raises a ValueError if a copy cannot be avoided. Default: None.\n\nReturns:\n- reshaped_array: ndarray - This will be a new view object if possible; otherwise, it will be a copy. Note there is no guarantee of the memory layout (C- or Fortran- contiguous) of the returned array.\n\nSee also:\n- ndarray.reshape: Equivalent method.\n\nNotes:\nIt is not always possible to change the shape of an array without copying the data.\n\nThe order keyword gives the index ordering both for fetching the values from a, and then placing the values into the output array.",
    "code": "numpy.reshape(a, /, shape=None, order='C', *, newshape=None, copy=None)"
  },
  "dot": {
    "doc": "Dot product of two arrays. Specifically,\n\n- If both a and b are 1-D arrays, it is inner product of vectors (without complex conjugation).\n- If both a and b are 2-D arrays, it is matrix multiplication, but using matmul or a @ b is preferred.\n- If either a or b is 0-D (scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a * b is preferred.\n- If a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b.\n- If a is an N-D array and b is an M-D array (where M>=2), it is a sum product over the last axis of a and the second-to-last axis of b: dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])\n\nIt uses an optimized BLAS library when possible (see numpy.linalg).\n\nParameters:\n- a: array_like - First argument.\n- b: array_like - Second argument.\n- out: ndarray, optional - Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for dot(a,b). This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.\n\nReturns:\n- output: ndarray - Returns the dot product of a and b. If a and b are both scalars or both 1-D arrays then a scalar is returned; otherwise an array is returned. If out is given, then it is returned.\n\nRaises:\n- ValueError - If the last dimension of a is not the same size as the second-to-last dimension of b.\n\nSee also:\n- vdot: Complex-conjugating dot product.\n- vecdot: Vector dot product of two arrays.\n- tensordot: Sum products over arbitrary axes.\n- einsum: Einstein summation convention.\n- matmul: '@' operator as method with out parameter.\n- linalg.multi_dot: Chained dot product.",
    "code": "numpy.dot(a, b, out=None)"
  }
}